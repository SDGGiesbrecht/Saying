thing (clients)
 (
  English: Unicode segments
  Swift: UnicodeSegments
 )
 {
  part (unit/nowhere)
   (
    English: segments
   )
   list of (Unicode segment)
 }

action (unit)
 (
  English: Unicode segments (segments: list of (Unicode segment))
 )
 Unicode segments
 create

use (clients)
 use of (Unicode segments) as list of (Unicode scalar) indexed by (Unicode segments index) separated by (Unicode segments boundary)
 {
  action (clients)
   (
    English: index after (boundary: Unicode segments boundary) in (list: Unicode segments) skipping bounds check
   )
   Unicode segments index
   {
    if ((scalar) of (boundary)) exists, unwrap it as (• scalar boundary: Unicode scalar boundary), {
     let (• segment list: list of (Unicode segment)) be ((segments) of (list))
     let (• segment index: list index) be (index after ((segment) of (boundary)) in (segment list) skipping bounds check)
     ← Unicode segments index at segment (segment index), scalar (index after (scalar boundary) in ((source) of (entry at (segment index) in (segment list))) skipping bounds check)
    }
    !
   }

  action (clients)
   (
    English: beginning of (list: Unicode segments)
   )
   Unicode segments boundary
   {
    let (• segment list: list of (Unicode segment)) be ((segments) of (list))
    let (• segment cursor: list boundary) be (beginning of (segment list))
    if (first in (segment list)) exists, unwrap it as (• first segment: Unicode segment), {
     ← Unicode segments boundary at segment (segment cursor), scalar (wrap (beginning of ((source) of (first segment: Unicode segment))) into optional)
    }
    ← Unicode segments boundary at segment (segment cursor), scalar (nothing: optional (Unicode scalar boundary))
   }

  action (clients)
   (
    English: end of (list: Unicode segments)
   )
   Unicode segments boundary
   {
    ← Unicode segments boundary at segment (end of ((segments) of (list))), scalar (nothing: optional (Unicode scalar boundary))
   }

  action (clients)
   [
    test (hidden) {
     let (• segment list: list of (Unicode segment)) start as (empty: list of (Unicode segment))
     append (example: Unicode segment) to (↓ segment list)
     append (example: Unicode segment) to (↓ segment list)
     let (• two segments: Unicode segments) be (Unicode segments (segment list))
     let (• cursor: Unicode segments boundary) start as (beginning of (two segments))
     advance (↓ cursor) to next in (two segments) skipping bounds check
     advance (↓ cursor) to next in (two segments) skipping bounds check
    }
    test (hidden) {
     let (• segment list: list of (Unicode segment)) start as (empty: list of (Unicode segment))
     append (Unicode segment at (zero: natural number) containing (Unicode text of (“  ”))) to (↓ segment list)
     let (• long segment: Unicode segments) be (Unicode segments (segment list))
     let (• cursor: Unicode segments boundary) start as (beginning of (long segment))
     advance (↓ cursor) to next in (long segment) skipping bounds check
     advance (↓ cursor) to next in (long segment) skipping bounds check
    }
   ]
   (
    English: advance (cursor: ↓ Unicode segments boundary) to next in (list: Unicode segments) skipping bounds check
   )
   {
    change (↓ cursor) to (boundary after (cursor) in (list) skipping bounds check)
   }

  action (clients)
   (
    English: boundary after (cursor: Unicode segments boundary) in (list: Unicode segments) skipping bounds check
   )
   Unicode segments boundary
   {
    let (• segment list: list of (Unicode segment)) be ((segments) of (list))
    let (• segment cursor: list boundary) be ((segment) of (cursor))
    let (• segment: Unicode text) be ((source) of (entry at (index after (segment cursor) in (segment list) skipping bounds check) in (segment list)))
    if ((scalar) of (cursor)) exists, unwrap it as (• scalar cursor: Unicode scalar boundary), {
     let (• next scalar: Unicode scalar boundary) be (boundary after (scalar cursor) in (segment) skipping bounds check)
     if ((next scalar) is (end of (segment))), {
      let (• next segment cursor: list boundary) be (boundary after (segment cursor) in (segment list) skipping bounds check)
      if ((next segment cursor) is (end of (segment list))), {
       ← Unicode segments boundary at segment (next segment cursor), scalar (nothing: optional (Unicode scalar boundary))
      }
      ← Unicode segments boundary at segment (next segment cursor), scalar (wrap (beginning of ((source) of (entry at (index after (next segment cursor) in (segment list) skipping bounds check) in (segment list)))) into optional)
     }
     ← Unicode segments boundary at segment (segment cursor), scalar (wrap (next scalar) into optional)
    }
    !
   }

  action (clients)
   (
    English: entry at (index: Unicode segments index) in (list: Unicode segments)
   )
   Unicode scalar
   {
    ← entry at ((scalar) of (index)) in ((source) of (entry at ((segment) of (index)) in ((segments) of (list))))
   }

  action (clients)
   (
    English: empty
    Deutsch: leer
    français : vide
    ελληνικά: άδειος
   )
   Unicode segments
   {
    ← Unicode segments (empty: list of (Unicode segment))
   }

  action (clients)
   (
    English: non‐empty example
   )
   Unicode segments
   {
    ← Unicode segments (non‐empty example: list of (Unicode segment))
   }
 }

use (clients)
 slicing (Unicode segments) as list of (Unicode scalar) indexed by (Unicode segments index) separated by (Unicode segments boundary)
 {
 }
