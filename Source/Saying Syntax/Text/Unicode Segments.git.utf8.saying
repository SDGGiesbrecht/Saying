thing (clients)
 (
  English: Unicode segments
  Swift: UnicodeSegments
 )
 {
  part (unit/nowhere)
   (
    English: segments
   )
   list of (Unicode segment)
 }

action (unit)
 (
  English: Unicode segments (segments: list of (Unicode segment))
 )
 Unicode segments
 create

use
 use of (Unicode segments) as list of (Unicode scalar) indexed by (Unicode segments index) separated by (Unicode segments boundary)
 {
  action (clients)
   (
    English: unsafe index after (boundary: Unicode segments boundary)
   )
   Unicode segments index
   {
    ← unsafe Unicode segments index after (boundary)
   }

  action (clients)
   (
    English: unsafe boundary before (index: Unicode segments index)
   )
   Unicode segments boundary
   {
    ← (preceding boundary) of (index)
   }

  action (clients)
   [
    test {ignore (beginning of (empty: Unicode segments))}
   ]
   (
    English: beginning of (list: Unicode segments)
   )
   Unicode segments boundary
   {
    let (• segment list: list of (Unicode segment)) be ((segments) of (list))
    let (• segment cursor: list boundary) be (beginning of (segment list))
    if (first in (segment list)) exists, unwrap it as (• first segment: Unicode segment), {
     ← Unicode segments boundary at segment (segment cursor), scalar (wrap (beginning of ((source) of (first segment: Unicode segment))) into optional)
    }
    ← Unicode segments boundary at segment (segment cursor), scalar (nothing: optional (Unicode scalar boundary))
   }

  action (clients)
   (
    English: end of (list: Unicode segments)
   )
   Unicode segments boundary
   {
    ← Unicode segments boundary at segment (end of ((segments) of (list))), scalar (nothing: optional (Unicode scalar boundary))
   }

  action (clients)
   [
    test {
     let (• segment list: list of (Unicode segment)) start as (empty: list of (Unicode segment))
     append (example: Unicode segment) to (↓ segment list)
     append (example: Unicode segment) to (↓ segment list)
     let (• two segments: Unicode segments) be (Unicode segments (segment list))
     let (• cursor: Unicode segments boundary) start as (beginning of (two segments))
     unsafely advance (↓ cursor) to next in (two segments)
     unsafely advance (↓ cursor) to next in (two segments)
    }
    test {
     let (• segment list: list of (Unicode segment)) start as (empty: list of (Unicode segment))
     append (Unicode segment at (zero: natural number) containing (Unicode text of (“  ”))) to (↓ segment list)
     let (• long segment: Unicode segments) be (Unicode segments (segment list))
     let (• cursor: Unicode segments boundary) start as (beginning of (long segment))
     unsafely advance (↓ cursor) to next in (long segment)
     unsafely advance (↓ cursor) to next in (long segment)
    }
   ]
   (
    English: unsafely advance (cursor: ↓ Unicode segments boundary) to next in (list: Unicode segments)
   )
   {
    change (↓ cursor) to (unsafe boundary after (cursor) in (list))
   }

  action (clients)
   (
    English: unsafe boundary after (cursor: Unicode segments boundary) in (list: Unicode segments)
   )
   Unicode segments boundary
   {
    let (• segment list: list of (Unicode segment)) be ((segments) of (list))
    let (• segment cursor: list boundary) be ((segment) of (cursor))
    let (• segment: Unicode text) be ((source) of (unsafe entry after (segment cursor) in (segment list)))
    if ((scalar) of (cursor)) exists, unwrap it as (• scalar cursor: Unicode scalar boundary), {
     let (• next scalar: Unicode scalar boundary) be (unsafe boundary after (scalar cursor) in (segment))
     if ((next scalar) is (end of (segment))), {
      let (• next segment cursor: list boundary) be (unsafe boundary after (segment cursor) in (segment list))
      if ((next segment cursor) is (end of (segment list))), {
       ← Unicode segments boundary at segment (next segment cursor), scalar (nothing: optional (Unicode scalar boundary))
      }
      ← Unicode segments boundary at segment (next segment cursor), scalar (wrap (beginning of ((source) of (unsafe entry after (next segment cursor) in (segment list)))) into optional)
     }
     ← Unicode segments boundary at segment (segment cursor), scalar (wrap (next scalar) into optional)
    }
    !
   }

  action (clients)
   (
    English: unsafe entry after (cursor: Unicode segments boundary) in (list: Unicode segments)
   )
   Unicode scalar
   {
    if ((scalar) of (cursor)) exists, unwrap it as (• scalar cursor: Unicode scalar boundary), {
     ← unsafe entry after (scalar cursor) in ((source) of (unsafe entry after ((segment) of (cursor)) in ((segments) of (list))))
    }
    !
   }

  action (clients)
   (
    English: non‐empty example
   )
   Unicode segments
   {
    ← Unicode segments (non‐empty example: list of (Unicode segment))
   }
 }

action (clients)
 (
  English: empty
  Deutsch: leer
  français : vide
  ελληνικά: άδειος
 )
 Unicode segments
 {
  ← Unicode segments (empty: list of (Unicode segment))
 }
