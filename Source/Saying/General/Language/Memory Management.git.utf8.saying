thing (file)
 [
  [
   English: A tracker that can be used to trace and test reference counting done by the Saying compiler.
  ]
  test {
   let (• secret hold: reference tracker) be (create reference tracker)
   verify (reference count of (secret hold) is (one: platform fixed‐width integer))
   let (• tracker: reference tracker) be (restart (secret hold))
   verify (reference count of (tracker) is (one: platform fixed‐width integer))
   release (tracker)
   verify (reference count of (tracker) is (zero: platform fixed‐width integer))
   ignore (hold (tracker))
   verify (reference count of (tracker) is (one: platform fixed‐width integer))
  }
 ]
 (
  English: reference tracker
 )
 C: “reference¤(5F)tracker¤(2A)”/“hold¤(5F)reference¤(5F)tracker(” tracker “)”/“release¤(5F)reference¤(5F)tracker(” tracker “)”/“copy¤(5F)reference¤(5F)tracker(” tracker “)” (
  “err”
  “stdbool”
  “stdlib”
  ) {
   “typedef struct reference¤(5F)tracker {¤(A)int tracked¤(5F)references;¤(A)int all¤(5F)references;¤(A)} reference¤(5F)tracker;”
   “reference¤(5F)tracker¤(2A) hold¤(5F)reference¤(5F)tracker(reference¤(5F)tracker¤(2A) tracker)¤(A){¤(A)tracker¤(2D)>tracked¤(5F)references += 1;¤(A)tracker¤(2D)>all¤(5F)references += 1;¤(A)}”
   “void release¤(5F)reference¤(5F)tracker(reference¤(5F)tracker¤(2A) tracker)¤(A){¤(A)tracker¤(2D)>tracked¤(5F)references ¤(2D)= 1;¤(A)tracker¤(2D)>all¤(5F)references ¤(2D)= 1;¤(A)if (tracker¤(2D)>all¤(5F)references == 0)¤(A){¤(A)free(tracker);¤(A)}¤(A)}”
   “reference¤(5F)tracker¤(2A) copy¤(5F)reference¤(5F)tracker(reference¤(5F)tracker¤(2A) tracker)¤(A){¤(A)reference¤(5F)tracker¤(2A) copy = malloc(sizeof(reference¤(5F)tracker));¤(A)if (!copy)¤(A){¤(A)err(EXIT¤(5F)FAILURE, ¤(22)malloc¤(22));¤(A)}¤(A)¤(2A)copy = (reference¤(5F)tracker) {1, 1};¤(A)return copy;¤(A)}”
  }
 {
 }

action (file)
 [
  [
   English: Creates a reference tracker with its reference count still at zero.
  ]
 ]
 (
  English: create reference tracker
 )
 reference tracker
 C: “create¤(5F)reference¤(5F)tracker()” {“reference¤(5F)tracker¤(2A) create¤(5F)reference¤(5F)tracker()¤(A){¤(A)reference¤(5F)tracker¤(2A) tracker = malloc(sizeof(reference¤(5F)tracker));¤(A)if (!tracker)¤(A){¤(A)err(EXIT¤(5F)FAILURE, ¤(22)malloc¤(22));¤(A)}¤(A)¤(2A)tracker = (reference¤(5F)tracker) {1, 1};¤(A)return tracker;¤(A)}”}
 create

use (file)
 general use of (reference tracker)
 {
 }

action (file)
 [
  [
   English: Restarts the reference tracker and returns it at a count of one as though it were freshly created.
  ]
 ]
 (
  English: restart (tracker: reference tracker)
 )
 reference tracker
 C: “restart¤(5F)reference¤(5F)tracker(” tracker “)” {“reference¤(5F)tracker¤(2A) restart¤(5F)reference¤(5F)tracker(reference¤(5F)tracker¤(2A) tracker)¤(A){¤(A)tracker¤(2D)>tracked¤(5F)references = 0;¤(A)return hold¤(5F)reference¤(5F)tracker(tracker);¤(A)}”}
 {
  ← tracker
 }

action (file)
 (
  English: hold (tracker: reference tracker)
 )
 reference tracker
 C: “hold¤(5F)reference¤(5F)tracker(” tracker “)”
 {
  ← tracker
 }

action (file)
 (
  English: release (tracker: reference tracker)
 )
 C: “release¤(5F)reference¤(5F)tracker(” tracker “)”
 {}

action (file)
 [
  [
   English: Compares the reference count, but only on platforms where the Saying compiler is responsible for reference counting.
  ]
  [
   English: On other platforms, where the check is meaningless, the result is always {true}.
  ]
 ]
 (
  English: reference count of (tracker: reference tracker) is (expected count: platform fixed‐width integer)
 )
 truth value
 C: “” tracker “¤(2D)>tracked¤(5F)references == ” expected count “”
 {
  ← true
 }

action (file) (tests)
 [
  test {
   let (• tracker: reference tracker) be (create reference tracker)
   use local reference with (tracker)
   verify (reference count of (tracker) is (zero: platform fixed‐width integer))
  }
 ]
 (
  English: use local reference with (tracker: reference tracker)
 )
 {
  let (• reference: reference tracker) be (restart (tracker))
  verify (reference count of (reference) is (one: platform fixed‐width integer))
  ignore (reference)
 }
