extension
 general containers of (thing)
 {
  thing (unit)
   [
    [
     English: A rudimentary list whose memory and length must be managed manually.
    ]
    [
     English: Never attempt to access any index outside of the allocated range.
    ]
    [
     English: While the lifetime of the list itself is the reponsibility of the developer, ownership of individual entries is managed automatically by the compiler. However, for it to work properly, two rules must be followed. (1) Indices must be initialized before being accessed in any other way. (2) At clean‐up, the specified endpoint must encompass all initialized indices and none that are uninitialized.
    ]
    test {
     let (• end: list boundary) be (end of list containing (one: natural number) entries)
     let (• list: unmanaged list of (reference tracker) of unknown length) start as (allocate memory up to (end): unmanaged list of (reference tracker) of unknown length)
     let (• first index: list index) be (index after (beginning of (list)) in (list) skipping bounds check)
     let (• original tracker: reference tracker) be (create reference tracker)
     initialize entry at (first index) in (↓ list) to (restart (original tracker))
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     ignore (entry at (first index) in (list))
     verify (reference count of (original tracker) is (three: platform fixed‐width integer))
     let (• replacement tracker: reference tracker) be (create reference tracker)
     replace (first index) in (↓ list) with (restart (replacement tracker))
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     verify (reference count of (replacement tracker) is (two: platform fixed‐width integer))
     clean (list) up up to (end)
     verify (reference count of (replacement tracker) is (one: platform fixed‐width integer))
    }
   ]
   (
    English: unmanaged list of (thing) of unknown length
   )
   C: “” thing “¤(2A)”
   {
    part (file)
     (
      English: managed
     )
     list of (thing)
   }

  action (file)
   [
    test {
     ignore (unmanaged (empty: list of (thing)))
    }
   ]
   (
    English: unmanaged (managed: list of (thing))
   )
   unmanaged list of (thing) of unknown length
   C: “(” thing “¤(2A))” managed “¤(2D)>data”
   create

  use (unit)
   general use of (unmanaged list of (thing) of unknown length)
   {
   }

  action (unit)
   (
    English: unallocated
   )
   unmanaged list of (thing) of unknown length
   C: “NULL” (“stddef”)
   {
    ← unmanaged (empty: list of (thing))
   }

  action (file)
   (
    English: (first: unmanaged list of (thing) of unknown length) and (second: unmanaged list of (thing) of unknown length) share address
   )
   truth value
   C: “” first “ == ” second “”
   {
    ← false
   }

  action (file)
   (
    English: allocate memory up to (end: list boundary) skipping success check
   )
   unmanaged list of (thing) of unknown length
   C: “malloc(” end “ ¤(2A) sizeof(” thing “))” (“stdlib”)
   {
    let (• list: list of (thing)) start as (empty: list of (thing))
    while ((end of (list)) is less than (end)), {
     append (example: thing) to (↓ list)
    }
    ← unmanaged (list)
   }

  action (unit)
   (
    English: allocate memory up to (end: list boundary)
   )
   unmanaged list of (thing) of unknown length
   {
    let (• memory: unmanaged list of (thing) of unknown length) be (allocate memory up to (end) skipping success check: unmanaged list of (thing) of unknown length)
    if ((memory) and (unallocated: unmanaged list of (thing) of unknown length) share address), abort due to memory allocation failure
    ← memory
   }

  action (unit)
   (
    English: initialize entry at (index: list index) in (list: ↓ unmanaged list of (thing) of unknown length) to (element: thing)
   )
   C: “” list “[” index “] = ” hold on (element) “”
   {
    replace (index) in (↓ (managed) of (list)) with (element)
   }

  action (unit)
   (
    English: hold entry (entry: thing)
   )
   C: “” hold on (entry) “”
   {}

  action (file)
   (
    English: release entry (entry: thing)
   )
   C: “” release of (entry) “”
   {}

  action (file)
   (
    English: deallocate memory of (list: unmanaged list of (thing) of unknown length)
   )
   C: “free(” list “)”
   {}

  action (unit)
   (
    English: clean (list: unmanaged list of (thing) of unknown length) up up to (end: list boundary)
   )
   {
    let (• cursor: list boundary) start as (beginning of (list))
    while ((cursor) is less than (end)), {
     release entry (entry at (index after (cursor) in (list) skipping bounds check) in (list))
     advance (↓ cursor) to next in (list) skipping bounds check
    }
    deallocate memory of (list)
   }

  action (file)
   (
    English: reallocate memory of (list: unmanaged list of (thing) of unknown length) up to (end: list boundary) skipping success check
   )
   unmanaged list of (thing) of unknown length
   C: “realloc(” list “, ” end “ ¤(2A) sizeof(” thing “))” (“stdlib”)
   {
    let (• copy: unmanaged list of (thing) of unknown length) start as (list)
    while ((end of ((managed) of (copy))) is less than (end)), {
     append (example: thing) to (↓ (managed) of (copy))
    }
    ← copy
   }

  action (unit)
   [
    test {
     let (• list: unmanaged list of (reference tracker) of unknown length) start as (allocate memory up to (end of list containing (one: natural number) entries): unmanaged list of (reference tracker) of unknown length)
     reallocate memory of (↓ list) up to (end of list containing (two: natural number) entries)
     clean (list) up up to (end of list containing (zero: natural number) entries)
    }
   ]
   (
    English: reallocate memory of (list: ↓ unmanaged list of (thing) of unknown length) up to (end: list boundary)
   )
   {
    if ((end) is (end of empty list)), {
     clean (list) up up to (end of empty list)
    }, otherwise {
     let (• memory: unmanaged list of (thing) of unknown length) be (reallocate memory of (list) up to (end) skipping success check: unmanaged list of (thing) of unknown length)
     if ((memory) and (unallocated: unmanaged list of (thing) of unknown length) share address), abort due to memory allocation failure
     change (↓ list) to (memory)
    }
   }

  action (file)
   (
    English: copy memory of (amount: list boundary) entries from (origin: unmanaged list of (thing) of unknown length) to (destination: unmanaged list of (thing) of unknown length)
   )
   C: “memmove(” destination “, ” origin “, ” amount “ ¤(2A) sizeof(” thing “))” (“string”)
   {}

  action (file)
   (
    English: pointer to (boundary: list boundary) in (list: unmanaged list of (thing) of unknown length)
   )
   unmanaged list of (thing) of unknown length
   C: “” list “ + ” boundary “”
   {
    ← unmanaged (empty: list of (thing))
   }

  action (file)
   (
    English: synchronize mock behind (list: ↓ unmanaged list of (thing) of unknown length) to match copy of (range: range of (list boundary)) from (origin: unmanaged list of (thing) of unknown length) to (destination: list boundary)
   )
   C: “”
   {
    let (• extraction: slice of (list of (thing))) be ((range) in ((managed) of (origin)))
    let (• overwrite: range of (list boundary)) be (from (destination) to (distance (length of (range)) after (destination)))
    replace (overwrite) in (↓ (managed) of (list)) with (extraction)
   }

  action (file)
   (
    English: copy memory of (range: range of (list boundary)) from (origin: unmanaged list of (thing) of unknown length) to (destination: list boundary) in (list: ↓ unmanaged list of (thing) of unknown length)
   )
   {
    copy memory of (length of (range)) entries from (pointer to ((lower bound) of (range)) in (origin)) to (pointer to (destination) in (list))
    synchronize mock behind (↓ list) to match copy of (range) from (origin) to (destination)
   }

  action (unit)
   (
    English: move (range: range of (list boundary)) to (destination: list boundary) in (list: ↓ unmanaged list of (thing) of unknown length)
   )
   {
    copy memory of (range) from (list) to (destination) in (↓ list)
   }

  action (unit)
   (
    English: copy (range: range of (list boundary)) from (origin: unmanaged list of (thing) of unknown length) to (destination: list boundary) in (list: ↓ unmanaged list of (thing) of unknown length)
   )
   {
    copy memory of (range) from (origin) to (destination) in (↓ list)
    let (• cursor: list boundary) start as (destination)
    let (• end: list boundary) be (distance (length of (range)) after (destination))
    while ((cursor) is less than (end)), {
     hold entry (entry at (index after (cursor) in (list) skipping bounds check) in (list))
     advance (↓ cursor) to next in (list) skipping bounds check
    }
   }

  action (unit)
   (
    English: index after (boundary: list boundary) in (list: unmanaged list of (thing) of unknown length) skipping bounds check
    Swift: (self: [list]).indexSkippingBoundsCheck afterBoundary (boundary: [boundary])
   )
   list index
   C: “” boundary “”
   {
    ← index after (boundary) in ((managed) of (list)) skipping bounds check
   }

  action (unit)
   (
    English: boundary before (index: list index) in (list: unmanaged list of (thing) of unknown length)
   )
   list boundary
   C: “” index “”
   {
    ← boundary before (index) in ((managed) of (list))
   }

  action (unit)
   (
    English: beginning of (list: unmanaged list of (thing) of unknown length)
    Deutsch: Anfang von (Liste: [list])
    français : début de (liste: [list])
    ελληνικά: αρχή (κατάλογος: [list])
    Swift: var (self: [list]).startIndex
   )
   list boundary
   C: “0”
   {
    ← beginning of ((managed) of (list))
   }

  action (unit)
   (
    English: advance (cursor: ↓ list boundary) to next in (list: unmanaged list of (thing) of unknown length) skipping bounds check
    Swift: (self: [list]).formIndex after (i: [cursor])
   )
   C: “++” cursor “”
   {
    advance (↓ cursor) to next in ((managed) of (list)) skipping bounds check
   }

  action (unit)
   (
    English: (index: list index) is within (list: unmanaged list of (thing) of unknown length) ending at (end: list boundary)
   )
   truth value
   {
    ← (boundary before (index) in (list)) is less than (end)
   }

  action (unit)
   (
    English: entry at (index: list index) in (list: unmanaged list of (thing) of unknown length)
    Swift: (self: [list]).subscript entryIndex (index: [index])
   )
   thing
   C: “” hold on (thing) “” list “[” index “]”
   {
    ← entry at (index) in ((managed) of (list))
   }

  action (unit)
   (
    English: replace (index: list index) in (list: ↓ unmanaged list of (thing) of unknown length) with (element: thing)
   )
   {
    release entry (entry at (index) in (list))
    initialize entry at (index) in (↓ list) to (element)
   }

  action (unit)
   (
    English: remove (range: range of (list boundary)) from (list: ↓ unmanaged list of (thing) of unknown length)
   )
   {
    let (• cursor: list boundary) start as ((lower bound) of (range))
    let (• end: list boundary) be ((upper bound) of (range))
    while ((cursor) is less than (end)), {
     release entry (entry at (index after (cursor) in (list) skipping bounds check) in (list))
     advance (↓ cursor) to next in (list) skipping bounds check
    }
   }
 }

flow (file)
 (
  English: if (condition: truth value), abort due to memory allocation failure
 )
 C: “if (” condition “)¤(A){¤(A)err(EXIT¤(5F)FAILURE, ¤(22)malloc([...]) == NULL¤(22));¤(A)}” (
   “err”
   “stdlib”
  )
 {
  if (condition), {
   !
  }
 }

action (unit)
 (
  English: end of list containing (end: natural number) entries
 )
 list boundary
 C: “(size¤(5F)t)” end “”
 C♯: “(int)” end “”
 JavaScript: “” end “”
 Kotlin: “” end “.toInt()”
 Swift: “Int(” end “)”

action (unit)
 (
  English: end of empty list
 )
 list boundary
 C: “0”
 {
  ← end of list containing (zero: natural number) entries
 }

action (unit)
 (
  English: end of list containing one entry
 )
 list boundary
 C: “1”
 {
  ← end of list containing (one: natural number) entries
 }

action (file)
 (
  English: distance from (lower bound: list boundary) to (upper bound: list boundary)
 )
 list boundary
 C: “” upper bound “ ¤(2D) ” lower bound “”
 C♯: “” upper bound “ ¤(2D) ” lower bound “”
 JavaScript: “” upper bound “ ¤(2D) ” lower bound “”
 Kotlin: “” upper bound “ ¤(2D) ” lower bound “”
 Swift: “” upper bound “ ¤(2D) ” lower bound “”

action (file)
 [
  test {verify ((distance (end of list containing (one: natural number) entries) after (end of list containing (one: natural number) entries)) is (end of list containing (two: natural number) entries))}
 ]
 (
  English: distance (distance: list boundary) after (boundary: list boundary)
 )
 list boundary
 C: “” boundary “ + ” distance “”
 C♯: “” boundary “ + ” distance “”
 JavaScript: “” boundary “ + ” distance “”
 Kotlin: “” boundary “ + ” distance “”
 Swift: “” boundary “ + ” distance “”

action (file)
 (
  English: length of (range: range of (list boundary))
 )
 list boundary
 {
  ← distance from ((lower bound) of (range)) to ((upper bound) of (range))
 }
