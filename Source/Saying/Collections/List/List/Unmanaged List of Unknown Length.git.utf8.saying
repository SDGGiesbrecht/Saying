extension
 general containers of (thing)
 {
  thing (unit)
   [
    [
     English: A rudimentary list whose memory and length must be managed manually.
    ]
    [
     English: Never attempt to access any index outside of the allocated range.
    ]
    [
     English: While the lifetime of the list itself is the reponsibility of the developer, ownership of individual entries is managed automatically by the compiler. However, for it to work properly, two rules must be followed. (1) Indices must be initialized before being accessed in any other way. (2) At clean‐up, the specified endpoint must encompass all initialized indices and none that are uninitialized.
    ]
    test {
     let (• end: list boundary) be (boundary at (“1”: memory offset))
     let (• list: unmanaged list of (reference tracker) of unknown length) start as (allocate memory up to (end): unmanaged list of (reference tracker) of unknown length)
     let (• first index: list index) be (index after (beginning of (list)) in (list) skipping bounds check)
     let (• original tracker: reference tracker) be (create reference tracker)
     initialize entry at (first index) in (↓ list) to (restart (original tracker))
     verify (reference count of (original tracker) is (“2”: platform fixed‐width integer))
     ignore (entry at (first index) in (list))
     verify (reference count of (original tracker) is (“3”: platform fixed‐width integer))
     let (• replacement tracker: reference tracker) be (create reference tracker)
     replace (first index) in (↓ list) with (restart (replacement tracker))
     verify (reference count of (original tracker) is (“2”: platform fixed‐width integer))
     verify (reference count of (replacement tracker) is (“2”: platform fixed‐width integer))
     clean (list) up up to (end)
     verify (reference count of (replacement tracker) is (“1”: platform fixed‐width integer))
    }
   ]
   (
    English: unmanaged list of (thing) of unknown length
   )
   C: “” thing “¤(2A)”
   {
   }

  action (unit)
   [
    test {
     ignore (empty placeholder: unmanaged list of (thing) of unknown length)
    }
   ]
   (
    English: empty placeholder
   )
   unmanaged list of (thing) of unknown length
   C: “NULL” (“stddef”)
   create

  use (unit)
   general use of (unmanaged list of (thing) of unknown length)
   {
   }

  action (unit)
   (
    English: unmanaged list of unknown length at (address: memory address)
   )
   unmanaged list of (thing) of unknown length
   C: “(” thing “¤(2A))” address “”
   {
    ← empty placeholder
   }

  action (file)
   (
    English: memory address of (list: unmanaged list of (thing) of unknown length)
   )
   memory address
   C: “(void¤(2A))” list “”
   {
    ← unallocated
   }

  action (unit)
   (
    English: allocate memory up to (end: list boundary)
   )
   unmanaged list of (thing) of unknown length
   {
    ← unmanaged list of unknown length at (allocate (((offset) of (end)) times (size of (example: thing))) bytes of memory)
   }

  action (file)
   (
    English: initialize entry at (index: memory offset) in (list: ↓ unmanaged list of (thing) of unknown length) to (element: thing)
   )
   C: “(” list “)[” index “] = ” hold on (element) “”
   {}

  action (unit)
   (
    English: initialize entry at (index: list index) in (list: ↓ unmanaged list of (thing) of unknown length) to (element: thing)
   )
   {
    initialize entry at ((offset) of ((beginning) of (index))) in (↓ list) to (element)
   }

  action (file)
   (
    English: hold entry (entry: thing)
   )
   C: “” hold on (entry) “”
   {}

  action (file)
   (
    English: release entry (entry: thing)
   )
   C: “” release of (entry) “”
   {}

  action (file)
   (
    English: deallocate memory of (list: unmanaged list of (thing) of unknown length)
   )
   {
    deallocate memory (memory address of (list))
   }

  action (unit)
   (
    English: clean (list: unmanaged list of (thing) of unknown length) up up to (end: list boundary)
   )
   {
    let (• cursor: list boundary) start as (beginning of (list))
    while ((cursor) is less than (end)), {
     release entry (entry at (index after (cursor) in (list) skipping bounds check) in (list))
     advance (↓ cursor) to next in (list) skipping bounds check
    }
    deallocate memory of (list)
   }

  action (unit)
   [
    test {
     let (• list: unmanaged list of (reference tracker) of unknown length) start as (allocate memory up to (boundary at (“1”: memory offset)): unmanaged list of (reference tracker) of unknown length)
     reallocate memory of (↓ list) up to (boundary at (“2”: memory offset))
     clean (list) up up to (boundary at (“0”: memory offset))
    }
   ]
   (
    English: reallocate memory of (list: ↓ unmanaged list of (thing) of unknown length) up to (end: list boundary)
   )
   {
    if (((offset) of (end)) is (“0”: memory offset)), {
     clean (list) up up to (end)
    }, otherwise {
     let (• address: memory address) start as (memory address of (list))
     reallocate memory of (↓ address) to (((offset) of (end)) times (size of (example: thing))) bytes
     change (↓ list) to (unmanaged list of unknown length at (address): unmanaged list of (thing) of unknown length)
    }
   }

  action (file)
   (
    English: copy memory of (amount: memory offset) entries from (origin: unmanaged list of (thing) of unknown length) to (destination: unmanaged list of (thing) of unknown length)
   )
   {
    copy memory of ((amount) times (size of (example: thing))) bytes from (memory address of (origin)) to (memory address of (destination))
   }

  action (file)
   (
    English: pointer to (offset: memory offset) in (list: unmanaged list of (thing) of unknown length)
   )
   unmanaged list of (thing) of unknown length
   C: “” list “ + ” offset “”
   {
    ← empty placeholder
   }

  action (file)
   (
    English: pointer to (boundary: list boundary) in (list: unmanaged list of (thing) of unknown length)
   )
   unmanaged list of (thing) of unknown length
   {
    ← pointer to ((offset) of (boundary)) in (list)
   }

  action (file)
   (
    English: copy memory of (range: range of (list boundary)) from (origin: unmanaged list of (thing) of unknown length) to (destination: list boundary) in (list: ↓ unmanaged list of (thing) of unknown length)
   )
   {
    copy memory of (length of (range)) entries from (pointer to ((lower bound) of (range)) in (origin)) to (pointer to (destination) in (list))
   }

  action (unit)
   (
    English: move (range: range of (list boundary)) to (destination: list boundary) in (list: ↓ unmanaged list of (thing) of unknown length)
   )
   {
    copy memory of (range) from (list) to (destination) in (↓ list)
   }

  action (unit)
   (
    English: copy (range: range of (list boundary)) from (origin: unmanaged list of (thing) of unknown length) to (destination: list boundary) in (list: ↓ unmanaged list of (thing) of unknown length)
   )
   {
    copy memory of (range) from (origin) to (destination) in (↓ list)
    let (• cursor: list boundary) start as (destination)
    let (• end: list boundary) be (distance (length of (range)) after (destination))
    while ((cursor) is less than (end)), {
     hold entry (entry at (index after (cursor) in (list) skipping bounds check) in (list))
     advance (↓ cursor) to next in (list) skipping bounds check
    }
   }

  action (unit)
   (
    English: index after (boundary: list boundary) in (list: unmanaged list of (thing) of unknown length) skipping bounds check
    Swift: (self: [list]).indexSkippingBoundsCheck afterBoundary (boundary: [boundary])
   )
   list index
   {
    ← index after (boundary) skipping bounds check
   }

  action (unit)
   (
    English: boundary before (index: list index) in (list: unmanaged list of (thing) of unknown length)
   )
   list boundary
   {
    ← (beginning) of (index)
   }

  action (unit)
   (
    English: beginning of (list: unmanaged list of (thing) of unknown length)
    Deutsch: Anfang von (Liste: [list])
    français : début de (liste: [list])
    ελληνικά: αρχή (κατάλογος: [list])
    Swift: var (self: [list]).startIndex
   )
   list boundary
   {
    ← boundary at (“0”: memory offset)
   }

  action (unit)
   (
    English: advance (cursor: ↓ list boundary) to next in (list: unmanaged list of (thing) of unknown length) skipping bounds check
    Swift: (self: [list]).formIndex after (i: [cursor])
   )
   C♯: “++” cursor “”
   JavaScript: “++” cursor “”
   Kotlin: “++” cursor “”
   {
    increment (↓ (offset) of (cursor))
   }

  action (unit)
   (
    English: (index: list index) is within (list: unmanaged list of (thing) of unknown length) ending at (end: list boundary)
   )
   truth value
   {
    ← (boundary before (index) in (list)) is less than (end)
   }

  action (file)
   (
    English: entry at (index: memory offset) in (list: unmanaged list of (thing) of unknown length)
   )
   thing
   C: “” hold on (thing) “” list “[” index “]”
   {
    ← example
   }

  action (unit)
   (
    English: entry at (index: list index) in (list: unmanaged list of (thing) of unknown length)
    Swift: (self: [list]).subscript entryIndex (index: [index])
   )
   thing
   {
    ← entry at ((offset) of ((beginning) of (index))) in (list)
   }

  action (unit)
   (
    English: replace (index: list index) in (list: ↓ unmanaged list of (thing) of unknown length) with (element: thing)
   )
   {
    release entry (entry at (index) in (list))
    initialize entry at (index) in (↓ list) to (element)
   }

  action (unit)
   (
    English: remove (range: range of (list boundary)) from (list: ↓ unmanaged list of (thing) of unknown length)
   )
   {
    let (• cursor: list boundary) start as ((lower bound) of (range))
    let (• end: list boundary) be ((upper bound) of (range))
    while ((cursor) is less than (end)), {
     release entry (entry at (index after (cursor) in (list) skipping bounds check) in (list))
     advance (↓ cursor) to next in (list) skipping bounds check
    }
   }
 }

action (file)
 (
  English: distance from (lower bound: list boundary) to (upper bound: list boundary)
 )
 memory offset
 {
  ← ((offset) of (upper bound)) minus ((offset) of (lower bound))
 }

action (file)
 [
  test {verify ((distance (“1”: memory offset) after (boundary at (“1”: memory offset))) is (boundary at (“2”: memory offset)))}
 ]
 (
  English: distance (distance: memory offset) after (boundary: list boundary)
 )
 list boundary
 {
  ← boundary at (((offset) of (boundary)) plus (distance))
 }

action (file)
 (
  English: length of (range: range of (list boundary))
 )
 memory offset
 {
  ← distance from ((lower bound) of (range)) to ((upper bound) of (range))
 }
