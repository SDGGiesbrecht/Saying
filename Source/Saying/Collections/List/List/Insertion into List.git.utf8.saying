ability (clients)
 (
  English: insertion from (insertion) into (list) separated by (boundary)
 )
 {
  requirement (clients)
   [
    test {
     let (• list: list) start as (non‐empty example: list)
     replace (from (beginning of (list)) to (end of (list))) in (↓ list) with (insertion example: insertion)
    }
   ]
   (
    English: replace (range: range of (boundary)) in (list: ↓ list) with (replacement: insertion)
    Swift: (self: [list]).replaceSubrange (subrange: [range]) with (newElements: [replacement])
   )

  choice (clients)
   [
    test {
     let (• list: list) be (non‐empty example: list)
     ignore ((list) with (from (beginning of (list)) to (end of (list))) replaced with (insertion example: insertion))
    }
   ]
   (
    English: (list: list) with (range: range of (boundary)) replaced with (replacement: insertion)
    Swift: (self: [list]).replacingSubrange (subrange: [range]) with (newElements: [replacement])
   )
   list
   {
    ← (list) with (range) replaced with (replacement) according to list insertion
   }

  choice (clients)
   [
    test {
     let (• list: list) start as (non‐empty example: list)
     insert (insertion example: insertion) at (beginning of (list)) in (↓ list)
    }
   ]
   (
    English: insert (insertion: insertion) at (boundary: boundary) in (list: ↓ list)
    Swift: (self: [list]).insert contentsOf (newElements: [insertion]) at (i: [boundary])
   )
   {
    insert (insertion) at (boundary) in (↓ list) according to list insertion
   }

  choice (clients)
   [
    test {
     let (• list: list) be (non‐empty example: list)
     ignore ((list) with (insertion example: insertion) inserted at (beginning of (list)))
    }
   ]
   (
    English: (list: list) with (insertion: insertion) inserted at (boundary: boundary)
    Swift: (self: [list]).inserting contentsOf (newElements: [insertion]) at (boundary: [boundary])
   )
   list
   {
    ← (list) with (insertion) inserted at (boundary) according to list insertion
   }

  choice (clients)
   [
    test {
     let (• list: list) start as (non‐empty example: list)
     append (insertion example: insertion) to (↓ list)
    }
   ]
   (
    English: append (appendix: insertion) to (list: ↓ list)
    Swift: (self: [list]).append contentsOf (newElements: [appendix])
   )
   {
    append (appendix) to (↓ list) according to list insertion
   }

  choice (clients)
   [
    test {ignore ((non‐empty example: list) with (insertion example: insertion) appended)}
   ]
   (
    English: (list: list) with (appendix: insertion) appended
    Swift: (self: [list]).appending contentsOf (newElements: [appendix])
   )
   list
   {
    ← (list) with (appendix) appended according to list insertion
   }

  choice (clients)
   [
    test {
     let (• list: list) start as (non‐empty example: list)
     prepend (insertion example: insertion) to (↓ list)
    }
   ]
   (
    English: prepend (prefix: insertion) to (list: ↓ list)
    Swift: (self: [list]).prepend contentsOf (newElements: [prefix])
   )
   {
    prepend (prefix) to (↓ list) according to list insertion
   }

  choice (clients)
   [
    test {ignore ((non‐empty example: list) with (insertion example: insertion) prepended)}
   ]
   (
    English: (list: list) with (prefix: insertion) prepended
    Swift: (self: [list]).prepending contentsOf (newElements: [prefix])
   )
   list
   {
    ← (list) with (prefix) prepended according to list insertion
   }

  choice (clients)
   [
    test {ignore (convert (insertion example: insertion) into list: list)}
   ]
   (
    English: convert (other: insertion) into list
    Swift: Self.init (other: [other])
   )
   list
   {
    let (• copy: list) start as (empty: list)
    append (other) to (↓ copy)
    ← copy
   }

  requirement (clients)
   (
    English: insertion example
   )
   insertion
 }

extension
 insertion from (insertion) into (list) separated by (boundary)
 {
  action (clients)
   [
    test {
     let (• list: list) be (non‐empty example: list)
     ignore ((list) with (from (beginning of (list)) to (end of (list))) replaced with (insertion example: insertion) according to list insertion)
    }
   ]
   (
    English: (list: list) with (range: range of (boundary)) replaced with (replacement: insertion) according to list insertion
   )
   list
   {
    let (• copy: list) start as (list)
    replace (range) in (↓ copy) with (replacement)
    ← copy
   }

  action (clients)
   [
    test {
     let (• list: list) start as (non‐empty example: list)
     append (insertion example: insertion) to (↓ list) according to list insertion
    }
   ]
   (
    English: append (appendix: insertion) to (list: ↓ list) according to list insertion
   )
   {
    replace (from (end of (list)) to (end of (list))) in (↓ list) with (appendix)
   }

  action (clients)
   [
    test {ignore ((non‐empty example: list) with (insertion example: insertion) appended according to list insertion)}
   ]
   (
    English: (list: list) with (appendix: insertion) appended according to list insertion
   )
   list
   {
    let (• copy: list) start as (list)
    append (appendix) to (↓ copy)
    ← copy
   }

  action (clients)
   [
    test {
     let (• list: list) start as (non‐empty example: list)
     insert (insertion example: insertion) at (beginning of (list)) in (↓ list) according to list insertion
    }
   ]
   (
    English: insert (insertion: insertion) at (boundary: boundary) in (list: ↓ list) according to list insertion
   )
   {
    replace (from (boundary) to (boundary)) in (↓ list) with (insertion)
   }

  action (clients)
   [
    test {
     let (• list: list) be (non‐empty example: list)
     ignore ((list) with (insertion example: insertion) inserted at (beginning of (list)) according to list insertion)
    }
   ]
   (
    English: (list: list) with (insertion: insertion) inserted at (boundary: boundary) according to list insertion
   )
   list
   {
    let (• copy: list) start as (list)
    insert (insertion) at (boundary) in (↓ copy)
    ← copy
   }

  action (clients)
   [
    test {
     let (• list: list) start as (non‐empty example: list)
     prepend (insertion example: insertion) to (↓ list) according to list insertion
    }
   ]
   (
    English: prepend (prefix: insertion) to (list: ↓ list) according to list insertion
   )
   {
    replace (from (beginning of (list)) to (beginning of (list))) in (↓ list) with (prefix)
   }

  action (clients)
   [
    test {ignore ((non‐empty example: list) with (insertion example: insertion) prepended according to list insertion)}
   ]
   (
    English: (list: list) with (prefix: insertion) prepended according to list insertion
   )
   list
   {
    let (• copy: list) start as (list)
    prepend (prefix) to (↓ copy)
    ← copy
   }

  action (clients)
   (
    English: remove (range: range of (boundary)) from (list: ↓ list) according to list insertion
   )
   {
    replace (range) in (↓ list) with (empty: list)
   }
 }

use (unit)
 insertion from (minimal list example) into (minimal list example) separated by (list boundary)
 {
  action (unit)
   (
    English: replace (range: range of (list boundary)) in (list: ↓ minimal list example) with (insertion: minimal list example)
   )
   {
    replace (range) in (↓ (wrapped list) of (list)) with ((wrapped list) of (insertion))
   }

  action (unit)
   (
    English: insertion example
   )
   minimal list example
   {
    ← minimal list example wrapping (insertion example: list of (truth value))
   }
 }
