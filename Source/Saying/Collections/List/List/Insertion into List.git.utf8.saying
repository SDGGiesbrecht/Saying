ability (clients)
 (
  English: insertion from (insertion) into (list) separated by (list boundary)
 )
 {
  requirement (clients)
   [
    test {
     let (• list: list) start as (non‐empty example: list)
     replace (from (beginning of (list)) to (end of (list))) in (↓ list) with (insertion example: insertion)
    }
   ]
   (
    English: replace (range: range of (list boundary)) in (list: ↓ list) with (insertion: insertion)
   )

  choice (clients)
   [
    test {
     let (• list: list) be (non‐empty example: list)
     ignore ((list) with (from (beginning of (list)) to (end of (list))) replaced with (insertion example: insertion))
    }
   ]
   (
    English: (list: list) with (range: range of (list boundary)) replaced with (insertion: insertion)
   )
   list
   {
    let (• copy: list) start as (list)
    replace (range) in (↓ copy) with (insertion)
    ← copy
   }

  choice (clients)
   [
    test {
     let (• list: list) start as (non‐empty example: list)
     insert (insertion example: insertion) at (beginning of (list)) in (↓ list)
    }
   ]
   (
    English: insert (insertion: insertion) at (boundary: list boundary) in (list: ↓ list)
   )
   {
    insert (insertion) at (boundary) in (↓ list) according to list insertion
   }

  choice (clients)
   [
    test {
     let (• list: list) be (non‐empty example: list)
     ignore ((list) with (insertion example: insertion) inserted at (beginning of (list)))
    }
   ]
   (
    English: (list: list) with (insertion: insertion) inserted at (boundary: list boundary)
   )
   list
   {
    ← (list) with (insertion) inserted at (boundary) according to list insertion
   }

  choice (clients)
   [
    test {
     let (• list: list) start as (non‐empty example: list)
     append (insertion example: insertion) to (↓ list)
    }
   ]
   (
    English: append (appendix: insertion) to (list: ↓ list)
   )
   {
    replace (from (end of (list)) to (end of (list))) in (↓ list) with (appendix)
   }

  choice (clients)
   [
    test {ignore ((non‐empty example: list) with (insertion example: insertion) appended)}
   ]
   (
    English: (list: list) with (appendix: insertion) appended
   )
   list
   {
    ← (list) with (appendix) appended according to list insertion
   }

  choice (clients)
   [
    test {
     let (• list: list) start as (non‐empty example: list)
     prepend (insertion example: insertion) to (↓ list)
    }
   ]
   (
    English: prepend (prefix: insertion) to (list: ↓ list)
   )
   {
    prepend (prefix) to (↓ list) according to list insertion
   }

  choice (clients)
   [
    test {ignore ((non‐empty example: list) with (insertion example: insertion) prepended)}
   ]
   (
    English: (list: list) with (prefix: insertion) prepended
   )
   list
   {
    ← (list) with (prefix) prepended according to list insertion
   }

  choice (clients)
   [
    test {ignore (convert (insertion example: insertion) into list: list)}
   ]
   (
    English: convert (other: insertion) into list
   )
   list
   {
    let (• copy: list) start as (empty: list)
    append (other) to (↓ copy)
    ← copy
   }

  requirement (clients)
   (
    English: insertion example
   )
   insertion
 }

extension
 insertion from (insertion) into (list) separated by (list boundary)
 {
  action (clients)
   [
    test {ignore ((non‐empty example: list) with (insertion example: insertion) appended according to list insertion)}
   ]
   (
    English: (list: list) with (appendix: insertion) appended according to list insertion
   )
   list
   {
    let (• copy: list) start as (list)
    append (appendix) to (↓ copy)
    ← copy
   }

  action (clients)
   [
    test {
     let (• list: list) start as (non‐empty example: list)
     insert (insertion example: insertion) at (beginning of (list)) in (↓ list) according to list insertion
    }
   ]
   (
    English: insert (insertion: insertion) at (boundary: list boundary) in (list: ↓ list) according to list insertion
   )
   {
    replace (from (boundary) to (boundary)) in (↓ list) with (insertion)
   }

  action (clients)
   [
    test {
     let (• list: list) be (non‐empty example: list)
     ignore ((list) with (insertion example: insertion) inserted at (beginning of (list)) according to list insertion)
    }
   ]
   (
    English: (list: list) with (insertion: insertion) inserted at (boundary: list boundary) according to list insertion
   )
   list
   {
    let (• copy: list) start as (list)
    insert (insertion) at (boundary) in (↓ copy)
    ← copy
   }

  action (clients)
   [
    test {
     let (• list: list) start as (non‐empty example: list)
     prepend (insertion example: insertion) to (↓ list) according to list insertion
    }
   ]
   (
    English: prepend (prefix: insertion) to (list: ↓ list) according to list insertion
   )
   {
    replace (from (beginning of (list)) to (beginning of (list))) in (↓ list) with (prefix)
   }

  action (clients)
   [
    test {ignore ((non‐empty example: list) with (insertion example: insertion) prepended according to list insertion)}
   ]
   (
    English: (list: list) with (prefix: insertion) prepended according to list insertion
   )
   list
   {
    let (• copy: list) start as (list)
    prepend (prefix) to (↓ copy)
    ← copy
   }
 }

use (unit)
 insertion from (minimal list example) into (minimal list example) separated by (list boundary)
 {
  action (unit)
   (
    English: replace (range: range of (list boundary)) in (list: ↓ minimal list example) with (insertion: minimal list example)
   )
   {
    ignore (false)
   }

  action (unit)
   (
    English: insertion example
   )
   minimal list example
   {
    ← non‐empty example
   }
 }
