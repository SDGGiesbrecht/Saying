extension
 general containers of (thing)
 {
  thing (clients)
   (
    English: list of (thing)
    Deutsch: Liste von (Ding: [thing])
    français : liste de (chose: [thing])
    ελληνικά: κατάλογος (πράγμα: [thing])
    עברית: רשימה של (דבר: [thing])
   )
   C: “GArray¤(2A)”/“g¤(5F)array¤(5F)ref(” array “)”/“g¤(5F)array¤(5F)unref(” array “)”/“g¤(5F)array¤(5F)ref(” array “)” (“glib¤(2D)2.0”)
   C♯: “List<” thing “>” (“System.Collections.Generic”)
   Kotlin: “List<” thing “>”
   Swift: “[” thing “]”
   {
   }

  action (file)
   (
    English: unmanaged (list: list of (thing))
   )
   unmanaged list of (thing)
   {
    let (• end: list boundary) be (end of (list))
    ← create unmanaged list with uncounted (uncounted (list)), end (end) and limit (end)
   }

  action (file)
   (
    English: create list with unmanaged list (list: unmanaged list of (thing))
   )
   list of (thing)
   C: “g¤(5F)array¤(5F)new(FALSE, FALSE, sizeof(” thing “))”
   {
    ← (managed) of ((uncounted) of (list))
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (empty: list of (thing))
     ignore (hold (list))
     release (list)
    }
   ]
   (
    English: hold (list: list of (thing))
    C: 1 hold (list: [list])
   )
   list of (thing)
   {
    let (• unmanaged: unmanaged list of (thing)) start as (unmanaged (list))
    hold unmanaged (↓ unmanaged)
    ← list
   }

  action (file)
   [
    test (hidden) {
     let (• list: list of (thing)) be (empty: list of (thing))
     let (• unmanaged: unmanaged list of (thing)) start as (unmanaged (list))
     hold unmanaged (↓ unmanaged)
     release (list)
    }
   ]
   (
    English: release (list: list of (thing))
    C: 1 release (list: [list])
   )
   {
    let (• unmanaged: unmanaged list of (thing)) start as (unmanaged (list))
    release unmanaged (↓ unmanaged)
   }

  action (file)
   [
    test {
     ignore (copy of (empty: list of (thing)))
    }
   ]
   (
    English: copy of (list: list of (thing))
    C: 1 copy (list: [list])
   )
   list of (thing)
   {
    ← create list with unmanaged list (copy of unmanaged (unmanaged (list)))
   }

  use (clients)
   use of (list of (thing)) as list of (thing) indexed by (list index) separated by (list boundary)
   {
    action (clients)
     (
      English: index after (boundary: list boundary) in (list: list of (thing)) skipping bounds check
     )
     list index
     C: “” boundary “”
     C♯: “” boundary “”
     JavaScript: “” boundary “”
     Kotlin: “” boundary “”
     Swift: “” boundary “”

    action (clients)
     (
      English: beginning of (list: list of (thing))
     )
     list boundary
     C: “0”
     C♯: “0”
     JavaScript: “0”
     Kotlin: “0”
     Swift: “” list “.startIndex”

    action (clients)
     (
      English: end of (list: list of (thing))
     )
     list boundary
     C: “” list “¤(2D)>len”
     C♯: “” list “.Count”
     JavaScript: “” list “.length”
     Kotlin: “” list “.size”
     Swift: “” list “.endIndex”

    action (clients)
     (
      English: advance (cursor: ↓ list boundary) to next in (list: list of (thing)) skipping bounds check
     )
     C: “++” cursor “”
     C♯: “++” cursor “”
     JavaScript: “++” cursor “”
     Kotlin: “++” cursor “”
     Swift: “” list “.formIndex(after: ¤(26)” cursor “)”

    action (clients)
     (
      English: boundary after (cursor: list boundary) in (list: list of (thing)) skipping bounds check
     )
     list boundary
     C: “” cursor “ + 1”
     C♯: “” cursor “ + 1”
     JavaScript: “” cursor “ + 1”
     Kotlin: “” cursor “ + 1”
     Swift: “” list “.index(after: ” cursor “)”

    action (clients)
     (
      English: entry at (cursor: list index) in (list: list of (thing))
     )
     thing
     C: “” hold on (thing) “g¤(5F)array¤(5F)index(” list “, ” thing “, ” cursor “)”
     C♯: “” list “[” cursor “]”
     JavaScript: “” list “[” cursor “]”
     Kotlin: “” list “[” cursor “]”
     Swift: “” list “[” cursor “]”

    action (clients)
     (
      English: entry after (cursor: list boundary) in (list: list of (thing)) skipping bounds check
     )
     thing
     C: “” hold on (thing) “g¤(5F)array¤(5F)index(” list “, ” thing “, ” cursor “)”
     C♯: “” list “[” cursor “]”
     JavaScript: “” list “[” cursor “]”
     Kotlin: “” list “[” cursor “]”
     Swift: “” list “[” cursor “]”

    action (clients)
     (
      English: first in (list: list of (thing))
     )
     optional (thing)
     Kotlin: “” list “.firstOrNull()”
     Swift: “” list “.first”
     {
      ← first in (list) according to default use as list
     }

    action (clients)
     (
      English: (list: list of (thing)) is empty
     )
     truth value
     Kotlin: “” list “.isEmpty()”
     Swift: “” list “.isEmpty”
     {
      ← (list) is empty according to default use as list
     }

    action (clients)
     (
      English: (list: list of (thing)) is not empty
     )
     truth value
     Kotlin: “” list “.isNotEmpty()”
     {
      ← (list) is not empty according to default use as list
     }

    action (clients)
     (
      English: empty
     )
     list of (thing)
     C: “g¤(5F)array¤(5F)new(FALSE, FALSE, sizeof(” thing “))”
     C♯: “new List<” thing “>()”
     JavaScript: “[]”
     Kotlin: “listOf()”
     Swift: “[]”

    action (clients)
     (
      English: non‐empty example
     )
     list of (thing)
     {
      ← non‐empty example according to use as changeable list
     }
   }

  action (clients)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     let (• beginning: list boundary) be (beginning of (list))
     verify ((boundary before (index after (beginning) in (list) skipping bounds check) in (list)) is (beginning))
    }
   ]
   (
    English: boundary before (index: list index) in (list: list of (thing))
   )
   list boundary
   C: “” index “”
   C♯: “” index “”
   JavaScript: “” index “”
   Kotlin: “” index “”
   Swift: “” index “”

  use (clients)
   slicing (list of (thing)) as list of (thing) indexed by (list index) separated by (list boundary)
   {
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     remove from (beginning of (list)) to (end of (list)) from (↓ list)
    }
   ]
   (
    English: remove from (beginning: list boundary) to (end: list boundary) from (list: ↓ list of (thing))
   )
   C: “g¤(5F)array¤(5F)remove¤(5F)range(” list “, ” beginning “, ” end “ ¤(2D) ” beginning “)”
   C♯: “” list “.RemoveRange(” beginning “, ” end “ ¤(2D) ” beginning “)”
   JavaScript: “” list “.splice(” beginning “, ” end “ ¤(2D) ” beginning “)”
   {
    replace from (beginning) to (end) in (↓ list) with (empty: list of (thing))
   }

  use (clients)
   use of (list of (thing)) as changeable list of (thing) indexed by (list index) separated by (list boundary)
   {
    action (clients)
     (
      English: replace (index: list index) in (list: ↓ list of (thing)) with (element: thing)
     )
     C: “g¤(5F)array¤(5F)index(” list “, ” thing “, ” index “) = ” hold on (element) “”
     C♯: “” list “[” index “] = ” element “”
     JavaScript: “” list “[” index “] = ” element “”
     Swift: “” list “[” index “] = ” element “”
     {
      change (↓ list) to ((list) with (index) replaced with (element))
     }

    action (clients)
     (
      English: (list: list of (thing)) with (index: list index) replaced with (element: thing)
     )
     list of (thing)
     Kotlin: “” list “.toMutableList().apply { this[” index “] = ” element “ }.toList()”
     {
      ← (list) with (index) replaced with (element) according to use as changeable list
     }

    action (clients)
     (
      English: insert (element: thing) at (boundary: list boundary) in (list: ↓ list of (thing))
     )
     C: “g¤(5F)array¤(5F)insert¤(5F)val(” list “, ” boundary “, ((struct { ” thing “ value; }) { ” hold on (element) “ }).value)”
     C♯: “” list “.Insert(” boundary “, ” element “)”
     JavaScript: “” list “.splice(” boundary “, 0, ” element “)”
     Swift: “” list “.insert(” element “, at: ” boundary “)”
     {
      change (↓ list) to ((list) with (element) inserted at (boundary))
     }

    action (clients)
     (
      English: (list: list of (thing)) with (element: thing) inserted at (boundary: list boundary)
     )
     list of (thing)
     Kotlin: “” list “.toMutableList().apply { add(” boundary “, ” element “) }.toList()”
     {
      ← (list) with (element) inserted at (boundary) according to use as changeable list
     }

    action (clients)
     (
      English: append (element: thing) to (list: ↓ list of (thing))
     )
     C: “g¤(5F)array¤(5F)append¤(5F)val(” list “, ((struct { ” thing “ value; }) { ” hold on (element) “ }).value)”
     C♯: “” list “.Add(” element “)”
     JavaScript: “” list “.push(” element “)”
     Swift: “” list “.append(” element “)”
     {
      change (↓ list) to ((list) with (element) appended)
     }

    action (clients)
     (
      English: (list: list of (thing)) with (element: thing) appended
     )
     list of (thing)
     Kotlin: “” list “.toMutableList().apply { add(” element “) }.toList()”
     {
      ← (list) with (element) appended according to use as changeable list
     }

    action (clients)
     (
      English: prepend (element: thing) to (list: ↓ list of (thing))
     )
     C: “g¤(5F)array¤(5F)prepend¤(5F)val(” list “, ((struct { ” thing “ value; }) { ” hold on (element) “ }).value)”
     JavaScript: “” list “.unshift(” element “)”
     {
      prepend (element) to (↓ list) according to use as changeable list
     }

    action (clients)
     (
      English: (list: list of (thing)) with (element: thing) prepended
     )
     list of (thing)
     C♯: “” list “.Prepend(” element “).ToList()” (“System.Linq”)
     {
      ← (list) with (element) prepended according to use as changeable list
     }

    action (clients)
     (
      English: remove (index: list index) from (list: ↓ list of (thing))
     )
     C: “g¤(5F)array¤(5F)remove¤(5F)index(” list “, ” index “)”
     C♯: “” list “.RemoveAt(” index “)”
     JavaScript: “” list “.splice(” index “, 0)”
     Swift: “” list “.remove(at: ” index “)”
     {
      change (↓ list) to ((list) with (index) removed)
     }

    action (clients)
     (
      English: (list: list of (thing)) with (index: list index) removed
     )
     list of (thing)
     Kotlin: “” list “.toMutableList().apply { removeAt(” index “) }.toList()”
     {
      ← (list) with (index) removed according to use as changeable list
     }

    action (clients)
     (
      English: remove (range: range of (list boundary)) from (list: ↓ list of (thing))
     )
     Swift: “” list “.removeSubrange(” range “)”
     {
      remove from ((lower bound) of (range)) to ((upper bound) of (range)) from (↓ list)
     }
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     replace from (beginning of (list)) to (end of (list)) in (↓ list) with (insertion example: list of (thing))
    }
   ]
   (
    English: replace from (beginning: list boundary) to (end: list boundary) in (list: ↓ list of (thing)) with (insertion: list of (thing))
   )
   JavaScript: “” list “.splice(” beginning “, ” end “ ¤(2D) ” beginning “, ...” insertion “)”
   {
    change (↓ list) to ((list) with (beginning) to (end) replaced with (insertion))
   }

  action (file)
   (
    English: (list: list of (thing)) with (beginning: list boundary) to (end: list boundary) replaced with (insertion: list of (thing))
   )
   list of (thing)
   JavaScript: “” list “.toSpliced(” beginning “, ” end “ ¤(2D) ” beginning “, ...” insertion “)”
   {
    let (• copy: list of (thing)) start as (convert from (beginning of (list)) to (beginning) in (list) into list)
    append (insertion) to (↓ copy)
    append (convert from (end) to (end of (list)) in (list) into list) to (↓ copy)
    ← copy
   }

  use (clients)
   insertion from (list of (thing)) into (list of (thing)) separated by (list boundary)
   {
    action (clients)
     (
      English: replace (range: range of (list boundary)) in (list: ↓ list of (thing)) with (insertion: list of (thing))
     )
     Swift: “” list “.replaceSubrange(” range “, with: ” insertion “)”
     {
      replace from ((lower bound) of (range)) to ((upper bound) of (range)) in (↓ list) with (insertion)
     }

    action (clients)
     (
      English: (list: list of (thing)) with (range: range of (list boundary)) replaced with (insertion: list of (thing))
     )
     list of (thing)
     {
      ← (list) with ((lower bound) of (range)) to ((upper bound) of (range)) replaced with (insertion)
     }

    action (clients)
     (
      English: insert (insertion: list of (thing)) at (boundary: list boundary) in (list: ↓ list of (thing))
     )
     C: “g¤(5F)array¤(5F)insert¤(5F)vals(” list “, ” boundary “, ” insertion “¤(2D)>data, ” insertion “¤(2D)>len)”
     C♯: “” list “.InsertRange(” boundary “, ” insertion “)”
     Swift: “” list “.insert(contentsOf: ” insertion “, at: ” boundary “)”
     {
      insert (insertion) at (boundary) in (↓ list) according to list insertion
     }

    action (clients)
     (
      English: (list: list of (thing)) with (insertion: list of (thing)) inserted at (boundary: list boundary)
     )
     list of (thing)
     Kotlin: “” list “.toMutableList().apply { addAll(” boundary “, ” insertion “) }.toList()”
     {
      ← (list) with (insertion) inserted at (boundary) according to list insertion
     }

    action (clients)
     (
      English: append (appendix: list of (thing)) to (list: ↓ list of (thing))
     )
     C: “g¤(5F)array¤(5F)append¤(5F)vals(” list “, ” appendix “¤(2D)>data, ” appendix “¤(2D)>len)”
     C♯: “” list “.AddRange(” appendix “)”
     Kotlin: “” list “ += ” appendix “”
     Swift: “” list “ += ” appendix “”
     {
      change (↓ list) to ((list) with (appendix) appended)
     }

    action (clients)
     (
      English: (list: list of (thing)) with (appendix: list of (thing)) appended
     )
     list of (thing)
     C♯: “” list “.Concat(” appendix “).ToList()” (“System.Linq”)
     JavaScript: “” list “.concat(” appendix “)”
     Kotlin: “” list “ + ” appendix “”
     Swift: “” list “ + ” appendix “”
     {
      ← (list) with (appendix) appended according to list insertion
     }

    action (clients)
     (
      English: prepend (prefix: list of (thing)) to (list: ↓ list of (thing))
     )
     C: “g¤(5F)array¤(5F)prepend¤(5F)vals(” list “, ” prefix “¤(2D)>data, ” prefix “¤(2D)>len)”
     JavaScript: “” list “.unshift(...” prefix “)”
     {
      prepend (prefix) to (↓ list) according to list insertion
     }

    action (clients)
     (
      English: (list: list of (thing)) with (prefix: list of (thing)) prepended
     )
     list of (thing)
     C♯: “” prefix “.Concat(” list “).ToList()” (“System.Linq”)
     JavaScript: “” prefix “.concat(” list “)”
     Kotlin: “” prefix “ + ” list “”
     Swift: “” prefix “ + ” list “”
     {
      ← (list) with (prefix) prepended according to list insertion
     }

    action (clients)
     (
      English: convert (other: list of (thing)) into list
     )
     list of (thing)
     C: “” hold on (other) “”
     C♯: “” other “”
     JavaScript: “” other “”
     Kotlin: “” other “”
     Swift: “” other “”

    action (clients)
     (
      English: insertion example
     )
     list of (thing)
     {
      ← non‐empty example
     }
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     verify ((convert from (beginning of (list)) to (end of (list)) in (list) into list) is not empty)
    }
   ]
   (
    English: convert from (lower bound: list boundary) to (upper bound: list boundary) in (list: list of (thing)) into list
   )
   list of (thing)
   C♯: “” list “.GetRange(” lower bound “, ” upper bound “ ¤(2D) ” lower bound “)”
   JavaScript: “” list “.slice(” lower bound “, ” upper bound “)”
   Kotlin: “” list “.slice(” lower bound “..<” upper bound “)”
   {
    let (• copy: list of (thing)) start as (empty: list of (thing))
    for each (• element: thing) in ((from (lower bound) to (upper bound)) in (list)), {
     append (element) to (↓ copy)
    }
    ← copy
   }

  use (clients)
   insertion from (slice of (list of (thing))) into (list of (thing)) separated by (list boundary)
   {
    action (clients)
     (
      English: replace (range: range of (list boundary)) in (list: ↓ list of (thing)) with (insertion: slice of (list of (thing)))
     )
     Swift: “” list “.replaceSubrange(” range “, with: ” insertion “)”
     {
      replace (range) in (↓ list) with (convert (insertion) into list: list of (thing))
     }

    action (clients)
     (
      English: insert (insertion: slice of (list of (thing))) at (boundary: list boundary) in (list: ↓ list of (thing))
     )
     Swift: “” list “.insert(contentsOf: ” insertion “, at: ” boundary “)”
     {
      insert (convert (insertion) into list: list of (thing)) at (boundary) in (↓ list)
     }

    action (clients)
     (
      English: append (appendix: slice of (list of (thing))) to (list: ↓ list of (thing))
     )
     Swift: “” list “.append(contentsOf: ” appendix “)”
     {
      append (convert (appendix) into list: list of (thing)) to (↓ list)
     }

    action (clients)
     (
      English: convert (other: slice of (list of (thing))) into list
     )
     list of (thing)
     Swift: “Array(” other “)”
     {
      ← convert from (beginning of (other)) to (end of (other)) in ((whole) of (other)) into list
     }

    action (clients)
     (
      English: insertion example
     )
     slice of (list of (thing))
     {
      ← entirety of (insertion example: list of (thing))
     }
   }
 }
