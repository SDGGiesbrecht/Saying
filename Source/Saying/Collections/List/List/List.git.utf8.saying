extension
 general containers of (thing)
 {
  thing (clients)
   (
    English: list of (thing)
    Deutsch: Liste von (Ding: [thing])
    français : liste de (chose: [thing])
    ελληνικά: κατάλογος (πράγμα: [thing])
    עברית: רשימה של (דבר: [thing])
   )
   C: “list¤(5F)” (thing) sanitized for identifier “¤(2A)”/“list¤(5F)” (thing) sanitized for identifier “¤(5F)hold(” . “)”/“list¤(5F)” (thing) sanitized for identifier “¤(5F)release(” . “)”/“list¤(5F)” (thing) sanitized for identifier “¤(5F)copy(” . “)” [
     “list¤(5F)” (thing) sanitized for identifier “¤(5F)hold(list¤(5F)” (thing) sanitized for identifier “¤(2A))”
     “list¤(5F)” (thing) sanitized for identifier “¤(5F)release(list¤(5F)” (thing) sanitized for identifier “¤(2A))”
     “list¤(5F)” (thing) sanitized for identifier “¤(5F)copy(list¤(5F)” (thing) sanitized for identifier “¤(2A))”
    ] {
     “list¤(5F)” (thing) sanitized for identifier “¤(2A) list¤(5F)” (thing) sanitized for identifier “¤(5F)hold(list¤(5F)” (thing) sanitized for identifier “¤(2A) list);”
     “void list¤(5F)” (thing) sanitized for identifier “¤(5F)release(list¤(5F)” (thing) sanitized for identifier “¤(2A) list);”
     “list¤(5F)” (thing) sanitized for identifier “¤(2A) list¤(5F)” (thing) sanitized for identifier “¤(5F)copy(list¤(5F)” (thing) sanitized for identifier “¤(2A) list);”
    }
   C♯: “List<” thing “>” (“System.Collections.Generic”)
   Kotlin: “List<” thing “>”
   Swift: “[” thing “]”
   {
    part (file)
     (
      English: unmanaged
     )
     unmanaged list of (thing)
     C: “¤(2A)” . “”
     C♯: “”
     JavaScript: “”
     Kotlin: “”
     Swift: “”
   }

  action (unit)
   [
    test {ignore (list in read‐only memory (unmanaged list of unknown length at (unallocated): unmanaged list of (thing) of unknown length) ending at (boundary at (zero: memory offset)))}
   ]
   (
    English: list in read‐only memory (uncounted: unmanaged list of (thing) of unknown length) ending at (end: list boundary)
   )
   list of (thing)
   {
    ← create list with unmanaged list (unmanaged list in read‐only memory (uncounted) ending at (end))
   }

  action (file)
   (
    English: initialize (list: list of (thing)) to (unmanaged: unmanaged list of (thing))
   )
   C: “¤(2A)” list “ = ” unmanaged “”
   {}

  action (file)
   [
    test {ignore (create list with unmanaged list (empty: unmanaged list of (thing)))}
   ]
   (
    English: create list with unmanaged list (list: unmanaged list of (thing))
   )
   list of (thing)
   {
    let (• memory: list of (thing)) be (list at (allocate (size of (list)) bytes of memory): list of (thing))
    initialize (memory) to (list)
    ← memory
   }

  action (file)
   (
    English: list at (address: memory address)
   )
   list of (thing)
   C: “(list¤(5F)” (thing) sanitized for identifier “¤(2A))” address “”
   {
    ← empty
   }

  action (file)
   [
    test {ignore (memory address of (empty: list of (thing)))}
   ]
   (
    English: memory address of (list: list of (thing))
   )
   memory address
   C: “(void¤(2A))” list “”
   {
    ← unallocated
   }

  action (file)
   (
    English: hold (list: list of (thing)) without returning
   )
   C♯: “”
   JavaScript: “”
   Kotlin: “”
   Swift: “”
   {
    hold unmanaged (↓ (unmanaged) of (list))
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (empty: list of (thing))
     hold (list) without returning
     ignore (return (list) without holding)
    }
   ]
   (
    English: return (list: list of (thing)) without holding
   )
   list of (thing)
   C: “” list “”
   C♯: “” list “”
   JavaScript: “” list “”
   Kotlin: “” list “”
   Swift: “” list “”

  action (file)
   [
    test {
     let (• list: list of (thing)) be (empty: list of (thing))
     ignore (hold (list))
    }
   ]
   (
    English: hold (list: list of (thing))
    C: 1 hold (list: [list])
   )
   list of (thing)
   C♯: “” list “”
   JavaScript: “” list “”
   Kotlin: “” list “”
   Swift: “” list “”
   {
    hold (list) without returning
    ← return (list) without holding
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (empty: list of (thing))
     hold (list) without returning
     release (list)
    }
   ]
   (
    English: release (list: list of (thing))
    C: 1 release (list: [list])
   )
   C♯: “”
   JavaScript: “”
   Kotlin: “”
   Swift: “”
   {
    let (• deallocating: truth value) be (((references) of ((unmanaged) of (list))) is (one: platform fixed‐width natural number))
    release unmanaged (↓ (unmanaged) of (list))
    if (deallocating), {
     deallocate memory (memory address of (list))
    }
   }

  action (file)
   [
    test {
     ignore (copy of (empty: list of (thing)))
    }
   ]
   (
    English: copy of (list: list of (thing))
    C: 1 copy (list: [list])
   )
   list of (thing)
   C♯: “” list “”
   JavaScript: “” list “”
   Kotlin: “” list “”
   Swift: “” list “”
   {
    ← create list with unmanaged list (copy of unmanaged ((unmanaged) of (list)))
   }

  use (clients)
   use of (list of (thing)) as list of (thing) indexed by (list index) separated by (list boundary)
   {
    action (clients)
     (
      English: index after (boundary: list boundary) in (list: list of (thing)) skipping bounds check
     )
     list index
     C♯: “” boundary “”
     JavaScript: “” boundary “”
     Kotlin: “” boundary “”
     Swift: “” boundary “”
     {
      ← index after (boundary) in ((unmanaged) of (list)) skipping bounds check
     }

    action (clients)
     (
      English: beginning of (list: list of (thing))
     )
     list boundary
     C♯: “0”
     JavaScript: “0”
     Kotlin: “0”
     Swift: “” list “.startIndex”
     {
      ← beginning of ((unmanaged) of (list))
     }

    action (clients)
     (
      English: end of (list: list of (thing))
     )
     list boundary
     C♯: “” list “.Count”
     JavaScript: “” list “.length”
     Kotlin: “” list “.size”
     Swift: “” list “.endIndex”
     {
      ← end of ((unmanaged) of (list))
     }

    action (clients)
     (
      English: advance (cursor: ↓ list boundary) to next in (list: list of (thing)) skipping bounds check
     )
     C♯: “++” cursor “”
     JavaScript: “++” cursor “”
     Kotlin: “++” cursor “”
     Swift: “” list “.formIndex(after: ¤(26)” cursor “)”
     {
      ← advance (↓ cursor) to next in ((unmanaged) of (list)) skipping bounds check
     }

    action (clients)
     (
      English: boundary after (cursor: list boundary) in (list: list of (thing)) skipping bounds check
     )
     list boundary
     C♯: “” cursor “ + 1”
     JavaScript: “” cursor “ + 1”
     Kotlin: “” cursor “ + 1”
     Swift: “” list “.index(after: ” cursor “)”
     {
      ← boundary after (cursor) in ((unmanaged) of (list)) skipping bounds check
     }

    action (clients)
     (
      English: entry at (cursor: list index) in (list: list of (thing))
     )
     thing
     C♯: “” list “[” cursor “]”
     JavaScript: “” list “[” cursor “]”
     Kotlin: “” list “[” cursor “]”
     Swift: “” list “[” cursor “]”
     {
      ← entry at (cursor) in ((unmanaged) of (list))
     }

    action (clients)
     (
      English: entry after (cursor: list boundary) in (list: list of (thing)) skipping bounds check
     )
     thing
     C♯: “” list “[” cursor “]”
     JavaScript: “” list “[” cursor “]”
     Kotlin: “” list “[” cursor “]”
     Swift: “” list “[” cursor “]”
     {
      ← entry after (cursor) in (list) skipping bounds check, according to default use as list
     }

    action (clients)
     (
      English: first in (list: list of (thing))
     )
     optional (thing)
     Kotlin: “” list “.firstOrNull()”
     Swift: “” list “.first”
     {
      ← first in (list) according to default use as list
     }

    action (clients)
     (
      English: (list: list of (thing)) is empty
     )
     truth value
     Kotlin: “” list “.isEmpty()”
     Swift: “” list “.isEmpty”
     {
      ← (list) is empty according to default use as list
     }

    action (clients)
     (
      English: (list: list of (thing)) is not empty
     )
     truth value
     Kotlin: “” list “.isNotEmpty()”
     {
      ← (list) is not empty according to default use as list
     }

    action (clients)
     (
      English: empty
     )
     list of (thing)
     C♯: “new List<” thing “>()”
     JavaScript: “[]”
     Kotlin: “listOf()”
     Swift: “[]”
     {
      ← create list with unmanaged list (empty: unmanaged list of (thing))
     }

    action (clients)
     (
      English: non‐empty example
     )
     list of (thing)
     {
      ← non‐empty example according to use as changeable list
     }
   }

  action (clients)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     let (• beginning: list boundary) be (beginning of (list))
     verify ((boundary before (index after (beginning) in (list) skipping bounds check) in (list)) is (beginning))
    }
   ]
   (
    English: boundary before (index: list index) in (list: list of (thing))
   )
   list boundary
   C♯: “” index “”
   JavaScript: “” index “”
   Kotlin: “” index “”
   Swift: “” index “”
   {
    ← boundary before (index) in ((unmanaged) of (list))
   }

  use (clients)
   slicing (list of (thing)) as list of (thing) indexed by (list index) separated by (list boundary)
   {
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, replace (index after (beginning of (list)) in (list) skipping bounds check) in (↓ list) with (example: thing) by unmanaged
    }
   ]
   (
    English: if most efficient, replace (index: list index) in (list: ↓ list of (thing)) with (element: thing) by unmanaged
   )
   C♯: “”
   JavaScript: “”
   Kotlin: “”
   Swift: “”
   {
    replace (index) in (↓ (unmanaged) of (list)) with (element)
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, replace (index after (beginning of (list)) in (list) skipping bounds check) in (↓ list) with (example: thing) by replacement
    }
   ]
   (
    English: if most efficient, replace (index: list index) in (list: ↓ list of (thing)) with (element: thing) by replacement
   )
   C: “”
   C♯: “”
   JavaScript: “”
   Swift: “”
   {
    change (↓ list) to ((list) with (index) replaced with (element))
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, insert (example: thing) at (beginning of (list)) in (↓ list) by unmanaged
    }
   ]
   (
    English: if most efficient, insert (element: thing) at (boundary: list boundary) in (list: ↓ list of (thing)) by unmanaged
   )
   C♯: “”
   JavaScript: “”
   Kotlin: “”
   Swift: “”
   {
    insert (element) at (boundary) in (↓ (unmanaged) of (list))
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, insert (example: thing) at (beginning of (list)) in (↓ list) by replacement
    }
   ]
   (
    English: if most efficient, insert (element: thing) at (boundary: list boundary) in (list: ↓ list of (thing)) by replacement
   )
   C: “”
   C♯: “”
   JavaScript: “”
   Swift: “”
   {
    change (↓ list) to ((list) with (element) inserted at (boundary))
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, append (example: thing) to (↓ list) by changeable list
    }
   ]
   (
    English: if most efficient, append (element: thing) to (list: ↓ list of (thing)) by changeable list
   )
   C♯: “”
   JavaScript: “”
   Kotlin: “”
   Swift: “”
   {
    append (element) to (↓ list) according to use as changeable list
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, append (example: thing) to (↓ list) by replacement
    }
   ]
   (
    English: if most efficient, append (element: thing) to (list: ↓ list of (thing)) by replacement
   )
   C: “”
   C♯: “”
   JavaScript: “”
   Swift: “”
   {
    change (↓ list) to ((list) with (element) appended)
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, remove (index after (beginning of (list)) in (list) skipping bounds check) from (↓ list) by range
    }
   ]
   (
    English: if most efficient, remove (index: list index) from (list: ↓ list of (thing)) by range
   )
   C♯: “”
   JavaScript: “”
   Kotlin: “”
   Swift: “”
   {
    let (• before: list boundary) be (boundary before (index) in (list))
    let (• after: list boundary) be (boundary after (before) in (list) skipping bounds check)
    remove (from (before) to (after)) from (↓ list)
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, remove (index after (beginning of (list)) in (list) skipping bounds check) from (↓ list) by replacement
    }
   ]
   (
    English: if most efficient, remove (index: list index) from (list: ↓ list of (thing)) by replacement
   )
   C: “”
   C♯: “”
   JavaScript: “”
   Swift: “”
   {
    change (↓ list) to ((list) with (index) removed)
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, remove (from (beginning of (list)) to (end of (list))) from (↓ list) by empty replacement
    }
   ]
   (
    English: if most efficient, remove (range: range of (list boundary)) from (list: ↓ list of (thing)) by empty replacement
   )
   C♯: “”
   JavaScript: “”
   Swift: “”
   {
    replace (range) in (↓ list) with (empty: list of (thing))
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     remove from (beginning of (list)) to (end of (list)) from (↓ list)
    }
   ]
   (
    English: remove from (beginning: list boundary) to (end: list boundary) from (list: ↓ list of (thing))
   )
   C♯: “” list “.RemoveRange(” beginning “, ” end “ ¤(2D) ” beginning “)”
   JavaScript: “” list “.splice(” beginning “, ” end “ ¤(2D) ” beginning “)”
   {}

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, remove (from (beginning of (list)) to (end of (list))) from (↓ list) by bounds
    }
   ]
   (
    English: if most efficient, remove (range: range of (list boundary)) from (list: ↓ list of (thing)) by bounds
   )
   C: “”
   Kotlin: “”
   Swift: “”
   {
    remove from ((lower bound) of (range)) to ((upper bound) of (range)) from (↓ list)
   }

  use (clients)
   use of (list of (thing)) as changeable list of (thing) indexed by (list index) separated by (list boundary)
   {
    action (clients)
     (
      English: replace (index: list index) in (list: ↓ list of (thing)) with (element: thing)
     )
     C♯: “” list “[” index “] = ” element “”
     JavaScript: “” list “[” index “] = ” element “”
     Swift: “” list “[” index “] = ” element “”
     {
      if most efficient, replace (index) in (↓ list) with (element) by replacement
     }

    action (clients)
     (
      English: (list: list of (thing)) with (index: list index) replaced with (element: thing)
     )
     list of (thing)
     Kotlin: “” list “.toMutableList().apply { this[” index “] = ” element “ }.toList()”
     {
      ← (list) with (index) replaced with (element) according to use as changeable list
     }

    action (clients)
     (
      English: insert (element: thing) at (boundary: list boundary) in (list: ↓ list of (thing))
     )
     C♯: “” list “.Insert(” boundary “, ” element “)”
     JavaScript: “” list “.splice(” boundary “, 0, ” element “)”
     Swift: “” list “.insert(” element “, at: ” boundary “)”
     {
      if most efficient, insert (element) at (boundary) in (↓ list) by replacement
      if most efficient, insert (element) at (boundary) in (↓ list) by unmanaged
     }

    action (clients)
     (
      English: (list: list of (thing)) with (element: thing) inserted at (boundary: list boundary)
     )
     list of (thing)
     Kotlin: “” list “.toMutableList().apply { add(” boundary “, ” element “) }.toList()”
     {
      ← (list) with (element) inserted at (boundary) according to use as changeable list
     }

    action (clients)
     (
      English: append (element: thing) to (list: ↓ list of (thing))
     )
     C♯: “” list “.Add(” element “)”
     JavaScript: “” list “.push(” element “)”
     Swift: “” list “.append(” element “)”
     {
      if most efficient, append (element) to (↓ list) by replacement
      if most efficient, append (element) to (↓ list) by changeable list
     }

    action (clients)
     (
      English: (list: list of (thing)) with (element: thing) appended
     )
     list of (thing)
     Kotlin: “” list “.toMutableList().apply { add(” element “) }.toList()”
     {
      ← (list) with (element) appended according to use as changeable list
     }

    action (clients)
     (
      English: prepend (element: thing) to (list: ↓ list of (thing))
     )
     JavaScript: “” list “.unshift(” element “)”
     {
      prepend (element) to (↓ list) according to use as changeable list
     }

    action (clients)
     (
      English: (list: list of (thing)) with (element: thing) prepended
     )
     list of (thing)
     C♯: “” list “.Prepend(” element “).ToList()” (“System.Linq”)
     {
      ← (list) with (element) prepended according to use as changeable list
     }

    action (clients)
     (
      English: remove (index: list index) from (list: ↓ list of (thing))
     )
     C♯: “” list “.RemoveAt(” index “)”
     JavaScript: “” list “.splice(” index “, 0)”
     Swift: “” list “.remove(at: ” index “)”
     {
      if most efficient, remove (index) from (↓ list) by replacement
      if most efficient, remove (index) from (↓ list) by range
     }

    action (clients)
     (
      English: (list: list of (thing)) with (index: list index) removed
     )
     list of (thing)
     Kotlin: “” list “.toMutableList().apply { removeAt(” index “) }.toList()”
     {
      ← (list) with (index) removed according to use as changeable list
     }

    action (clients)
     (
      English: remove (range: range of (list boundary)) from (list: ↓ list of (thing))
     )
     Swift: “” list “.removeSubrange(” range “)”
     {
      if most efficient, remove (range) from (↓ list) by bounds
      if most efficient, remove (range) from (↓ list) by empty replacement
     }
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, replace (from (beginning of (list)) to (end of (list))) in (↓ list) with (insertion example: list of (thing)) by unmanaged
    }
   ]
   (
    English: if most efficient, replace (range: range of (list boundary)) in (list: ↓ list of (thing)) with (insertion: list of (thing)) by unmanaged
   )
   C♯: “”
   JavaScript: “”
   Kotlin: “”
   Swift: “”
   {
    replace (range) in (↓ (unmanaged) of (list)) with ((unmanaged) of (insertion))
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     replace from (beginning of (list)) to (end of (list)) in (↓ list) with (insertion example: list of (thing))
    }
   ]
   (
    English: replace from (beginning: list boundary) to (end: list boundary) in (list: ↓ list of (thing)) with (insertion: list of (thing))
   )
   JavaScript: “” list “.splice(” beginning “, ” end “ ¤(2D) ” beginning “, ...” insertion “)”
   {}

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, replace (from (beginning of (list)) to (end of (list))) in (↓ list) with (insertion example: list of (thing)) by bounds
    }
   ]
   (
    English: if most efficient, replace (range: range of (list boundary)) in (list: ↓ list of (thing)) with (insertion: list of (thing)) by bounds
   )
   C: “”
   C♯: “”
   Kotlin: “”
   Swift: “”
   {
    replace from ((lower bound) of (range)) to ((upper bound) of (range)) in (↓ list) with (insertion)
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, replace (from (beginning of (list)) to (end of (list))) in (↓ list) with (insertion example: list of (thing)) by replacement
    }
   ]
   (
    English: if most efficient, replace (range: range of (list boundary)) in (list: ↓ list of (thing)) with (insertion: list of (thing)) by replacement
   )
   C: “”
   JavaScript: “”
   Swift: “”
   {
    change (↓ list) to ((list) with (range) replaced with (insertion))
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     ignore (if most efficient, (list) with (from (beginning of (list)) to (end of (list))) replaced with (insertion example: list of (thing)) by appending)
    }
   ]
   (
    English: if most efficient, (list: list of (thing)) with (range: range of (list boundary)) replaced with (insertion: list of (thing)) by appending
   )
   list of (thing)
   JavaScript: “” list “”
   Swift: “” list “”
   {
    let (• copy: list of (thing)) start as (convert ((from (beginning of (list)) to ((lower bound) of (range))) in (list)) into list)
    append (insertion) to (↓ copy)
    append (convert ((from ((upper bound) of (range)) to (end of (list))) in (list)) into list) to (↓ copy)
    ← copy
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     ignore ((list) with (beginning of (list)) to (end of (list)) replaced with (insertion example: list of (thing)))
    }
   ]
   (
    English: (list: list of (thing)) with (beginning: list boundary) to (end: list boundary) replaced with (insertion: list of (thing))
   )
   list of (thing)
   JavaScript: “” list “.toSpliced(” beginning “, ” end “ ¤(2D) ” beginning “, ...” insertion “)”
   {
    ← list
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     ignore (if most efficient, (list) with (from (beginning of (list)) to (end of (list))) replaced with (insertion example: list of (thing)) by bounds)
    }
   ]
   (
    English: if most efficient, (list: list of (thing)) with (range: range of (list boundary)) replaced with (insertion: list of (thing)) by bounds
   )
   list of (thing)
   C: “” hold on (list) “”
   C♯: “” list “”
   Kotlin: “” list “”
   Swift: “” list “”
   {
    ← (list) with ((lower bound) of (range)) to ((upper bound) of (range)) replaced with (insertion)
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     ignore (if most efficient, (list) with (from (beginning of (list)) to (end of (list))) replaced with (insertion example: list of (thing)) by list insertion)
    }
   ]
   (
    English: if most efficient, (list: list of (thing)) with (range: range of (list boundary)) replaced with (insertion: list of (thing)) by list insertion
   )
   list of (thing)
   C♯: “” list “”
   JavaScript: “” list “”
   Kotlin: “” list “”
   {
    ← (list) with (range) replaced with (insertion) according to list insertion
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, insert (insertion example: list of (thing)) at (beginning of (list)) in (↓ list) by replacement
    }
   ]
   (
    English: if most efficient, insert (insertion: list of (thing)) at (boundary: list boundary) in (list: ↓ list of (thing)) by replacement
   )
   C: “”
   C♯: “”
   JavaScript: “”
   Swift: “”
   {
    change (↓ list) to ((list) with (insertion) inserted at (boundary))
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, insert (insertion example: list of (thing)) at (beginning of (list)) in (↓ list) by list insertion
    }
   ]
   (
    English: if most efficient, insert (insertion: list of (thing)) at (boundary: list boundary) in (list: ↓ list of (thing)) by list insertion
   )
   C♯: “”
   Kotlin: “”
   Swift: “”
   {
    insert (insertion) at (boundary) in (↓ list) according to list insertion
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, append (insertion example: list of (thing)) to (↓ list) by list insertion
    }
   ]
   (
    English: if most efficient, append (appendix: list of (thing)) to (list: ↓ list of (thing)) by list insertion
   )
   C♯: “”
   JavaScript: “”
   Kotlin: “”
   Swift: “”
   {
    append (appendix) to (↓ list) according to list insertion
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, append (insertion example: list of (thing)) to (↓ list) by replacement
    }
   ]
   (
    English: if most efficient, append (appendix: list of (thing)) to (list: ↓ list of (thing)) by replacement
   )
   C: “”
   C♯: “”
   Kotlin: “”
   Swift: “”
   {
    change (↓ list) to ((list) with (appendix) appended)
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, prepend (insertion example: list of (thing)) to (↓ list) by list insertion
    }
   ]
   (
    English: if most efficient, prepend (prefix: list of (thing)) to (list: ↓ list of (thing)) by list insertion
   )
   C: “”
   JavaScript: “”
   {
    prepend (prefix) to (↓ list) according to list insertion
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, prepend (insertion example: list of (thing)) to (↓ list) by replacement
    }
   ]
   (
    English: if most efficient, prepend (prefix: list of (thing)) to (list: ↓ list of (thing)) by replacement
   )
   C: “”
   JavaScript: “”
   {
    change (↓ list) to ((list) with (prefix) prepended)
   }

  use (clients)
   insertion from (list of (thing)) into (list of (thing)) separated by (list boundary)
   {
    action (clients)
     (
      English: replace (range: range of (list boundary)) in (list: ↓ list of (thing)) with (insertion: list of (thing))
     )
     Swift: “” list “.replaceSubrange(” range “, with: ” insertion “)”
     {
      if most efficient, replace (range) in (↓ list) with (insertion) by replacement
      if most efficient, replace (range) in (↓ list) with (insertion) by bounds
      if most efficient, replace (range) in (↓ list) with (insertion) by unmanaged
     }

    action (clients)
     (
      English: (list: list of (thing)) with (range: range of (list boundary)) replaced with (insertion: list of (thing))
     )
     list of (thing)
     {
      ← if most efficient, (if most efficient, (if most efficient, (list) with (range) replaced with (insertion) by bounds) with (range) replaced with (insertion) by list insertion) with (range) replaced with (insertion) by appending
     }

    action (clients)
     (
      English: insert (insertion: list of (thing)) at (boundary: list boundary) in (list: ↓ list of (thing))
     )
     C♯: “” list “.InsertRange(” boundary “, ” insertion “)”
     Swift: “” list “.insert(contentsOf: ” insertion “, at: ” boundary “)”
     {
      if most efficient, insert (insertion) at (boundary) in (↓ list) by replacement
      if most efficient, insert (insertion) at (boundary) in (↓ list) by list insertion
     }

    action (clients)
     (
      English: (list: list of (thing)) with (insertion: list of (thing)) inserted at (boundary: list boundary)
     )
     list of (thing)
     Kotlin: “” list “.toMutableList().apply { addAll(” boundary “, ” insertion “) }.toList()”
     {
      ← (list) with (insertion) inserted at (boundary) according to list insertion
     }

    action (clients)
     (
      English: append (appendix: list of (thing)) to (list: ↓ list of (thing))
     )
     C♯: “” list “.AddRange(” appendix “)”
     Kotlin: “” list “ += ” appendix “”
     Swift: “” list “ += ” appendix “”
     {
      if most efficient, append (appendix) to (↓ list) by replacement
      if most efficient, append (appendix) to (↓ list) by list insertion
     }

    action (clients)
     (
      English: (list: list of (thing)) with (appendix: list of (thing)) appended
     )
     list of (thing)
     JavaScript: “” list “.concat(” appendix “)”
     Kotlin: “” list “ + ” appendix “”
     Swift: “” list “ + ” appendix “”
     {
      ← (list) with (appendix) appended according to list insertion
     }

    action (clients)
     (
      English: prepend (prefix: list of (thing)) to (list: ↓ list of (thing))
     )
     JavaScript: “” list “.unshift(...” prefix “)”
     {
      if most efficient, prepend (prefix) to (↓ list) by replacement
      if most efficient, prepend (prefix) to (↓ list) by list insertion
     }

    action (clients)
     (
      English: (list: list of (thing)) with (prefix: list of (thing)) prepended
     )
     list of (thing)
     C♯: “” prefix “.Concat(” list “).ToList()” (“System.Linq”)
     JavaScript: “” prefix “.concat(” list “)”
     Kotlin: “” prefix “ + ” list “”
     Swift: “” prefix “ + ” list “”
     {
      ← (list) with (prefix) prepended according to list insertion
     }

    action (clients)
     (
      English: convert (other: list of (thing)) into list
     )
     list of (thing)
     C: “” hold on (other) “”
     C♯: “” other “”
     JavaScript: “” other “”
     Kotlin: “” other “”
     Swift: “” other “”

    action (clients)
     (
      English: insertion example
     )
     list of (thing)
     {
      ← non‐empty example
     }
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     let (• result: list of (thing)) start as (empty: list of (thing))
     if most efficient, convert ((from (beginning of (list)) to (end of (list))) in (list)) into list by unmanaged and store in (↓ result)
    }
   ]
   (
    English: if most efficient, convert (other: slice of (list of (thing))) into list by unmanaged and store in (result: ↓ list of (thing))
   )
   C♯: “”
   JavaScript: “”
   Kotlin: “”
   Swift: “”
   {
    change (↓ result) to (create list with unmanaged list (copy of ((bounds) of (other)) from ((unmanaged) of ((whole) of (other)))))
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     ignore (convert from (beginning of (list)) to (end of (list)) in (list) into list)
    }
   ]
   (
    English: convert from (lower bound: list boundary) to (upper bound: list boundary) in (list: list of (thing)) into list
   )
   list of (thing)
   C♯: “” list “.GetRange(” lower bound “, ” upper bound “ ¤(2D) ” lower bound “)”
   JavaScript: “” list “.slice(” lower bound “, ” upper bound “)”
   Kotlin: “” list “.slice(” lower bound “..<” upper bound “)”
   {
    ← empty
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     let (• result: list of (thing)) start as (empty: list of (thing))
     if most efficient, convert ((from (beginning of (list)) to (end of (list))) in (list)) into list by bounds and store in (↓ result)
    }
   ]
   (
    English: if most efficient, convert (other: slice of (list of (thing))) into list by bounds and store in (result: ↓ list of (thing))
   )
   C: “”
   Swift: “”
   {
    change (↓ result) to (convert from (beginning of (other)) to (end of (other)) in ((whole) of (other)) into list)
   }

  use (clients)
   insertion from (slice of (list of (thing))) into (list of (thing)) separated by (list boundary)
   {
    action (clients)
     (
      English: replace (range: range of (list boundary)) in (list: ↓ list of (thing)) with (insertion: slice of (list of (thing)))
     )
     Swift: “” list “.replaceSubrange(” range “, with: ” insertion “)”
     {
      replace (range) in (↓ list) with (convert (insertion) into list: list of (thing))
     }

    action (clients)
     (
      English: insert (insertion: slice of (list of (thing))) at (boundary: list boundary) in (list: ↓ list of (thing))
     )
     Swift: “” list “.insert(contentsOf: ” insertion “, at: ” boundary “)”
     {
      insert (convert (insertion) into list: list of (thing)) at (boundary) in (↓ list)
     }

    action (clients)
     (
      English: append (appendix: slice of (list of (thing))) to (list: ↓ list of (thing))
     )
     Swift: “” list “.append(contentsOf: ” appendix “)”
     {
      append (convert (appendix) into list: list of (thing)) to (↓ list)
     }

    action (clients)
     (
      English: convert (other: slice of (list of (thing))) into list
     )
     list of (thing)
     Swift: “Array(” other “)”
     {
      let (• copy: list of (thing)) start as (empty: list of (thing))
      if most efficient, convert (other) into list by bounds and store in (↓ copy)
      if most efficient, convert (other) into list by unmanaged and store in (↓ copy)
      ← copy
     }

    action (clients)
     (
      English: insertion example
     )
     slice of (list of (thing))
     {
      ← entirety of (insertion example: list of (thing))
     }
   }
 }
