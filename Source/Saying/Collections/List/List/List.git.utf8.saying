extension
 general containers of (thing)
 {
  thing (clients)
   (
    English: list of (thing)
    Deutsch: Liste von (Ding: [thing])
    français : liste de (chose: [thing])
    ελληνικά: κατάλογος (πράγμα: [thing])
    עברית: רשימה של (דבר: [thing])
   )
   C: “GArray¤(2A)”/“g¤(5F)array¤(5F)ref(” array “)”/“g¤(5F)array¤(5F)unref(” array “)”/“g¤(5F)array¤(5F)ref(” array “)” (“glib¤(2D)2.0”)
   C♯: “List<” thing “>” (“System.Collections.Generic”)
   Kotlin: “List<” thing “>”
   Swift: “[” thing “]”
   {
   }

  action (file)
   (
    English: unmanaged (list: list of (thing))
   )
   unmanaged list of (thing)
   {
    let (• end: list boundary) be (end of (list))
    ← create unmanaged list with uncounted (uncounted (list)), end (end) and limit (end)
   }

  action (file)
   (
    English: create list with unmanaged list (list: unmanaged list of (thing))
   )
   list of (thing)
   C: “g¤(5F)array¤(5F)new(FALSE, FALSE, sizeof(” thing “))”
   {
    ← (managed) of ((uncounted) of (list))
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (empty: list of (thing))
     ignore (hold (list))
     release (list)
    }
   ]
   (
    English: hold (list: list of (thing))
    C: 1 hold (list: [list])
   )
   list of (thing)
   {
    let (• unmanaged: unmanaged list of (thing)) start as (unmanaged (list))
    hold unmanaged (↓ unmanaged)
    ← list
   }

  action (file)
   [
    test (hidden) {
     let (• list: list of (thing)) be (empty: list of (thing))
     let (• unmanaged: unmanaged list of (thing)) start as (unmanaged (list))
     hold unmanaged (↓ unmanaged)
     release (list)
    }
   ]
   (
    English: release (list: list of (thing))
    C: 1 release (list: [list])
   )
   {
    let (• unmanaged: unmanaged list of (thing)) start as (unmanaged (list))
    release unmanaged (↓ unmanaged)
   }

  action (file)
   [
    test {
     ignore (copy of (empty: list of (thing)))
    }
   ]
   (
    English: copy of (list: list of (thing))
    C: 1 copy (list: [list])
   )
   list of (thing)
   {
    ← create list with unmanaged list (copy of unmanaged (unmanaged (list)))
   }

  use (clients)
   use of (list of (thing)) as list of (thing) indexed by (list index) separated by (list boundary)
   {
    action (clients)
     (
      English: index after (boundary: list boundary) in (list: list of (thing)) skipping bounds check
     )
     list index
     C: “” boundary “”
     C♯: “” boundary “”
     JavaScript: “” boundary “”
     Kotlin: “” boundary “”
     Swift: “” boundary “”

    action (clients)
     (
      English: beginning of (list: list of (thing))
     )
     list boundary
     C: “0”
     C♯: “0”
     JavaScript: “0”
     Kotlin: “0”
     Swift: “” list “.startIndex”

    action (clients)
     (
      English: end of (list: list of (thing))
     )
     list boundary
     C: “” list “¤(2D)>len”
     C♯: “” list “.Count”
     JavaScript: “” list “.length”
     Kotlin: “” list “.size”
     Swift: “” list “.endIndex”

    action (clients)
     (
      English: advance (cursor: ↓ list boundary) to next in (list: list of (thing)) skipping bounds check
     )
     C: “++” cursor “”
     C♯: “++” cursor “”
     JavaScript: “++” cursor “”
     Kotlin: “++” cursor “”
     Swift: “” list “.formIndex(after: ¤(26)” cursor “)”

    action (clients)
     (
      English: boundary after (cursor: list boundary) in (list: list of (thing)) skipping bounds check
     )
     list boundary
     C: “” cursor “ + 1”
     C♯: “” cursor “ + 1”
     JavaScript: “” cursor “ + 1”
     Kotlin: “” cursor “ + 1”
     Swift: “” list “.index(after: ” cursor “)”

    action (clients)
     (
      English: entry at (cursor: list index) in (list: list of (thing))
     )
     thing
     C: “” hold on (thing) “g¤(5F)array¤(5F)index(” list “, ” thing “, ” cursor “)”
     C♯: “” list “[” cursor “]”
     JavaScript: “” list “[” cursor “]”
     Kotlin: “” list “[” cursor “]”
     Swift: “” list “[” cursor “]”

    action (clients)
     (
      English: entry after (cursor: list boundary) in (list: list of (thing)) skipping bounds check
     )
     thing
     C: “” hold on (thing) “g¤(5F)array¤(5F)index(” list “, ” thing “, ” cursor “)”
     C♯: “” list “[” cursor “]”
     JavaScript: “” list “[” cursor “]”
     Kotlin: “” list “[” cursor “]”
     Swift: “” list “[” cursor “]”

    action (clients)
     (
      English: first in (list: list of (thing))
     )
     optional (thing)
     Kotlin: “” list “.firstOrNull()”
     Swift: “” list “.first”
     {
      ← first in (list) according to default use as list
     }

    action (clients)
     (
      English: (list: list of (thing)) is empty
     )
     truth value
     Kotlin: “” list “.isEmpty()”
     Swift: “” list “.isEmpty”
     {
      ← (list) is empty according to default use as list
     }

    action (clients)
     (
      English: (list: list of (thing)) is not empty
     )
     truth value
     Kotlin: “” list “.isNotEmpty()”
     {
      ← (list) is not empty according to default use as list
     }

    action (clients)
     (
      English: empty
     )
     list of (thing)
     C: “g¤(5F)array¤(5F)new(FALSE, FALSE, sizeof(” thing “))”
     C♯: “new List<” thing “>()”
     JavaScript: “[]”
     Kotlin: “listOf()”
     Swift: “[]”

    action (clients)
     (
      English: non‐empty example
     )
     list of (thing)
     {
      ← non‐empty example according to use as changeable list
     }
   }

  action (clients)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     let (• beginning: list boundary) be (beginning of (list))
     verify ((boundary before (index after (beginning) in (list) skipping bounds check) in (list)) is (beginning))
    }
   ]
   (
    English: boundary before (index: list index) in (list: list of (thing))
   )
   list boundary
   C: “” index “”
   C♯: “” index “”
   JavaScript: “” index “”
   Kotlin: “” index “”
   Swift: “” index “”

  use (clients)
   slicing (list of (thing)) as list of (thing) indexed by (list index) separated by (list boundary)
   {
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, replace (index after (beginning of (list)) in (list) skipping bounds check) in (↓ list) with (example: thing) by replacement
    }
   ]
   (
    English: if most efficient, replace (index: list index) in (list: ↓ list of (thing)) with (element: thing) by replacement
   )
   C: “”
   C♯: “”
   JavaScript: “”
   Swift: “”
   {
    change (↓ list) to ((list) with (index) replaced with (element))
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, insert (example: thing) at (beginning of (list)) in (↓ list) by replacement
    }
   ]
   (
    English: if most efficient, insert (element: thing) at (boundary: list boundary) in (list: ↓ list of (thing)) by replacement
   )
   C: “”
   C♯: “”
   JavaScript: “”
   Swift: “”
   {
    change (↓ list) to ((list) with (element) inserted at (boundary))
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, append (example: thing) to (↓ list) by replacement
    }
   ]
   (
    English: if most efficient, append (element: thing) to (list: ↓ list of (thing)) by replacement
   )
   C: “”
   C♯: “”
   JavaScript: “”
   Swift: “”
   {
    change (↓ list) to ((list) with (element) appended)
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, remove (index after (beginning of (list)) in (list) skipping bounds check) from (↓ list) by replacement
    }
   ]
   (
    English: if most efficient, remove (index: list index) from (list: ↓ list of (thing)) by replacement
   )
   C: “”
   C♯: “”
   JavaScript: “”
   Swift: “”
   {
    change (↓ list) to ((list) with (index) removed)
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, remove (from (beginning of (list)) to (end of (list))) from (↓ list) by empty replacement
    }
   ]
   (
    English: if most efficient, remove (range: range of (list boundary)) from (list: ↓ list of (thing)) by empty replacement
   )
   C: “”
   C♯: “”
   JavaScript: “”
   Swift: “”
   {
    replace (range) in (↓ list) with (empty: list of (thing))
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     remove from (beginning of (list)) to (end of (list)) from (↓ list)
    }
   ]
   (
    English: remove from (beginning: list boundary) to (end: list boundary) from (list: ↓ list of (thing))
   )
   C: “g¤(5F)array¤(5F)remove¤(5F)range(” list “, ” beginning “, ” end “ ¤(2D) ” beginning “)”
   C♯: “” list “.RemoveRange(” beginning “, ” end “ ¤(2D) ” beginning “)”
   JavaScript: “” list “.splice(” beginning “, ” end “ ¤(2D) ” beginning “)”
   {}

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, remove (from (beginning of (list)) to (end of (list))) from (↓ list) by bounds
    }
   ]
   (
    English: if most efficient, remove (range: range of (list boundary)) from (list: ↓ list of (thing)) by bounds
   )
   Kotlin: “”
   Swift: “”
   {
    remove from ((lower bound) of (range)) to ((upper bound) of (range)) from (↓ list)
   }

  use (clients)
   use of (list of (thing)) as changeable list of (thing) indexed by (list index) separated by (list boundary)
   {
    action (clients)
     (
      English: replace (index: list index) in (list: ↓ list of (thing)) with (element: thing)
     )
     C: “g¤(5F)array¤(5F)index(” list “, ” thing “, ” index “) = ” hold on (element) “”
     C♯: “” list “[” index “] = ” element “”
     JavaScript: “” list “[” index “] = ” element “”
     Swift: “” list “[” index “] = ” element “”
     {
      if most efficient, replace (index) in (↓ list) with (element) by replacement
     }

    action (clients)
     (
      English: (list: list of (thing)) with (index: list index) replaced with (element: thing)
     )
     list of (thing)
     Kotlin: “” list “.toMutableList().apply { this[” index “] = ” element “ }.toList()”
     {
      ← (list) with (index) replaced with (element) according to use as changeable list
     }

    action (clients)
     (
      English: insert (element: thing) at (boundary: list boundary) in (list: ↓ list of (thing))
     )
     C: “g¤(5F)array¤(5F)insert¤(5F)val(” list “, ” boundary “, ((struct { ” thing “ value; }) { ” hold on (element) “ }).value)”
     C♯: “” list “.Insert(” boundary “, ” element “)”
     JavaScript: “” list “.splice(” boundary “, 0, ” element “)”
     Swift: “” list “.insert(” element “, at: ” boundary “)”
     {
      if most efficient, insert (element) at (boundary) in (↓ list) by replacement
     }

    action (clients)
     (
      English: (list: list of (thing)) with (element: thing) inserted at (boundary: list boundary)
     )
     list of (thing)
     Kotlin: “” list “.toMutableList().apply { add(” boundary “, ” element “) }.toList()”
     {
      ← (list) with (element) inserted at (boundary) according to use as changeable list
     }

    action (clients)
     (
      English: append (element: thing) to (list: ↓ list of (thing))
     )
     C: “g¤(5F)array¤(5F)append¤(5F)val(” list “, ((struct { ” thing “ value; }) { ” hold on (element) “ }).value)”
     C♯: “” list “.Add(” element “)”
     JavaScript: “” list “.push(” element “)”
     Swift: “” list “.append(” element “)”
     {
      if most efficient, append (element) to (↓ list) by replacement
     }

    action (clients)
     (
      English: (list: list of (thing)) with (element: thing) appended
     )
     list of (thing)
     Kotlin: “” list “.toMutableList().apply { add(” element “) }.toList()”
     {
      ← (list) with (element) appended according to use as changeable list
     }

    action (clients)
     (
      English: prepend (element: thing) to (list: ↓ list of (thing))
     )
     C: “g¤(5F)array¤(5F)prepend¤(5F)val(” list “, ((struct { ” thing “ value; }) { ” hold on (element) “ }).value)”
     JavaScript: “” list “.unshift(” element “)”
     {
      prepend (element) to (↓ list) according to use as changeable list
     }

    action (clients)
     (
      English: (list: list of (thing)) with (element: thing) prepended
     )
     list of (thing)
     C♯: “” list “.Prepend(” element “).ToList()” (“System.Linq”)
     {
      ← (list) with (element) prepended according to use as changeable list
     }

    action (clients)
     (
      English: remove (index: list index) from (list: ↓ list of (thing))
     )
     C: “g¤(5F)array¤(5F)remove¤(5F)index(” list “, ” index “)”
     C♯: “” list “.RemoveAt(” index “)”
     JavaScript: “” list “.splice(” index “, 0)”
     Swift: “” list “.remove(at: ” index “)”
     {
      if most efficient, remove (index) from (↓ list) by replacement
     }

    action (clients)
     (
      English: (list: list of (thing)) with (index: list index) removed
     )
     list of (thing)
     Kotlin: “” list “.toMutableList().apply { removeAt(” index “) }.toList()”
     {
      ← (list) with (index) removed according to use as changeable list
     }

    action (clients)
     (
      English: remove (range: range of (list boundary)) from (list: ↓ list of (thing))
     )
     Swift: “” list “.removeSubrange(” range “)”
     {
      if most efficient, remove (range) from (↓ list) by bounds
      if most efficient, remove (range) from (↓ list) by empty replacement
     }
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     replace from (beginning of (list)) to (end of (list)) in (↓ list) with (insertion example: list of (thing))
    }
   ]
   (
    English: replace from (beginning: list boundary) to (end: list boundary) in (list: ↓ list of (thing)) with (insertion: list of (thing))
   )
   JavaScript: “” list “.splice(” beginning “, ” end “ ¤(2D) ” beginning “, ...” insertion “)”
   {}

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, replace (from (beginning of (list)) to (end of (list))) in (↓ list) with (insertion example: list of (thing)) by bounds
    }
   ]
   (
    English: if most efficient, replace (range: range of (list boundary)) in (list: ↓ list of (thing)) with (insertion: list of (thing)) by bounds
   )
   C: “”
   C♯: “”
   Kotlin: “”
   Swift: “”
   {
    replace from ((lower bound) of (range)) to ((upper bound) of (range)) in (↓ list) with (insertion)
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, replace (from (beginning of (list)) to (end of (list))) in (↓ list) with (insertion example: list of (thing)) by replacement
    }
   ]
   (
    English: if most efficient, replace (range: range of (list boundary)) in (list: ↓ list of (thing)) with (insertion: list of (thing)) by replacement
   )
   JavaScript: “”
   Swift: “”
   {
    change (↓ list) to ((list) with (range) replaced with (insertion))
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     ignore (if most efficient, (list) with (from (beginning of (list)) to (end of (list))) replaced with (insertion example: list of (thing)) by appending)
    }
   ]
   (
    English: if most efficient, (list: list of (thing)) with (range: range of (list boundary)) replaced with (insertion: list of (thing)) by appending
   )
   list of (thing)
   JavaScript: “” list “”
   Swift: “” list “”
   {
    let (• copy: list of (thing)) start as (convert ((from (beginning of (list)) to ((lower bound) of (range))) in (list)) into list)
    append (insertion) to (↓ copy)
    append (convert ((from ((upper bound) of (range)) to (end of (list))) in (list)) into list) to (↓ copy)
    ← copy
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     ignore ((list) with (beginning of (list)) to (end of (list)) replaced with (insertion example: list of (thing)))
    }
   ]
   (
    English: (list: list of (thing)) with (beginning: list boundary) to (end: list boundary) replaced with (insertion: list of (thing))
   )
   list of (thing)
   JavaScript: “” list “.toSpliced(” beginning “, ” end “ ¤(2D) ” beginning “, ...” insertion “)”
   {
    ← list
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     ignore (if most efficient, (list) with (from (beginning of (list)) to (end of (list))) replaced with (insertion example: list of (thing)) by bounds)
    }
   ]
   (
    English: if most efficient, (list: list of (thing)) with (range: range of (list boundary)) replaced with (insertion: list of (thing)) by bounds
   )
   list of (thing)
   C: “” list “”
   C♯: “” list “”
   Kotlin: “” list “”
   Swift: “” list “”
   {
    ← (list) with ((lower bound) of (range)) to ((upper bound) of (range)) replaced with (insertion)
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     ignore (if most efficient, (list) with (from (beginning of (list)) to (end of (list))) replaced with (insertion example: list of (thing)) by list insertion)
    }
   ]
   (
    English: if most efficient, (list: list of (thing)) with (range: range of (list boundary)) replaced with (insertion: list of (thing)) by list insertion
   )
   list of (thing)
   C: “” list “”
   C♯: “” list “”
   JavaScript: “” list “”
   Kotlin: “” list “”
   {
    ← (list) with (range) replaced with (insertion) according to list insertion
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, insert (insertion example: list of (thing)) at (beginning of (list)) in (↓ list) by replacement
    }
   ]
   (
    English: if most efficient, insert (insertion: list of (thing)) at (boundary: list boundary) in (list: ↓ list of (thing)) by replacement
   )
   C: “”
   C♯: “”
   JavaScript: “”
   Swift: “”
   {
    change (↓ list) to ((list) with (insertion) inserted at (boundary))
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, insert (insertion example: list of (thing)) at (beginning of (list)) in (↓ list) by list insertion
    }
   ]
   (
    English: if most efficient, insert (insertion: list of (thing)) at (boundary: list boundary) in (list: ↓ list of (thing)) by list insertion
   )
   C: “”
   C♯: “”
   Kotlin: “”
   Swift: “”
   {
    insert (insertion) at (boundary) in (↓ list) according to list insertion
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, append (insertion example: list of (thing)) to (↓ list) by replacement
    }
   ]
   (
    English: if most efficient, append (appendix: list of (thing)) to (list: ↓ list of (thing)) by replacement
   )
   C: “”
   C♯: “”
   Kotlin: “”
   Swift: “”
   {
    change (↓ list) to ((list) with (appendix) appended)
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) start as (non‐empty example: list of (thing))
     if most efficient, prepend (insertion example: list of (thing)) to (↓ list) by replacement
    }
   ]
   (
    English: if most efficient, prepend (prefix: list of (thing)) to (list: ↓ list of (thing)) by replacement
   )
   C: “”
   JavaScript: “”
   {
    change (↓ list) to ((list) with (prefix) prepended)
   }

  use (clients)
   insertion from (list of (thing)) into (list of (thing)) separated by (list boundary)
   {
    action (clients)
     (
      English: replace (range: range of (list boundary)) in (list: ↓ list of (thing)) with (insertion: list of (thing))
     )
     Swift: “” list “.replaceSubrange(” range “, with: ” insertion “)”
     {
      if most efficient, replace (range) in (↓ list) with (insertion) by replacement
      if most efficient, replace (range) in (↓ list) with (insertion) by bounds
     }

    action (clients)
     (
      English: (list: list of (thing)) with (range: range of (list boundary)) replaced with (insertion: list of (thing))
     )
     list of (thing)
     {
      ← if most efficient, (if most efficient, (if most efficient, (list) with (range) replaced with (insertion) by bounds) with (range) replaced with (insertion) by list insertion) with (range) replaced with (insertion) by appending
     }

    action (clients)
     (
      English: insert (insertion: list of (thing)) at (boundary: list boundary) in (list: ↓ list of (thing))
     )
     C: “g¤(5F)array¤(5F)insert¤(5F)vals(” list “, ” boundary “, ” insertion “¤(2D)>data, ” insertion “¤(2D)>len)”
     C♯: “” list “.InsertRange(” boundary “, ” insertion “)”
     Swift: “” list “.insert(contentsOf: ” insertion “, at: ” boundary “)”
     {
      if most efficient, insert (insertion) at (boundary) in (↓ list) by replacement
      if most efficient, insert (insertion) at (boundary) in (↓ list) by list insertion
     }

    action (clients)
     (
      English: (list: list of (thing)) with (insertion: list of (thing)) inserted at (boundary: list boundary)
     )
     list of (thing)
     Kotlin: “” list “.toMutableList().apply { addAll(” boundary “, ” insertion “) }.toList()”
     {
      ← (list) with (insertion) inserted at (boundary) according to list insertion
     }

    action (clients)
     (
      English: append (appendix: list of (thing)) to (list: ↓ list of (thing))
     )
     C: “g¤(5F)array¤(5F)append¤(5F)vals(” list “, ” appendix “¤(2D)>data, ” appendix “¤(2D)>len)”
     C♯: “” list “.AddRange(” appendix “)”
     Kotlin: “” list “ += ” appendix “”
     Swift: “” list “ += ” appendix “”
     {
      if most efficient, append (appendix) to (↓ list) by replacement
     }

    action (clients)
     (
      English: (list: list of (thing)) with (appendix: list of (thing)) appended
     )
     list of (thing)
     C♯: “” list “.Concat(” appendix “).ToList()” (“System.Linq”)
     JavaScript: “” list “.concat(” appendix “)”
     Kotlin: “” list “ + ” appendix “”
     Swift: “” list “ + ” appendix “”
     {
      ← (list) with (appendix) appended according to list insertion
     }

    action (clients)
     (
      English: prepend (prefix: list of (thing)) to (list: ↓ list of (thing))
     )
     C: “g¤(5F)array¤(5F)prepend¤(5F)vals(” list “, ” prefix “¤(2D)>data, ” prefix “¤(2D)>len)”
     JavaScript: “” list “.unshift(...” prefix “)”
     {
      if most efficient, prepend (prefix) to (↓ list) by replacement
     }

    action (clients)
     (
      English: (list: list of (thing)) with (prefix: list of (thing)) prepended
     )
     list of (thing)
     C♯: “” prefix “.Concat(” list “).ToList()” (“System.Linq”)
     JavaScript: “” prefix “.concat(” list “)”
     Kotlin: “” prefix “ + ” list “”
     Swift: “” prefix “ + ” list “”
     {
      ← (list) with (prefix) prepended according to list insertion
     }

    action (clients)
     (
      English: convert (other: list of (thing)) into list
     )
     list of (thing)
     C: “” hold on (other) “”
     C♯: “” other “”
     JavaScript: “” other “”
     Kotlin: “” other “”
     Swift: “” other “”

    action (clients)
     (
      English: insertion example
     )
     list of (thing)
     {
      ← non‐empty example
     }
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     let (• result: list of (thing)) start as (empty: list of (thing))
     if most efficient, convert ((from (beginning of (list)) to (end of (list))) in (list)) into list by iteration and store in (↓ result)
    }
   ]
   (
    English: if most efficient, convert (other: slice of (list of (thing))) into list by iteration and store in (result: ↓ list of (thing))
   )
   C♯: “”
   JavaScript: “”
   Kotlin: “”
   Swift: “”
   {
    for each (• element: thing) in (other), {
     append (element) to (↓ result)
    }
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     ignore (convert from (beginning of (list)) to (end of (list)) in (list) into list)
    }
   ]
   (
    English: convert from (lower bound: list boundary) to (upper bound: list boundary) in (list: list of (thing)) into list
   )
   list of (thing)
   C♯: “” list “.GetRange(” lower bound “, ” upper bound “ ¤(2D) ” lower bound “)”
   JavaScript: “” list “.slice(” lower bound “, ” upper bound “)”
   Kotlin: “” list “.slice(” lower bound “..<” upper bound “)”
   {
    ← empty
   }

  action (file)
   [
    test {
     let (• list: list of (thing)) be (non‐empty example: list of (thing))
     let (• result: list of (thing)) start as (empty: list of (thing))
     if most efficient, convert ((from (beginning of (list)) to (end of (list))) in (list)) into list by bounds and store in (↓ result)
    }
   ]
   (
    English: if most efficient, convert (other: slice of (list of (thing))) into list by bounds and store in (result: ↓ list of (thing))
   )
   C: “”
   Swift: “”
   {
    change (↓ result) to (convert from (beginning of (other)) to (end of (other)) in ((whole) of (other)) into list)
   }

  use (clients)
   insertion from (slice of (list of (thing))) into (list of (thing)) separated by (list boundary)
   {
    action (clients)
     (
      English: replace (range: range of (list boundary)) in (list: ↓ list of (thing)) with (insertion: slice of (list of (thing)))
     )
     Swift: “” list “.replaceSubrange(” range “, with: ” insertion “)”
     {
      replace (range) in (↓ list) with (convert (insertion) into list: list of (thing))
     }

    action (clients)
     (
      English: insert (insertion: slice of (list of (thing))) at (boundary: list boundary) in (list: ↓ list of (thing))
     )
     Swift: “” list “.insert(contentsOf: ” insertion “, at: ” boundary “)”
     {
      insert (convert (insertion) into list: list of (thing)) at (boundary) in (↓ list)
     }

    action (clients)
     (
      English: append (appendix: slice of (list of (thing))) to (list: ↓ list of (thing))
     )
     Swift: “” list “.append(contentsOf: ” appendix “)”
     {
      append (convert (appendix) into list: list of (thing)) to (↓ list)
     }

    action (clients)
     (
      English: convert (other: slice of (list of (thing))) into list
     )
     list of (thing)
     Swift: “Array(” other “)”
     {
      let (• copy: list of (thing)) start as (empty: list of (thing))
      if most efficient, convert (other) into list by bounds and store in (↓ copy)
      if most efficient, convert (other) into list by iteration and store in (↓ copy)
      ← copy
     }

    action (clients)
     (
      English: insertion example
     )
     slice of (list of (thing))
     {
      ← entirety of (insertion example: list of (thing))
     }
   }
 }
