extension
 general containers of (thing)
 {
  thing (unit)
   [
    [
     English: A rudimentary list whose memory must be managed manually.
    ]
    [
     English: While the lifetime of the list itself is the reponsibility of the developer, ownership of individual entries is managed automatically by the compiler.
    ]
    test {
     let (• list: unmanaged list of (reference tracker)) start as (empty: unmanaged list of (reference tracker))
     let (• original tracker: reference tracker) be (create reference tracker)
     let (• beginning: list boundary) be (beginning of (list))
     insert (restart (original tracker)) at (beginning) in (↓ list)
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing (one: natural number) entries))
     hold (↓ list)
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     release (↓ list)
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     let (• insertion tracker: reference tracker) be (create reference tracker)
     insert (restart (insertion tracker)) at (beginning) in (↓ list)
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     verify (reference count of (insertion tracker) is (two: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing (two: natural number) entries))
     let (• first: list index) be (index after (beginning) in (list) skipping bounds check)
     ignore (entry at (first) in (list))
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     verify (reference count of (insertion tracker) is (three: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing (two: natural number) entries))
     let (• replacement tracker: reference tracker) be (create reference tracker)
     replace (first) in (↓ list) with (restart (replacement tracker))
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     verify (reference count of (insertion tracker) is (two: platform fixed‐width integer))
     verify (reference count of (replacement tracker) is (two: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing (two: natural number) entries))
     release (↓ list)
     verify (reference count of (original tracker) is (one: platform fixed‐width integer))
     verify (reference count of (insertion tracker) is (two: platform fixed‐width integer))
     verify (reference count of (replacement tracker) is (one: platform fixed‐width integer))
    }
   ]
   (
    English: unmanaged list of (thing)
   )
   {
    part (file)
     (
      English: uncounted
     )
     unmanaged list of (thing) of unknown length

    part (file)
     (
      English: end
     )
     list boundary

    part (file)
     (
      English: limit
     )
     list boundary

    part (file)
     (
      English: references
     )
     platform fixed‐width natural number
   }

  action (file)
   (
    English: create unmanaged list with uncounted (uncounted: unmanaged list of (thing) of unknown length), end (end: list boundary), limit (limit: list boundary) and references (references: platform fixed‐width natural number)
   )
   unmanaged list of (thing)
   create

  use (unit)
   general use of (unmanaged list of (thing))
   {
   }

  action (file)
   (
    English: create unmanaged list with uncounted (uncounted: unmanaged list of (thing) of unknown length), end (end: list boundary) and limit (limit: list boundary)
   )
   unmanaged list of (thing)
   {
    ← create unmanaged list with uncounted (uncounted), end (end), limit (limit) and references (one: platform fixed‐width natural number)
   }

  action (file)
   (
    English: hold (list: ↓ unmanaged list of (thing))
   )
   {
    increment (↓ (references) of (list))
   }

  action (file)
   (
    English: release (list: ↓ unmanaged list of (thing))
   )
   {
    if (((references) of (list)) is less than (one: platform fixed‐width natural number)), {
     !
    }
    decrement (↓ (references) of (list)) skipping underflow check
    if (((references) of (list)) is (zero: platform fixed‐width natural number)), {
     clean ((uncounted) of (list)) up up to ((end) of (list))
    }
   }

  action (unit)
   (
    English: index after (boundary: list boundary) in (list: unmanaged list of (thing)) skipping bounds check
    Swift: (self: [list]).indexSkippingBoundsCheck afterBoundary (boundary: [boundary])
   )
   list index
   {
    ← index after (boundary) in ((uncounted) of (list)) skipping bounds check
   }

  action (unit)
   (
    English: beginning of (list: unmanaged list of (thing))
    Deutsch: Anfang von (Liste: [list])
    français : début de (liste: [list])
    ελληνικά: αρχή (κατάλογος: [list])
    Swift: var (self: [list]).startIndex
   )
   list boundary
   {
    ← beginning of ((uncounted) of (list))
   }

  action (unit)
   (
    English: end of (list: unmanaged list of (thing))
    Deutsch: Ende von (Liste: [list])
    français : fin de (liste: [list])
    ελληνικά: τέλος (κατάλογος: [list])
    Swift: var (self: [list]).endIndex
   )
   list boundary
   {
    ← (end) of (list)
   }

  action (unit)
   (
    English: advance (cursor: ↓ list boundary) to next in (list: unmanaged list of (thing)) skipping bounds check
    Swift: (self: [list]).formIndex after (i: [cursor])
   )
   {
    advance (↓ cursor) to next in ((uncounted) of (list)) skipping bounds check
   }

  action (unit)
   (
    English: boundary after (cursor: list boundary) in (list: unmanaged list of (thing)) skipping bounds check
    Swift: (self: [list]).index after (i: [cursor])
   )
   list boundary
   {
    let (• copy: list boundary) start as (cursor)
    advance (↓ copy) to next in (list) skipping bounds check
    ← copy
   }

  action (unit)
   (
    English: entry at (index: list index) in (list: unmanaged list of (thing))
    Swift: (self: [list]).subscript entryIndex (index: [index])
   )
   thing
   {
    if ((index) is within ((uncounted) of (list)) ending at ((end) of (list))), {
     ← entry at (index) in ((uncounted) of (list))
    }
    !
   }

  action (unit)
   (
    English: empty
    Deutsch: leer
    français : vide
    ελληνικά: άδειος
   )
   unmanaged list of (thing)
   {
    ← create unmanaged list with uncounted (unallocated: unmanaged list of (thing) of unknown length), end (end of empty list) and limit (end of empty list)
   }

  action (unit)
   (
    English: replace (index: list index) in (list: ↓ unmanaged list of (thing)) with (element: thing)
   )
   {
    if ((index) is within ((uncounted) of (list)) ending at ((end) of (list))), {
     replace (index) in (↓ (uncounted) of (list)) with (element)
    }, otherwise {
     !
    }
   }

  action (file)
   (
    English: resize storage of (list: ↓ unmanaged list of (thing)) to end at (new limit: list boundary)
   )
   {
    if (((limit) of (list)) is (end of empty list), {
     change (↓ (uncounted) of (list)) to (allocate memory up to (new limit))
    }, otherwise {
     reallocate memory of (↓ (uncounted) of (list)) up to (new limit)
    }
    change ((limit) of (list)) to (new limit)
   }

  action (unit)
   (
    English: insert (element: thing) at (boundary: list boundary) in (list: ↓ unmanaged list of (thing))
   )
   {
    let (• original end: list boundary) be (end of (list))
    if ((boundary) is greater than (original end)), {
     !
    }
    if ((original end) is ((limit) of (list))), {
     if ((original end) is (end of empty list)), {
      resize storage of (↓ list) to end at (end of list containing one entry)
     }, otherwise {
      resize storage of (↓ list) to end at (double (original end))
     }
    }
    if ((boundary) is not (original end)), {
     move (from (boundary) to (original end)) to (boundary after (boundary) in (list) skipping bounds check) in (↓ (uncounted) of (list))
    }
    initialize entry at (index after (boundary) in (list) skipping bounds check) in (↓ (uncounted) of (list)) to (element)
    advance (↓ (end) of (list)) to next in (list) skipping bounds check
   }
 }

action (file)
 (
  English: double (end: list boundary)
 )
 list boundary
 C: “” end “ ¤(2A) 2”
 C♯: “” end “ ¤(2A) 2”
 JavaScript: “” end “ ¤(2A) 2”
 Kotlin: “” end “ ¤(2A) 2”
 Swift: “” end “ ¤(2A) 2”
