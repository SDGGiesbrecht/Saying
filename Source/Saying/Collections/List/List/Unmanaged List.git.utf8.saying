extension
 general containers of (thing)
 {
  thing (unit)
   [
    [
     English: A rudimentary list whose memory must be managed manually.
    ]
    [
     English: While the lifetime of the list itself is the reponsibility of the developer, ownership of individual entries is managed automatically by the compiler.
    ]
    test {
     let (• list: unmanaged list of (reference tracker)) start as (empty: unmanaged list of (reference tracker))
     let (• original tracker: reference tracker) be (create reference tracker)
     let (• beginning: list boundary) be (beginning of (list))
     insert (restart (original tracker)) at (beginning) in (↓ list)
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing (one: natural number) entries))
     hold (↓ list)
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     release (↓ list)
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     let (• insertion tracker: reference tracker) be (create reference tracker)
     insert (restart (insertion tracker)) at (beginning) in (↓ list)
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     verify (reference count of (insertion tracker) is (two: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing (two: natural number) entries))
     let (• first: list index) be (index after (beginning) in (list) skipping bounds check)
     ignore (entry at (first) in (list))
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     verify (reference count of (insertion tracker) is (three: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing (two: natural number) entries))
     let (• replacement tracker: reference tracker) be (create reference tracker)
     replace (first) in (↓ list) with (restart (replacement tracker))
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     verify (reference count of (insertion tracker) is (two: platform fixed‐width integer))
     verify (reference count of (replacement tracker) is (two: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing (two: natural number) entries))
     remove (first) from (↓ list)
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     verify (reference count of (insertion tracker) is (two: platform fixed‐width integer))
     verify (reference count of (replacement tracker) is (one: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing (one: natural number) entries))
     release (↓ list)
     verify (reference count of (original tracker) is (one: platform fixed‐width integer))
     verify (reference count of (insertion tracker) is (two: platform fixed‐width integer))
     verify (reference count of (replacement tracker) is (one: platform fixed‐width integer))
    }
   ]
   (
    English: unmanaged list of (thing)
   )
   {
    part (file)
     (
      English: uncounted
     )
     unmanaged list of (thing) of unknown length

    part (file)
     (
      English: end
     )
     list boundary

    part (file)
     (
      English: limit
     )
     list boundary

    part (file)
     (
      English: references
     )
     platform fixed‐width natural number
   }

  action (file)
   (
    English: create unmanaged list with uncounted (uncounted: unmanaged list of (thing) of unknown length), end (end: list boundary), limit (limit: list boundary) and references (references: platform fixed‐width natural number)
   )
   unmanaged list of (thing)
   create

  use (unit)
   general use of (unmanaged list of (thing))
   {
   }

  action (file)
   (
    English: create unmanaged list with uncounted (uncounted: unmanaged list of (thing) of unknown length), end (end: list boundary) and limit (limit: list boundary)
   )
   unmanaged list of (thing)
   {
    ← create unmanaged list with uncounted (uncounted), end (end), limit (limit) and references (one: platform fixed‐width natural number)
   }

  action (file)
   (
    English: hold (list: ↓ unmanaged list of (thing))
   )
   {
    increment (↓ (references) of (list))
   }

  action (file)
   (
    English: release (list: ↓ unmanaged list of (thing))
   )
   {
    if (((references) of (list)) is less than (one: platform fixed‐width natural number)), {
     !
    }
    decrement (↓ (references) of (list)) skipping underflow check
    if (((references) of (list)) is (zero: platform fixed‐width natural number)), {
     clean ((uncounted) of (list)) up up to ((end) of (list))
    }
   }

  action (unit)
   (
    English: index after (boundary: list boundary) in (list: unmanaged list of (thing)) skipping bounds check
    Swift: (self: [list]).indexSkippingBoundsCheck afterBoundary (boundary: [boundary])
   )
   list index
   {
    ← index after (boundary) in ((uncounted) of (list)) skipping bounds check
   }

  action (unit)
   (
    English: boundary before (index: list index) in (list: unmanaged list of (thing))
   )
   list boundary
   {
    ← boundary before (index) in ((uncounted) of (list))
   }

  action (unit)
   (
    English: beginning of (list: unmanaged list of (thing))
    Deutsch: Anfang von (Liste: [list])
    français : début de (liste: [list])
    ελληνικά: αρχή (κατάλογος: [list])
    Swift: var (self: [list]).startIndex
   )
   list boundary
   {
    ← beginning of ((uncounted) of (list))
   }

  action (unit)
   (
    English: end of (list: unmanaged list of (thing))
    Deutsch: Ende von (Liste: [list])
    français : fin de (liste: [list])
    ελληνικά: τέλος (κατάλογος: [list])
    Swift: var (self: [list]).endIndex
   )
   list boundary
   {
    ← (end) of (list)
   }

  action (unit)
   (
    English: advance (cursor: ↓ list boundary) to next in (list: unmanaged list of (thing)) skipping bounds check
    Swift: (self: [list]).formIndex after (i: [cursor])
   )
   {
    advance (↓ cursor) to next in ((uncounted) of (list)) skipping bounds check
   }

  action (unit)
   (
    English: boundary after (cursor: list boundary) in (list: unmanaged list of (thing)) skipping bounds check
    Swift: (self: [list]).index after (i: [cursor])
   )
   list boundary
   {
    let (• copy: list boundary) start as (cursor)
    advance (↓ copy) to next in (list) skipping bounds check
    ← copy
   }

  action (unit)
   (
    English: entry at (index: list index) in (list: unmanaged list of (thing))
    Swift: (self: [list]).subscript entryIndex (index: [index])
   )
   thing
   {
    if ((index) is within ((uncounted) of (list)) ending at ((end) of (list))), {
     ← entry at (index) in ((uncounted) of (list))
    }
    !
   }

  action (unit)
   (
    English: empty
    Deutsch: leer
    français : vide
    ελληνικά: άδειος
   )
   unmanaged list of (thing)
   {
    ← create unmanaged list with uncounted (unallocated: unmanaged list of (thing) of unknown length), end (end of empty list) and limit (end of empty list)
   }

  action (unit)
   (
    English: replace (index: list index) in (list: ↓ unmanaged list of (thing)) with (element: thing)
   )
   {
    if ((index) is within ((uncounted) of (list)) ending at ((end) of (list))), {
     replace (index) in (↓ (uncounted) of (list)) with (element)
    }, otherwise {
     !
    }
   }

  action (file)
   (
    English: resize storage of (list: ↓ unmanaged list of (thing)) to end at (new limit: list boundary)
   )
   {
    if (((limit) of (list)) is (end of empty list)), {
     change (↓ (uncounted) of (list)) to (allocate memory up to (new limit): unmanaged list of (thing) of unknown length)
    }, otherwise {
     reallocate memory of (↓ (uncounted) of (list)) up to (new limit)
    }
    change ((limit) of (list)) to (new limit)
   }

  action (unit)
   (
    English: insert (element: thing) at (boundary: list boundary) in (list: ↓ unmanaged list of (thing))
   )
   {
    let (• original end: list boundary) be (end of (list))
    if ((boundary) is greater than (original end)), {
     !
    }
    if ((original end) is ((limit) of (list))), {
     if ((original end) is (end of empty list)), {
      resize storage of (↓ list) to end at (end of list containing one entry)
     }, otherwise {
      resize storage of (↓ list) to end at ((original end) grown by (growth factor))
     }
    }
    if ((boundary) is not (original end)), {
     move (from (boundary) to (original end)) to (boundary after (boundary) in (list) skipping bounds check) in (↓ (uncounted) of (list))
    }
    initialize entry at (index after (boundary) in (list) skipping bounds check) in (↓ (uncounted) of (list)) to (element)
    advance (↓ (end) of (list)) to next in (list) skipping bounds check
   }

  action (unit)
   (
    English: remove (index: list index) from (list: ↓ unmanaged list of (thing))
   )
   {
    let (• boundary before: list boundary) be (boundary before (index) in (list))
    remove (from (boundary before) to (boundary after (boundary before) in (list) skipping bounds check)) from (↓ list)
   }

  action (unit)
   [
    test {
     let (• list: unmanaged list of (thing)) start as (empty: unmanaged list of (thing))
     let (• out of bounds: list boundary) be (end of list containing (two: natural number) entries)
     remove (from (out of bounds) to (out of bounds)) from (↓ list)
     verify (((end) of (list)) is (end of empty list))
     let (• beginning: list boundary) be (beginning of (list))
     insert (example: thing) at (beginning) in (↓ list)
     remove (from (end of empty list) to (out of bounds)) from (↓ list)
     verify (((end) of (list)) is (end of empty list))
     insert (example: thing) at (beginning) in (↓ list)
     remove (from (end of list containing one entry) to (out of bounds)) from (↓ list)
     verify (((end) of (list)) is (end of list containing one entry))
     release (↓ list)
    }
   ]
   (
    English: remove (range: range of (list boundary)) from (list: ↓ unmanaged list of (thing))
   )
   {
    let (• original end: list boundary) be ((end) of (list))
    let (• beginning of range: list boundary) be ((lower bound) of (range))
    if ((beginning of range) is greater than or equal to (original end)), {
     ←
    }
    let (• end of range: list boundary) start as ((upper bound) of (range))
    if ((end of range) is greater than (original end)), {
     change (end of range) to (original end)
    }
    let (• removal range: range of (list boundary)) be (from (beginning of range) to (end of range))
    remove (removal range) from (↓ (uncounted) of (list))
    let (• trailing range: range of (list boundary)) be (from (end of range) to (original end))
    if ((end of range) is not (original end)), {
     move (trailing range) to (beginning of range) in (↓ (uncounted) of (list))
    }
    change ((end) of (list)) to (distance (length of (trailing range)) after (beginning of range))
    let (• smaller limit: list boundary) be (((limit) of (list)) shrunk by (growth factor))
    if (((end) of (list)) is less than or equal to ((smaller limit) shrunk by (growth factor))), {
     resize storage of (↓ list) to end at (smaller limit)
    }
   }
 }

action (file)
 (
  English: growth factor
 )
 list boundary
 C: “2”
 C♯: “2”
 JavaScript: “2”
 Kotlin: “2”
 Swift: “2”

action (file)
 (
  English: (end: list boundary) grown by (factor: list boundary)
 )
 list boundary
 C: “” end “ ¤(2A) ” factor “”
 C♯: “” end “ ¤(2A) ” factor “”
 JavaScript: “” end “ ¤(2A) ” factor “”
 Kotlin: “” end “ ¤(2A) ” factor “”
 Swift: “” end “ ¤(2A) ” factor “”

action (file)
 (
  English: (end: list boundary) shrunk by (factor: list boundary)
 )
 list boundary
 C: “” end “ / ” factor “”
 C♯: “” end “ / ” factor “”
 JavaScript: “Math.floor(” end “ / ” factor “)”
 Kotlin: “” end “ / ” factor “”
 Swift: “” end “ / ” factor “”
