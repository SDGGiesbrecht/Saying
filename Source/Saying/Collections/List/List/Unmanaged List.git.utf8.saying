extension
 general containers of (thing)
 {
  thing (unit)
   [
    [
     English: A rudimentary list whose memory must be managed manually.
    ]
    [
     English: While the lifetime of the list itself is the reponsibility of the developer, ownership of individual entries is managed automatically by the compiler.
    ]
    test {
     let (• list: unmanaged list of (reference tracker)) start as (empty: unmanaged list of (reference tracker))
     let (• original tracker: reference tracker) be (create reference tracker)
     let (• beginning: list boundary) be (beginning of (list))
     insert (restart (original tracker)) at (beginning) in (↓ list)
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing (one: natural number) entries))
     hold (↓ list)
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     release (↓ list)
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     let (• insertion tracker: reference tracker) be (create reference tracker)
     insert (restart (insertion tracker)) at (beginning) in (↓ list)
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     verify (reference count of (insertion tracker) is (two: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing (two: natural number) entries))
     let (• first: list index) be (index after (beginning) in (list) skipping bounds check)
     ignore (entry at (first) in (list))
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     verify (reference count of (insertion tracker) is (three: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing (two: natural number) entries))
     let (• replacement tracker: reference tracker) be (create reference tracker)
     replace (first) in (↓ list) with (restart (replacement tracker))
     verify (reference count of (original tracker) is (two: platform fixed‐width integer))
     verify (reference count of (insertion tracker) is (two: platform fixed‐width integer))
     verify (reference count of (replacement tracker) is (two: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing (two: natural number) entries))
     release (↓ list)
     verify (reference count of (original tracker) is (one: platform fixed‐width integer))
     verify (reference count of (insertion tracker) is (two: platform fixed‐width integer))
     verify (reference count of (replacement tracker) is (one: platform fixed‐width integer))
    }
   ]
   (
    English: unmanaged list of (thing)
   )
   {
    part (file)
     (
      English: uncounted
     )
     unmanaged list of (thing) of unknown length

    part (file)
     (
      English: end
     )
     list boundary

    part (file)
     (
      English: limit
     )
     list boundary

    part (file)
     (
      English: references
     )
     platform fixed‐width natural number
   }

  action (file)
   (
    English: create unmanaged list with uncounted (uncounted: unmanaged list of (thing) of unknown length), end (end: list boundary), limit (limit: list boundary) and references (references: platform fixed‐width natural number)
   )
   unmanaged list of (thing)
   create

  use (unit)
   general use of (unmanaged list of (thing))
   {
   }

  action (file)
   (
    English: create unmanaged list with uncounted (uncounted: unmanaged list of (thing) of unknown length), end (end: list boundary) and limit (limit: list boundary)
   )
   unmanaged list of (thing)
   {
    ← create unmanaged list with uncounted (uncounted), end (end), limit (limit) and references (one: platform fixed‐width natural number)
   }

  action (file)
   (
    English: hold (list: ↓ unmanaged list of (thing))
   )
   {
    increment (↓ (references) of (list))
   }

  action (file)
   (
    English: release (list: ↓ unmanaged list of (thing))
   )
   {
    if (((references) of (list)) is less than (one: platform fixed‐width natural number)), {
     !
    }
    decrement (↓ (references) of (list)) skipping underflow check
    if (((references) of (list)) is (zero: platform fixed‐width natural number)), {
     clean ((uncounted) of (list)) up up to ((end) of (list))
    }
   }

  action (unit)
   (
    English: index after (boundary: list boundary) in (list: unmanaged list of (thing)) skipping bounds check
    Swift: (self: [list]).indexSkippingBoundsCheck afterBoundary (boundary: [boundary])
   )
   list index
   {
    ← index after (boundary) in ((uncounted) of (list)) skipping bounds check
   }

  action (unit)
   (
    English: beginning of (list: unmanaged list of (thing))
    Deutsch: Anfang von (Liste: [list])
    français : début de (liste: [list])
    ελληνικά: αρχή (κατάλογος: [list])
    Swift: var (self: [list]).startIndex
   )
   list boundary
   {
    ← beginning of ((uncounted) of (list))
   }

  action (unit)
   (
    English: end of (list: unmanaged list of (thing))
    Deutsch: Ende von (Liste: [list])
    français : fin de (liste: [list])
    ελληνικά: τέλος (κατάλογος: [list])
    Swift: var (self: [list]).endIndex
   )
   list boundary
   {
    ← (end) of (list)
   }

  action (unit)
   (
    English: advance (cursor: ↓ list boundary) to next in (list: unmanaged list of (thing)) skipping bounds check
    Swift: (self: [list]).formIndex after (i: [cursor])
   )
   {
    advance (↓ cursor) to next in ((uncounted) of (list)) skipping bounds check
   }

  action (unit)
   (
    English: boundary after (cursor: list boundary) in (list: unmanaged list of (thing)) skipping bounds check
    Swift: (self: [list]).index after (i: [cursor])
   )
   list boundary
   {
    let (• copy: list boundary) start as (cursor)
    advance (↓ copy) to next in (list) skipping bounds check
    ← copy
   }

  action (unit)
   (
    English: entry at (index: list index) in (list: unmanaged list of (thing))
    Swift: (self: [list]).subscript entryIndex (index: [index])
   )
   thing
   {
    if ((index) is within ((uncounted) of (list)) ending at ((end) of (list))), {
     ← entry at (index) in ((uncounted) of (list))
    }
    !
   }

  action (unit)
   (
    English: empty
    Deutsch: leer
    français : vide
    ελληνικά: άδειος
   )
   unmanaged list of (thing)
   {
    ← create unmanaged list with uncounted (unallocated: unmanaged list of (thing) of unknown length), end (end of empty list) and limit (end of empty list)
   }

  action (unit)
   (
    English: replace (index: list index) in (list: ↓ unmanaged list of (thing)) with (element: thing)
   )
   {
    if ((index) is within ((uncounted) of (list)) ending at ((end) of (list))), {
     replace (index) in (↓ (uncounted) of (list)) with (element)
    }, otherwise {
     !
    }
   }

  action (file)
   (
    English: resize storage of (list: ↓ unmanaged list of (thing)) to end at (new limit: list boundary)
   )
   {
    if (((limit) of (list)) is (end of empty list)), {
     change ((uncounted) of (list)) to (allocate memory up to (new limit): unmanaged list of (thing) of unknown length)
    }, otherwise {
     reallocate memory of (↓ (uncounted) of (list)) up to (new limit)
    }
    change ((limit) of (list)) to (new limit)
   }

  action (file)
   (
    English: ensure enough storage for (new end: list boundary) in (list: ↓ unmanaged list of (thing))
   )
   {
    if ((new end) is greater than ((limit) of (list))), {
     resize storage of (↓ list) to end at ((new end) grown by (growth factor))
    }
   }

  action (unit)
   (
    English: insert (element: thing) at (boundary: list boundary) in (list: ↓ unmanaged list of (thing))
   )
   {
    let (• original end: list boundary) be (end of (list))
    if ((boundary) is greater than (original end)), {
     !
    }
    let (• new end: list boundary) be (distance (end of list containing one entry) after (original end))
    ensure enough storage for (new end) in (↓ list)
    if ((boundary) is not (original end)), {
     move (from (boundary) to (original end)) to (boundary after (boundary) in (list) skipping bounds check) in (↓ (uncounted) of (list))
    }
    initialize entry at (index after (boundary) in (list) skipping bounds check) in (↓ (uncounted) of (list)) to (element)
    advance (↓ (end) of (list)) to next in (list) skipping bounds check
   }

  action (unit)
   [
    test {
     let (• replacement: unmanaged list of (reference tracker)) start as (empty: unmanaged list of (reference tracker))
     let (• tracker: reference tracker) be (create reference tracker)
     insert (restart (tracker)) at (beginning of (replacement)) in (↓ replacement)
     verify (reference count of (tracker) is (two: platform fixed‐width integer))
     let (• list: unmanaged list of (reference tracker)) start as (empty: unmanaged list of (reference tracker))
     verify (((end) of (list)) is (end of empty list))
     verify (((limit) of (list)) is (end of empty list))
     let (• beginning: list boundary) be (beginning of (list))
     replace (from (beginning) to (beginning)) in (↓ list) with (replacement)
     verify (reference count of (tracker) is (three: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing one entry))
     verify (((limit) of (list)) is (end of list containing (two: natural number) entries))
     replace (from (beginning) to (beginning)) in (↓ list) with (replacement)
     verify (reference count of (tracker) is (four: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing (two: natural number) entries))
     verify (((limit) of (list)) is (end of list containing (two: natural number) entries))
     replace (from (beginning) to (beginning)) in (↓ list) with (replacement)
     verify (reference count of (tracker) is (five: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing (three: natural number) entries))
     verify (((limit) of (list)) is (end of list containing (six: natural number) entries))
     let (• first: range of (list boundary)) be (from (beginning) to (boundary after (beginning) in (list) skipping bounds check))
     replace (first) in (↓ list) with (empty: unmanaged list of (reference tracker))
     verify (reference count of (tracker) is (four: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing (two: natural number) entries))
     verify (((limit) of (list)) is (end of list containing (six: natural number) entries))
     replace (first) in (↓ list) with (empty: unmanaged list of (reference tracker))
     verify (reference count of (tracker) is (three: platform fixed‐width integer))
     verify (((end) of (list)) is (end of list containing one entry))
     verify (((limit) of (list)) is (end of list containing (two: natural number) entries))
     replace (first) in (↓ list) with (empty: unmanaged list of (reference tracker))
     verify (reference count of (tracker) is (two: platform fixed‐width integer))
     verify (((end) of (list)) is (end of empty list))
     verify (((limit) of (list)) is (end of empty list))
     release (↓ list)
     release (↓ replacement)
    }
   ]
   (
    English: replace (range: range of (list boundary)) in (list: ↓ unmanaged list of (thing)) with (replacement: unmanaged list of (thing))
    Swift: (self: [list]).replaceSubrange (subrange: [range]) with (newElements: [replacement])
   )
   {
    let (• original end: list boundary) be ((end) of (list))
    let (• beginning of removal: list boundary) be ((lower bound) of (range))
    if ((beginning of removal) is greater than (original end)), {
     !
    }
    let (• end of removal: list boundary) be ((upper bound) of (range))
    if ((end of removal) is greater than (original end)), {
     !
    }
    remove (range) from (↓ (uncounted) of (list))
    let (• trailing range: range of (list boundary)) be (from (end of removal) to (original end))
    let (• length of replacement: list boundary) be (end of (replacement))
    let (• end of insertion: list boundary) be (distance (length of replacement) after (beginning of removal))
    let (• new end: list boundary) be (distance (length of (trailing range)) after (end of insertion))
    ensure enough storage for (new end) in (↓ list)
    if ((end of removal) is not (original end)), {
     if ((new end) is not (original end)), {
      move (trailing range) to (end of insertion) in (↓ (uncounted) of (list))
     }
    }
    change ((end) of (list)) to (new end)
    if ((new end) is less than (original end)), {
     if ((new end) is less than or equal to ((((limit) of (list)) shrunk by (growth factor)) shrunk by (growth factor))), {
      resize storage of (↓ list) to end at ((new end) grown by (growth factor))
     }
    }
    if ((length of replacement) is greater than (end of empty list)), {
     copy (from (beginning of (replacement)) to (end of (replacement))) from ((uncounted) of (replacement)) to (beginning of removal) in (↓ (uncounted) of (list))
    }
   }
 }

action (file)
 (
  English: growth factor
 )
 list boundary
 C: “2”
 C♯: “2”
 JavaScript: “2”
 Kotlin: “2”
 Swift: “2”

action (file)
 (
  English: (end: list boundary) grown by (factor: list boundary)
 )
 list boundary
 C: “” end “ ¤(2A) ” factor “”
 C♯: “” end “ ¤(2A) ” factor “”
 JavaScript: “” end “ ¤(2A) ” factor “”
 Kotlin: “” end “ ¤(2A) ” factor “”
 Swift: “” end “ ¤(2A) ” factor “”

action (file)
 (
  English: (end: list boundary) shrunk by (factor: list boundary)
 )
 list boundary
 C: “” end “ / ” factor “”
 C♯: “” end “ / ” factor “”
 JavaScript: “Math.floor(” end “ / ” factor “)”
 Kotlin: “” end “ / ” factor “”
 Swift: “” end “ / ” factor “”
