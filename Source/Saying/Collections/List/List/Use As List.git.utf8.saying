ability (clients)
 (
  English: use of (list) as list of (element) indexed by (index) separated by (boundary)
 )
 {
  requirement (clients)
   [
    test {ignore (index after (beginning of (non‐empty example: list)) in (non‐empty example: list) skipping bounds check)}
   ]
   (
    English: index after (boundary: boundary) in (list: list) skipping bounds check
    Swift: (self: [list]).indexSkippingBoundsCheck afterBoundary (boundary: [boundary])
   )
   index

  requirement (clients)
   (
    English: beginning of (list: list)
    Deutsch: Anfang von (Liste: [list])
    français : début de (liste: [list])
    ελληνικά: αρχή (κατάλογος: [list])
    Swift: var (self: [list]).startIndex
   )
   boundary

  requirement (clients)
   [
    test {
     let (• non‐empty: list) be (non‐empty example: list)
     verify ((beginning of (non‐empty)) is not (end of (non‐empty)))
    }
   ]
   (
    English: end of (list: list)
    Deutsch: Ende von (Liste: [list])
    français : fin de (liste: [list])
    ελληνικά: τέλος (κατάλογος: [list])
    Swift: var (self: [list]).endIndex
   )
   boundary

  requirement (clients)
   [
    test {
     let (• non‐empty: list) be (non‐empty example: list)
     let (• beginning: boundary) be (beginning of (non‐empty))
     let (• cursor: boundary) start as (beginning)
     advance (↓ cursor) to next in (non‐empty) skipping bounds check
     verify ((cursor) is not (beginning))
    }
   ]
   (
    English: advance (cursor: ↓ boundary) to next in (list: list) skipping bounds check
    Swift: (self: [list]).formIndex after (i: [cursor])
   )

  choice (clients)
   [
    test {
     let (• non‐empty: list) be (non‐empty example: list)
     let (• beginning: boundary) be (beginning of (non‐empty))
     verify ((boundary after (beginning) in (non‐empty) skipping bounds check) is not (beginning))
    }
   ]
   (
    English: boundary after (cursor: boundary) in (list: list) skipping bounds check
    Swift: (self: [list]).index after (i: [cursor])
   )
   boundary
   {
    let (• copy: boundary) start as (cursor)
    advance (↓ copy) to next in (list) skipping bounds check
    ← copy
   }

  requirement (clients)
   [
    test {
     let (• non‐empty: list) be (non‐empty example: list)
     let (• index: index) be (index after (beginning of (non‐empty)) in (non‐empty) skipping bounds check)
     ignore (entry at (index) in (non‐empty))
    }
   ]
   (
    English: entry at (index: index) in (list: list)
    Swift: (self: [list]).subscript entryIndex (index: [index])
   )
   element

  choice (clients)
   [
    test {
     let (• non‐empty: list) be (non‐empty example: list)
     ignore (entry after (beginning of (non‐empty)) in (non‐empty) skipping bounds check)
    }
   ]
   (
    English: entry after (cursor: boundary) in (list: list) skipping bounds check
    Swift: (self: [list]).subscript (position: [cursor])
   )
   element
   {
    ← entry at (index after (cursor) in (list) skipping bounds check) in (list)
   }

  choice (clients)
   [
    test {verify ((first in (non‐empty example: list)) exists)}
   ]
   (
    English: first in (list: list)
    Deutsch: erster in (Liste: [list])
    français : premier dans (liste: [list])
    ελληνικά: πρώτος σε (κατάλογος: [list])
    Swift: var (self: [list]).first
   )
   optional (element)
   Swift: “” list “.first” [
     “==(¤(5F): ” boundary “, ¤(5F): ” boundary “)”
     “<(¤(5F): ” boundary “, ¤(5F): ” boundary “)”
     “” list “.startIndex”
     “” list “.endIndex”
     “” list “.subscript(¤(5F): ” boundary “)”
     “” list “.isEmpty”
     “” list “.index(after: ” boundary “)”
    ] {
     “extension ” list “: Collection {}”
     “extension ” boundary “: Comparable {}”
    }
   {
    ← first in (list) according to default use as list
   }

  choice (clients)
   [
    test {verify ((empty: list) is empty)}
   ]
   (
    English: (list: list) is empty
    Deutsch: (Liste: [list]) ist leer
    français : (liste: [list]) est vide
    ελληνικά: (κατάλογος: [list]) είναι άδειος
    Swift: var (self: [list]).isEmpty
   )
   truth value
   Swift: “” list “.isEmpty” [
     “==(¤(5F): ” boundary “, ¤(5F): ” boundary “)”
     “<(¤(5F): ” boundary “, ¤(5F): ” boundary “)”
     “” list “.startIndex”
     “” list “.endIndex”
     “” list “.subscript(¤(5F): ” boundary “)”
     “” list “.index(after: ” boundary “)”
    ] {
     “extension ” list “: Collection {}”
     “extension ” boundary “: Comparable {}”
    }
   {
    ← (list) is empty according to default use as list
   }

  choice (clients)
   [
    test {verify ((non‐empty example: list) is not empty)}
   ]
   (
    English: (list: list) is not empty
    Deutsch: (Liste: [list]) ist nicht leer
    français : (liste: [list]) n’est pas vide
    ελληνικά: (κατάλογος: [list]) δεν είναι άδειος
    Swift: var (self: [list]).isNotEmpty
   )
   truth value
   {
    ← (list) is not empty according to default use as list
   }

  requirement (clients)
   [
    test {verify ((empty: list) is empty)}
   ]
   (
    English: empty
    Deutsch: leer
    français : vide
    ελληνικά: άδειος
   )
   list

  requirement (clients)
   (
    English: non‐empty example
   )
   list
 }

extension
 use of (list) as list of (element) indexed by (index) separated by (boundary)
 {
  use (clients)
   general use of (list)
   {
   }

  action (clients)
   [
    test {verify ((index after (beginning of (non‐empty example: list)) in (non‐empty example: list)) exists)}
    test {verify ((index after (beginning of (empty: list)) in (empty: list)) does not exist)}
   ]
   (
    English: index after (boundary: boundary) in (list: list)
    Swift: (self: [list]).index afterBoundary (boundary: [boundary])
   )
   optional (index)
   {
    if ((boundary) is less than (end of (list))), {
     ← wrap (index after (boundary) in (list) skipping bounds check) into optional
    }
    ← nothing
   }

  action (clients)
   [
    test {verify ((boundary after (beginning of (non‐empty example: list)) in (non‐empty example: list)) exists)}
    test {verify ((boundary after (end of (non‐empty example: list)) in (non‐empty example: list)) does not exist)}
   ]
   (
    English: boundary after (cursor: boundary) in (list: list)
    Swift: (self: [list]).boundary after (cursor: [cursor])
   )
   optional (boundary)
   {
    if ((cursor) is less than (end of (list))), {
     ← wrap (boundary after (cursor) in (list) skipping bounds check) into optional
    }
    ← nothing
   }

  action (clients)
   [
    test {
     verify ((first in (non‐empty example: list) according to default use as list) exists)
     verify ((first in (empty: list) according to default use as list) does not exist)
    }
   ]
   (
    English: first in (list: list) according to default use as list
    Swift: var (self: [list]).firstAccordingToDefaultUseAsList
   )
   optional (element)
   {
    if (index after (beginning of (list)) in (list)) exists, unwrap it as (• first: index), {
     ← wrap (entry at (first) in (list)) into optional
    }
    ← nothing
   }

  action (clients)
   [
    test {verify ((empty: list) is empty according to default use as list)}
   ]
   (
    English: (list: list) is empty according to default use as list
    Swift: var (self: [list]).isEmptyAccordingToDefaultUseAsList
   )
   truth value
   {
    ← (end of (list)) is (beginning of (list))
   }

  action (clients)
   [
    test {verify ((non‐empty example: list) is not empty according to default use as list)}
   ]
   (
    English: (list: list) is not empty according to default use as list
    Swift: var (self: [list]).isNotEmptyAccordingToDefaultUseAsList
   )
   truth value
   {
    ← not ((list) is empty)
   }
 }

thing (file)
 (
  English: minimal list example
 )
 {
  part (file)
   (
    English: wrapped list
   )
   list of (truth value)
 }

action (file)
 (
  English: minimal list example wrapping (wrapped list: list of (truth value))
 )
 minimal list example
 create

use (file)
 use of (minimal list example) as list of (truth value) indexed by (list index) separated by (list boundary)
 {
  action (file)
   (
    English: index after (boundary: list boundary) in (list: minimal list example) skipping bounds check
   )
   list index
   {
    ← index after (boundary) in ((wrapped list) of (list)) skipping bounds check
   }

  action (file)
   (
    English: beginning of (list: minimal list example)
   )
   list boundary
   {
    ← beginning of ((wrapped list) of (list))
   }

  action (file)
   (
    English: end of (list: minimal list example)
   )
   list boundary
   {
    ← end of ((wrapped list) of (list))
   }

  action (file)
   (
    English: advance (cursor: ↓ list boundary) to next in (list: minimal list example) skipping bounds check
   )
   {
    advance (↓ cursor) to next in ((wrapped list) of (list)) skipping bounds check
   }

  action (file)
   (
    English: entry at (index: list index) in (list: minimal list example)
   )
   truth value
   {
    ← entry at (index) in ((wrapped list) of (list))
   }

  action (file)
   (
    English: empty
   )
   minimal list example
   {
    ← minimal list example wrapping (empty: list of (truth value))
   }

  action (file)
   (
    English: non‐empty example
   )
   minimal list example
   {
    ← minimal list example wrapping (non‐empty example: list of (truth value))
   }
 }
