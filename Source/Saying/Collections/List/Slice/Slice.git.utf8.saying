extension
 slicing (list) as list of (element) indexed by (index) separated by (boundary)
 {
  thing (clients)
   (
    English: slice of (list)
   )
   Swift: “Slice<” list “>” [
     “==(¤(5F): ” boundary “, ¤(5F): ” boundary “)”
     “<(¤(5F): ” boundary “, ¤(5F): ” boundary “)”
     “” list “.startIndex”
     “” list “.endIndex”
     “” list “.subscript(¤(5F): ” boundary “)”
     “” list “.isEmpty”
     “” list “.index(after: ” boundary “)”
    ] {
     “extension ” list “: Collection {}”
     “extension ” boundary “: Comparable {}”
    }
   {
    part (clients/nowhere)
     (
      English: whole
     )
     list
     Swift: “” . “.base”

    part (clients/nowhere)
     [
      test {ignore ((bounds) of (non‐empty example: slice of (list of (truth value))))}
     ]
     (
      English: bounds
     )
     range of (boundary)
     Swift: “{let slice = ” . “; return slice.startIndex ..< slice.endIndex}()”
   }

  action (clients)
   (
    English: (bounds: range of (boundary)) in (whole: list)
   )
   slice of (list)
   Swift: “Slice(base: ” whole “, bounds: ” bounds “)”
   create

  action (clients)
   (
    English: entirety of (list: list)
   )
   slice of (list)
   {
    ← (from (beginning of (list)) to (end of (list))) in (list)
   }

  use (clients)
   general use of (slice of (list))
   {
   }

  use (clients)
   use of (slice of (list)) as list of (element) indexed by (index) separated by (boundary)
   {
    action (clients)
     (
      English: index after (boundary: boundary) in (list: slice of (list)) skipping bounds check
     )
     index
     {
      ← index after (boundary) in ((whole) of (list)) skipping bounds check
     }

    action (clients)
     (
      English: beginning of (list: slice of (list))
     )
     boundary
     Swift: “” list “.startIndex”
     {
      ← (lower bound) of ((bounds) of (list))
     }

    action (clients)
     (
      English: end of (list: slice of (list))
     )
     boundary
     Swift: “” list “.endIndex”
     {
      ← (upper bound) of ((bounds) of (list))
     }

    action (clients)
     (
      English: advance (cursor: ↓ boundary) to next in (list: slice of (list)) skipping bounds check
     )
     Swift: “” list “.formIndex(after: ¤(26)” cursor “)”
     {
      advance (↓ cursor) to next in ((whole) of (list)) skipping bounds check
     }

    action (clients)
     (
      English: boundary after (cursor: boundary) in (list: slice of (list)) skipping bounds check
     )
     boundary
     Swift: “” list “.index(after: ” cursor “)”
     {
      ← boundary after (cursor) in ((whole) of (list)) skipping bounds check
     }

    action (clients)
     (
      English: entry at (cursor: index) in (list: slice of (list))
     )
     element
     {
      ← entry at (cursor) in ((whole) of (list))
     }

    action (clients)
     (
      English: entry after (cursor: boundary) in (list: slice of (list)) skipping bounds check
     )
     element
     Swift: “” list “[” cursor “]”
     {
      ← entry after (cursor) in ((whole) of (list)) skipping bounds check
     }

    action (clients)
     (
      English: first in (list: slice of (list))
     )
     optional (element)
     Swift: “” list “.first”
     {
      ← first in (list) according to default use as list
     }

    action (clients)
     (
      English: (list: slice of (list)) is empty
     )
     truth value
     Swift: “” list “.isEmpty”
     {
      ← (list) is empty according to default use as list
     }

    action (clients)
     (
      English: empty
     )
     slice of (list)
     {
      ← entirety of (empty: list)
     }

    action (clients)
     (
      English: non‐empty example
     )
     slice of (list)
     {
      ← entirety of (non‐empty example: list)
     }
   }

  action (clients)
   [
    [
     English: Removes the first element from the slice by shrinking its window, without checking whether anything exists to remove.
    ]
    [
     English: It is generally advised to use the safer variant {remove first from ()} instead. For valid parameters, its effects are exactly the same.
    ]
    [
     English: Skipping the bounds check can be more efficient when a first element is already known from context to exist. However, the caller takes responsibility for assuring that the slice is not empty. Removing from an empty slice may cause a fatal error or overflow into invalid program state.
    ]
    test {
     let (• text: Unicode text) be (“...”)
     let (• slice: slice of (Unicode text)) start as (entirety of (text))
     while ((first in (slice)) is (“.”: Unicode scalar)), {
      remove first from (↓ slice) skipping bounds check
     }
     verify ((slice) is empty)
    }
   ]
   (
    English: remove first from (slice: ↓ slice of (list)) skipping bounds check
   )
   Swift: “” slice “.removeFirst()”
   {
    let (• new start: boundary) be (boundary after (beginning of (slice)) in (slice) skipping bounds check)
    change (↓ slice) to ((from (new start) to (end of (slice))) in ((whole) of (slice)))
   }

  action (clients)
   [
    [
     English: Removes the first element from the slice by shrinking its window.
    ]
    [
     English: The list behind the slice remains unaffected.
    ]
    test {
     let (• numbers: Unicode text) be (“123”)
     let (• slice: slice of (Unicode text)) start as (entirety of (numbers))
     remove first from (↓ slice)
     verify ((first in (slice)) is (“2”: Unicode scalar))
     remove first from (↓ slice)
     verify ((first in (slice)) is (“3”: Unicode scalar))
     remove first from (↓ slice)
     verify ((slice) is empty)
     verify ((numbers) is (“123”))
    }
    [
     English: This action safely does nothing if the slice is already empty.
    ]
    test {
     let (• slice: slice of (list)) start as (empty: slice of (list))
     remove first from (↓ slice)
    }
   ]
   (
    English: remove first from (slice: ↓ slice of (list))
    Swift: (self: [slice]).removeFirstUnlessEmpty
   )
   {
    if ((slice) is not empty), {
     remove first from (↓ slice) skipping bounds check
    }
   }
 }
