ability (clients)
 (
  English: use of (list) as list of (element) indexed by (index) separated by (boundary)
 )
 {
  requirement (clients)
   (
    English: unsafe index after (boundary: boundary)
   )
   index

  requirement (clients)
   (
    English: unsafe boundary before (index: index)
   )
   boundary

  requirement (clients)
   (
    English: beginning of (list: list)
    Deutsch: Anfang von (Liste: [list])
    français : début de (liste: [list])
    ελληνικά: αρχή (κατάλογος: [list])
    Swift: var (self: [list]).startIndex
   )
   boundary

  requirement (clients)
   [
    test {
     let (• non‐empty: list) be (non‐empty example: list)
     verify ((beginning of (non‐empty)) is not (end of (non‐empty)))
    }
   ]
   (
    English: end of (list: list)
    Deutsch: Ende von (Liste: [list])
    français : fin de (liste: [list])
    ελληνικά: τέλος (κατάλογος: [list])
    Swift: var (self: [list]).endIndex
   )
   boundary

  requirement (clients)
   [
    test {
     let (• non‐empty: list) be (non‐empty example: list)
     let (• beginning: boundary) be (beginning of (non‐empty))
     let (• cursor: boundary) start as (beginning)
     unsafely advance (↓ cursor) to next in (non‐empty)
     verify ((cursor) is not (beginning))
    }
   ]
   (
    English: unsafely advance (cursor: ↓ boundary) to next in (list: list)
    Swift: (self: [list]).formIndex after (i: [cursor])
   )

  choice (clients)
   [
    test {
     let (• non‐empty: list) be (non‐empty example: list)
     let (• beginning: boundary) be (beginning of (non‐empty))
     verify ((unsafe boundary after (beginning) in (non‐empty)) is not (beginning))
    }
   ]
   (
    English: unsafe boundary after (cursor: boundary) in (list: list)
    Deutsch : Index nach (Index: [cursor]) in (Liste: [list])
    français : indice après (indice: [cursor]) dans (liste: [list])
    ελληνικά: δείκτης μετά (δείκτης: [cursor]) σε (κατάλογος: [list])
    Swift: (self: [list]).index after (i: [cursor])
   )
   boundary
   {
    let (• copy: boundary) start as (cursor)
    unsafely advance (↓ copy) to next in (list)
    ← copy
   }

  requirement (clients)
   [
    test {
     let (• non‐empty: list) be (non‐empty example: list)
     ignore (unsafe entry after (beginning of (non‐empty)) in (non‐empty))
    }
   ]
   (
    English: unsafe entry after (cursor: boundary) in (list: list)
    Swift: (self: [list]).subscript (position: [cursor])
   )
   element

  choice (clients)
   [
    test {
     verify ((first in (non‐empty example: list)) exists)
    }
   ]
   (
    English: first in (list: list)
    Deutsch: erster in (Liste: [list])
    français : premier dans (liste: [list])
    ελληνικά: πρώτος σε (κατάλογος: [list])
    Swift: var (self: [list]).first
   )
   optional (element)
   Swift: “” list “.first” [
     “==(¤(5F): ” boundary “, ¤(5F): ” boundary “)”
     “<(¤(5F): ” boundary “, ¤(5F): ” boundary “)”
     “” list “.startIndex”
     “” list “.endIndex”
     “” list “.subscript(¤(5F): ” boundary “)”
     “” list “.isEmpty”
     “” list “.index(after: ” boundary “)”
    ] {
     “extension ” list “: Collection {}”
     “extension ” boundary “: Comparable {}”
    }
   {
    ← first in (list) according to default use as list
   }

  choice (clients)
   [
    test {
     verify (not ((non‐empty example: list) is empty))
    }
   ]
   (
    English: (list: list) is empty
    Deutsch: (Liste: [list]) ist leer
    français : (liste: [list]) est vide
    ελληνικά: (κατάλογος: [list]) είναι άδειος
    Swift: var (self: [list]).isEmpty
   )
   truth value
   Swift: “” list “.isEmpty” [
     “==(¤(5F): ” boundary “, ¤(5F): ” boundary “)”
     “<(¤(5F): ” boundary “, ¤(5F): ” boundary “)”
     “” list “.startIndex”
     “” list “.endIndex”
     “” list “.subscript(¤(5F): ” boundary “)”
     “” list “.index(after: ” boundary “)”
    ] {
     “extension ” list “: Collection {}”
     “extension ” boundary “: Comparable {}”
    }
   {
    ← (list) is empty according to default use as list
   }

  choice (clients)
   [
    test {
     verify ((non‐empty example: list) is not empty)
    }
   ]
   (
    English: (list: list) is not empty
    Deutsch: (Liste: [list]) ist nicht leer
    français : (liste: [list]) n’est pas vide
    ελληνικά: (κατάλογος: [list]) δεν είναι άδειος
   )
   truth value
   {
    ← (list) is not empty according to default use as list
   }

  requirement (clients)
   (
    English: non‐empty example
   )
   list
 }

extension
 use of (list) as list of (element) indexed by (index) separated by (boundary)
 {
  use (clients)
   general use of (list)
   {
   }

  action (clients)
   [
    test {
     verify ((first in (non‐empty example: list) according to default use as list) exists)
    }
   ]
   (
    English: first in (list: list) according to default use as list
   )
   optional (element)
   {
    if ((list) is empty), {
     ← nothing
    }
    ← wrap (unsafe entry after (beginning of (list)) in (list)) into optional
   }

  action (clients)
   [
    test {
     verify (not ((non‐empty example: list) is empty according to default use as list))
    }
   ]
   (
    English: (list: list) is empty according to default use as list
   )
   truth value
   {
    ← (end of (list)) is (beginning of (list))
   }

  action (clients)
   [
    test {
     verify ((non‐empty example: list) is not empty according to default use as list)
    }
   ]
   (
    English: (list: list) is not empty according to default use as list
   )
   truth value
   {
    ← not ((list) is empty)
   }
 }

thing (file)
 (
  English: minimal list example
 )
 {
  part (file)
   (
    English: wrapped list
   )
   list of (truth value)
 }

action (file)
 (
  English: minimal list example wrapping (wrapped list: list of (truth value))
 )
 minimal list example
 create

use
 use of (minimal list example) as list of (truth value) indexed by (list index) separated by (list boundary)
 {
  action (clients)
   (
    English: unsafe index after (boundary: list boundary)
   )
   list index
   C: “” boundary “”
   C♯: “” boundary “”
   JavaScript: “” boundary “”
   Kotlin: “” boundary “”
   Swift: “” boundary “”

  action (clients)
   (
    English: unsafe boundary before (index: list index)
   )
   list boundary
   C: “” index “”
   C♯: “” index “”
   JavaScript: “” index “”
   Kotlin: “” index “”
   Swift: “” index “”

  action (file)
   (
    English: beginning of (list: minimal list example)
   )
   list boundary
   {
    ← beginning of ((wrapped list) of (list))
   }

  action (file)
   (
    English: end of (list: minimal list example)
   )
   list boundary
   {
    ← end of ((wrapped list) of (list))
   }

  action (file)
   (
    English: unsafely advance (cursor: ↓ list boundary) to next in (list: minimal list example)
   )
   {
    unsafely advance (↓ cursor) to next in ((wrapped list) of (list))
   }

  action (file)
   (
    English: unsafe entry after (cursor: list boundary) in (list: minimal list example)
   )
   truth value
   {
    ← unsafe entry after (cursor) in ((wrapped list) of (list))
   }

  action (file)
   (
    English: non‐empty example
   )
   minimal list example
   {
    ← minimal list example wrapping (non‐empty example: list of (truth value))
   }
 }

action (file)
 [
  test {
   verify ((first in (empty minimal list example) according to default use as list) does not exist)
  }
 ]
 (
  English: empty minimal list example
 )
 minimal list example
 {
  ← minimal list example wrapping (empty: list of (truth value))
 }
