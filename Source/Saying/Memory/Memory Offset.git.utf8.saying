thing (clients)
 (
  English: memory offset
 )
 C: “size¤(5F)t” (“stddef”)
 C♯: “int”
 Kotlin: “Int”
 Swift: “Int”

action (file)
 [
  test {ignore (maximum representable: memory offset)}
 ]
 (
  English: maximum representable
 )
 memory offset
 C: “SIZE¤(5F)MAX” (“stdint”)
 C♯: “int.MaxValue” (“System”)
 JavaScript: “Number.MAX¤(5F)SAFE¤(5F)INTEGER”
 Kotlin: “Int.MAX¤(5F)VALUE”
 Swift: “Int.max”

action (unit)
 [
  test {ignore ((example: platform fixed‐width integer) as memory offset skipping overflow check)}
 ]
 (
  English: (integer: platform fixed‐width integer) as memory offset skipping overflow check
 )
 memory offset
 C: “(size¤(5F)t)” integer “”
 C♯: “” integer “”
 JavaScript: “” integer “”
 Kotlin: “” integer “”
 Swift: “” integer “”

use (unit)
 general use of (memory offset)
 {
 }

action (unit)
 (
  English: (first: memory offset) is (second: memory offset)
  English +: (first: [first]) = (second: [second])
  Deutsch: (erste: [first]) ist (zweite: [second])
  Deutsch +: (erste: [first]) = (zweite: [second])
  français : (première: [first]) est (deuxième: [second])
  français +: (première: [first]) = (deuxième: [second])
  ελληνικά: (πρώτη: [first]) είναι (δεύτερα: [second])
  ελληνικά +: (πρώτη: [first]) = (δεύτερα: [second])
  עברית: (ראשון: [first]) (שני: [second])
  עברית +: (ראשון: [first]) = (שני: [second])
  C♯: override (this: [first]).Equals (obj: [second])
  Kotlin: override (this: [first]).equals (other: [second])
  Swift: == (lhs: [first]) (rhs: [second])
 )
 truth value
 C: “” first “ == ” second “”
 C♯: “” first “ == ” second “”
 JavaScript: “” first “ == ” second “”
 Kotlin: “” first “ == ” second “”
 Swift: «» first “ == ” second „“

action (unit)
 (
  English: (first: memory offset) is not (second: memory offset)
  English +: (first: [first]) ≠ (second: [second])
  Deutsch: (erste: [first]) ist nicht (zweite: [second])
  Deutsch +: (erste: [first]) ≠ (zweite: [second])
  français : (première: [first]) n’est pas (deuxième: [second])
  français +: (première: [first]) ≠ (deuxième: [second])
  ελληνικά: (πρώτη: [first]) δεν είναι (δεύτερα: [second])
  ελληνικά +: (πρώτη: [first]) ≠ (δεύτερα: [second])
  עברית: (ראשון: [first]) לא (שני: [second])
  עברית +: (ראשון: [first]) ≠ (שני: [second])
 )
 truth value
 C: “” first “ != ” second “”
 C♯: “” first “ != ” second “”
 JavaScript: “” first “ != ” second “”
 Kotlin: “” first “ != ” second “”
 Swift: «» first “ != ” second „“

action (file)
 [
  test {ignore (direct hash value of (“0”: memory offset))}
 ]
 direct hash value of (offset: memory offset)
 hash value
 C: “(unsigned)” offset “”
 C♯: “” offset “”
 JavaScript: “” offset “”
 Kotlin: “” offset “”
 Swift: “” offset “”

action (unit)
 [
  test {verify ((“0”: memory offset) is less than (“1”: memory offset))}
 ]
 (
  English: (first: memory offset) is less than (second: memory offset)
  English +: (first: [first]) < (second: [second])
  Deutsch: (erste: [first]) ist kleiner als (zweite: [second])
  Deutsch +: (erste: [first]) < (zweite: [second])
  français : (première: [first]) est inférieur à (deuxième: [second])
  français +: (première: [first]) < (deuxième: [second])
  ελληνικά: (πρώτη: [first]) είναι μικρότερος από (δεύτερα: [second])
  ελληνικά +: (πρώτη: [first]) < (δεύτερα: [second])
  עברית: (ראשון: [first]) קטן מ(שני: [second])
  עברית +: (ראשון: [first]) < (שני: [second])
  Swift: < (lhs: [first]) (rhs: [second])
 )
 truth value
 C: “” first “ < ” second “”
 C♯: “” first “ < ” second “”
 JavaScript: “” first “ < ” second “”
 Kotlin: “” first “ < ” second “”
 Swift: «» first “ < ” second „“

action (unit)
 (
  English: (first: memory offset) is greater than (second: memory offset)
  English +: (first: [first]) > (second: [second])
  Deutsch: (erste: [first]) ist größer als (zweite: [second])
  Deutsch +: (erste: [first]) > (zweite: [second])
  français : (première: [first]) est supérieur à (deuxième: [second])
  français +: (première: [first]) > (deuxième: [second])
  ελληνικά: (πρώτη: [first]) είναι μεγαλύτερος από (δεύτερα: [second])
  ελληνικά +: (πρώτη: [first]) > (δεύτερα: [second])
  עברית: (ראשון: [first]) גדול מ(שני: [second])
  עברית +: (ראשון: [first]) > (שני: [second])
  Swift: > (lhs: [first]) (rhs: [second])
 )
 truth value
 C: “” first “ > ” second “”
 C♯: “” first “ > ” second “”
 JavaScript: “” first “ > ” second “”
 Kotlin: “” first “ > ” second “”
 Swift: «» first “ > ” second „“

action (unit)
 [
  test {verify ((“0”: memory offset) is less than or equal to (“1”: memory offset))}
 ]
 (
  English: (first: memory offset) is less than or equal to (second: memory offset)
  English +: (first: [first]) ≤ (second: [second])
  Deutsch: (erste: [first]) ist kleiner oder gleich (zweite: [second])
  Deutsch +: (erste: [first]) ≤ (zweite: [second])
  français : (première: [first]) est inférieur ou égal à (deuxième: [second])
  français +: (première: [first]) ≤ (deuxième: [second])
  ελληνικά: (πρώτη: [first]) είναι μικρότερος ή ίσος με (δεύτερα: [second])
  ελληνικά +: (πρώτη: [first]) ≤ (δεύτερα: [second])
  עברית: (ראשון: [first]) קטן או שווה ל(שני: [second])
  עברית +: (ראשון: [first]) ≤ (שני: [second])
  Swift: <= (lhs: [first]) (rhs: [second])
 )
 truth value
 C: “” first “ <= ” second “”
 C♯: “” first “ <= ” second “”
 JavaScript: “” first “ <= ” second “”
 Kotlin: “” first “ <= ” second “”
 Swift: «» first “ <= ” second „“

action (unit)
 [
  test {verify ((“0”: memory offset) is greater than or equal to (“0”: memory offset))}
 ]
 (
  English: (first: memory offset) is greater than or equal to (second: memory offset)
  English +: (first: [first]) ≥ (second: [second])
  Deutsch: (erste: [first]) ist größer oder gleich (zweite: [second])
  Deutsch +: (erste: [first]) ≥ (zweite: [second])
  français : (première: [first]) est supérieur ou égal à (deuxième: [second])
  français +: (première: [first]) ≥ (deuxième: [second])
  ελληνικά: (πρώτη: [first]) είναι μεγαλύτερος ή ίσος με (δεύτερα: [second])
  ελληνικά +: (πρώτη: [first]) ≥ (δεύτερα: [second])
  עברית: (ראשון: [first]) גדול או שווה ל(שני: [second])
  עברית +: (ראשון: [first]) ≥ (שני: [second])
  Swift: >= (lhs: [first]) (rhs: [second])
 )
 truth value
 C: “” first “ >= ” second “”
 C♯: “” first “ >= ” second “”
 JavaScript: “” first “ >= ” second “”
 Kotlin: “” first “ >= ” second “”
 Swift: «» first “ >= ” second „“

action (unit)
 [
  test {
   let (• offset: memory offset) start as (“0”: memory offset)
   increment (↓ offset) skipping overflow check
   verify ((offset) is (“1”: memory offset))
  }
 ]
 (
  English: increment (value: ↓ memory offset) skipping overflow check
 )
 C: “++” value “”
 C♯: “++” value “”
 JavaScript: “++” value “”
 Kotlin: “++” value “”
 Swift: “” value “ += 1”

action (unit)
 (
  English: (augend: memory offset) plus (addend: memory offset) skipping overflow check
 )
 memory offset
 C: “” augend “ + ” addend “”
 C♯: “” augend “ + ” addend “”
 JavaScript: “” augend “ + ” addend “”
 Kotlin: “” augend “ + ” addend “”
 Swift: “” augend “ ¤(26)+ ” addend “”

flow (file)
 [
  test {if (false), abort due to addition overflow}
 ]
 (
  English: if (condition: truth value), abort due to addition overflow
 )
 C: “if (” condition “)¤(A){¤(A)err(EXIT¤(5F)FAILURE, ¤(22)[...] + [...] > SIZE¤(5F)MAX¤(22));¤(A)}” (
   “err”
   “stdlib”
  )
 JavaScript: “if (” condition “) {¤(A)throw new Error(¤(22)[...] + [...] > Number.MAX¤(5F)SAFE¤(5F)INTEGER¤(22));¤(A)}”
 {
  if (condition), {
   !
  }
 }

action (unit)
 (
  English: (augend: memory offset) plus (addend: memory offset) skipping negative overflow checks, but aborting on positive overflow
 )
 memory offset
 C♯: “checked(” augend “ + ” addend “)”
 Kotlin: “Math.addExact(” augend “, ” addend “)” (“java.lang.Math”)
 Swift: “” augend “ + ” addend “”
 {
  if ((augend) is greater than ((maximum representable: memory offset) minus (addend) skipping overflow check)), abort due to addition overflow
  ← (augend) plus (addend) skipping overflow check
 }

action (unit)
 (
  English: (minuend: memory offset) minus (subtrahend: memory offset) skipping overflow check
 )
 memory offset
 C: “” minuend “ ¤(2D) ” subtrahend “”
 C♯: “” minuend “ ¤(2D) ” subtrahend “”
 JavaScript: “” minuend “ ¤(2D) ” subtrahend “”
 Kotlin: “” minuend “ ¤(2D) ” subtrahend “”
 Swift: “” minuend “ ¤(26)¤(2D) ” subtrahend “”

action (unit)
 (first: memory offset) times (second: memory offset) skipping overflow check
 memory offset
 C: “” first “ ¤(2A) ” second “”
 C♯: “” first “ ¤(2A) ” second “”
 JavaScript: “” first “ ¤(2A) ” second “”
 Kotlin: “” first “ ¤(2A) ” second “”
 Swift: «» first “ ¤(26)¤(2A) ” second „“

flow (file)
 [
  test {if (false), abort due to multiplication overflow}
 ]
 (
  English: if (condition: truth value), abort due to multiplication overflow
 )
 C: “if (” condition “)¤(A){¤(A)err(EXIT¤(5F)FAILURE, ¤(22)[...] ¤(2A) [...] > SIZE¤(5F)MAX¤(22));¤(A)}” (
   “err”
   “stdlib”
  )
 JavaScript: “if (” condition “) {¤(A)throw new Error(¤(22)[...] ¤(2A) [...] > Number.MAX¤(5F)SAFE¤(5F)INTEGER¤(22));¤(A)}”
 {
  if (condition), {
   !
  }
 }

action (unit)
 (first: memory offset) times (second: memory offset) skipping negative overflow checks, but aborting on positive overflow
 memory offset
 C♯: “checked(” first “ ¤(2A) ” second “)”
 Kotlin: “Math.multiplyExact(” first “, ” second “)” (“java.lang.Math”)
 Swift: «» first “ ¤(2A) ” second „“
 {
  if ((first) is greater than (“0”: memory offset)), {
   if (((maximum representable: memory offset) divided by (first) skipping zero and overflow checks) is less than (second)), abort due to multiplication overflow
  }
  ← (first) times (second) skipping overflow check
 }

action (unit)
 (
  English: (dividend: memory offset) divided by (divisor: memory offset) skipping zero and overflow checks
 )
 memory offset
 C: “” dividend “ / ” divisor “”
 C♯: “” dividend “ / ” divisor “”
 JavaScript: “Math.floor(” dividend “ / ” divisor “)”
 Kotlin: “” dividend “ / ” divisor “”
 Swift: “” dividend “ / ” divisor “”

extension
 general use of (thing)
 {
  action (unit)
   (
    English: size of (example: thing)
   )
   memory offset
   C: “sizeof(” thing “)”
   Swift: “MemoryLayout<” thing “>.stride”
   {
    ← “1”
   }
 }
