thing (clients)
 (
  English: memory offset
 )
 C: “size¤(5F)t” (“stddef”)
 C♯: “int”
 Kotlin: “Int”
 Swift: “Int”

action (unit)
 [
  test {ignore ((example: platform fixed‐width integer) as memory offset skipping overflow check)}
 ]
 (
  English: (integer: platform fixed‐width integer) as memory offset skipping overflow check
 )
 memory offset
 C: “(size¤(5F)t)” integer “”
 C♯: “” integer “”
 JavaScript: “” integer “”
 Kotlin: “” integer “”
 Swift: “” integer “”

use (unit)
 general containers of (memory offset)
 {
  action (unit)
   example
   memory offset
   C: “0”
   C♯: “0”
   JavaScript: “0”
   Kotlin: “0”
   Swift: “0”
 }

action (file)
 [
  test {ignore (direct hash value of (example: memory offset))}
 ]
 direct hash value of (offset: memory offset)
 hash value
 C: “(unsigned)” offset “”
 C♯: “” offset “”
 JavaScript: “” offset “”
 Kotlin: “” offset “”
 Swift: “” offset “”

use (unit)
 comparison of (memory offset) for equality
 {
  action (unit)
   (first: memory offset) is (second: memory offset)
   truth value
   C: “” first “ == ” second “”
   C♯: “” first “ == ” second “”
   JavaScript: “” first “ == ” second “”
   Kotlin: “” first “ == ” second “”
   Swift: «» first “ == ” second „“

  action (unit)
   (first: memory offset) is not (second: memory offset)
   truth value
   C: “” first “ != ” second “”
   C♯: “” first “ != ” second “”
   JavaScript: “” first “ != ” second “”
   Kotlin: “” first “ != ” second “”
   Swift: «» first “ != ” second „“

  action (unit)
   hash key (key: memory offset) with (hasher: ↓ hasher)
   Swift: “” key “.hash(into: ¤(26)” hasher “)”
   {
    feed (direct hash value of (key)) into (↓ hasher)
   }

  action (unit)
   (
    English: hash value of (key: memory offset)
   )
   hash value
   C♯: “” key “.GetHashCode()”
   Kotlin: “” key “.hashCode()”
   {
    ← hash value of (key) according to comparison for equality
   }

  action (unit)
   differing example
   memory offset
   {
    ← greater example
   }
 }

use (unit)
 comparison of (memory offset) for order
 {
  action (unit)
   (first: memory offset) is less than (second: memory offset)
   truth value
   C: “” first “ < ” second “”
   C♯: “” first “ < ” second “”
   JavaScript: “” first “ < ” second “”
   Kotlin: “” first “ < ” second “”
   Swift: «» first “ < ” second „“

  action (unit)
   (first: memory offset) is greater than (second: memory offset)
   truth value
   C: “” first “ > ” second “”
   C♯: “” first “ > ” second “”
   JavaScript: “” first “ > ” second “”
   Kotlin: “” first “ > ” second “”
   Swift: «» first “ > ” second „“

  action (unit)
   (first: memory offset) is less than or equal to (second: memory offset)
   truth value
   C: “” first “ <= ” second “”
   C♯: “” first “ <= ” second “”
   JavaScript: “” first “ <= ” second “”
   Kotlin: “” first “ <= ” second “”
   Swift: «» first “ <= ” second „“

  action (unit)
   (first: memory offset) is greater than or equal to (second: memory offset)
   truth value
   C: “” first “ >= ” second “”
   C♯: “” first “ >= ” second “”
   JavaScript: “” first “ >= ” second “”
   Kotlin: “” first “ >= ” second “”
   Swift: «» first “ >= ” second „“

  action (unit)
   greater example
   memory offset
   C: “1”
   C♯: “1”
   JavaScript: “1”
   Kotlin: “1”
   Swift: “1”
 }

use (unit)
 additive arithmetic with (memory offset)
 {
  action (unit)
   (
    English: zero
   )
   memory offset
   C: “0”
   C♯: “0”
   JavaScript: “0”
   Kotlin: “0”
   Swift: “0”

  action (unit)
   (
    English: one
   )
   memory offset
   C: “1”
   C♯: “1”
   JavaScript: “1”
   Kotlin: “1”
   Swift: “1”
 }

use (unit)
 incrementation of (memory offset)
 {
  action (unit)
   (
    English: increment (value: ↓ memory offset)
   )
   C: “++” value “”
   C♯: “++” value “”
   JavaScript: “++” value “”
   Kotlin: “++” value “”
   Swift: “” value “ += 1”

  action (unit)
   (
    English: decrement (value: ↓ memory offset) skipping underflow check
   )
   C: “¤(2D)¤(2D)” value “”
   C♯: “¤(2D)¤(2D)” value “”
   JavaScript: “¤(2D)¤(2D)” value “”
   Kotlin: “¤(2D)¤(2D)” value “”
   Swift: “” value “ ¤(2D)= 1”

  action (unit)
   (
    English: can decrement (value: memory offset)
   )
   truth value
   {
    ← true
   }

  action (unit)
   (
    English: successor example
   )
   memory offset
   {
    ← one
   }
 }

action (unit)
 (
  English: (augend: memory offset) plus (addend: memory offset)
  English +: (augend: [augend]) + (addend: [addend])
  español: (primer sumando: [augend]) más (segundo sumando: [addend])
  español +: (primer sumando: [augend]) + (segundo sumando: [addend])
  português: (primeiro sumado: [augend]) mais (segundo sumado: [addend])
  português +: (primeiro sumado: [augend]) + (segundo sumado: [addend])
  français : (cumulande: [augend]) plus (cumulateur: [addend])
  français + : (cumulande: [augend]) + (cumulateur: [addend])
  Deutsch: (erster Summand: [augend]) plus (zweiter Summand: [addend])
  Deutsch: (erster Summand: [augend]) + (zweiter Summand: [addend])
  italiano: (auguendo: [augend]) più (addendo: [addend])
  italiano +: (auguendo: [augend]) + (addendo: [addend])
  Nederlands: (eerste term: [augend]) plus (tweede term: [addend])
  Nederlands +: (eerste term: [augend]) + (tweede term: [addend])
  ελληνικά: (προσθέτης: [augend]) συν (προσθετέος: [addend])
  ελληνικά +: (προσθέτης: [augend]) + (προσθετέος: [addend])
  עברית: (מחובר ראשון: [augend]) ועוד (מחובר שני: [addend])
  עברית +: (מחובר ראשון: [augend]) + (מחובר שני: [addend])
 )
 memory offset
 C: “” augend “ + ” addend “”
 C♯: “” augend “ + ” addend “”
 JavaScript: “” augend “ + ” addend “”
 Kotlin: “” augend “ + ” addend “”
 Swift: “” augend “ + ” addend “”

action (unit)
 (
  English: (minuend: memory offset) minus (subtrahend: memory offset)
 )
 memory offset
 C: “” minuend “ ¤(2D) ” subtrahend “”
 C♯: “” minuend “ ¤(2D) ” subtrahend “”
 JavaScript: “” minuend “ ¤(2D) ” subtrahend “”
 Kotlin: “” minuend “ ¤(2D) ” subtrahend “”
 Swift: “” minuend “ ¤(2D) ” subtrahend “”

action (unit)
 (first: memory offset) times (second: memory offset)
 memory offset
 C: “” first “ ¤(2A) ” second “”
 C♯: “” first “ ¤(2A) ” second “”
 JavaScript: “” first “ ¤(2A) ” second “”
 Kotlin: “” first “ ¤(2A) ” second “”
 Swift: «» first “ ¤(2A) ” second „“

action (unit)
 (
  English: (dividend: memory offset) divided by (divisor: memory offset)
 )
 memory offset
 C: “” dividend “ / ” divisor “”
 C♯: “” dividend “ / ” divisor “”
 JavaScript: “Math.floor(” dividend “ / ” divisor “)”
 Kotlin: “” dividend “ / ” divisor “”
 Swift: “” dividend “ / ” divisor “”

extension
 general use of (thing)
 {
  action (unit)
   (
    English: size of (example: thing)
   )
   memory offset
   C: “sizeof(” thing “)”
   {
    ← zero
   }
 }

action (unit)
 (
  English: two
 )
 memory offset
 C: “2”
 C♯: “2”
 JavaScript: “2”
 Kotlin: “2”
 Swift: “2”

action (unit)
 (
  English: three
 )
 memory offset
 C: “3”
 C♯: “3”
 JavaScript: “3”
 Kotlin: “3”
 Swift: “3”

action (unit)
 (
  English: six
 )
 memory offset
 C: “6”
 C♯: “6”
 JavaScript: “6”
 Kotlin: “6”
 Swift: “6”
