ability (clients)
 (
  English: incrementation of (value)
 )
 {
  requirement (clients)
   [
    test {
     let (• value: value) start as (example: value)
     increment (↓ value)
     verify ((value) is (successor example: value))
    }
   ]
   (
    English: increment (value: ↓ value)
   )

  choice (clients)
   [
    test {
     verify ((successor to (example: value)) is (successor example: value))
    }
   ]
   (
    English: successor to (value: value)
   )
   value
   {
    let (• copy: value) start as (value)
    increment (↓ copy)
    ← copy
   }

  requirement (clients)
   [
    [
     English: Decrements the value without checking whether a valid predecessor exists.
    ]
    [
     English: This action is simpler to implement as an ability requirement, but callers are generally advised to use its safer variant {decrement ()} instead.
    ]
    [
     English: Skipping the underflow check can also be more efficient when the value is already known from context to have a valid predecessor. However, the caller takes responsibility for the logical soundness of the call.
    ]
    test {
     let (• value: value) start as (successor example: value)
     decrement (↓ value) skipping underflow check
     verify ((value) is (example: value))
    }
   ]
   (
    English: decrement (value: ↓ value) skipping underflow check
   )

  choice (clients)
   [
    [
     English: Returns the value’s predecessor without checking whether said precedessor is valid.
    ]
    [
     English: This action is simpler to implement as an ability requirement, but callers are generally advised to use its safer variant {decrement ()} instead.
    ]
    [
     English: Skipping the underflow check can also be more efficient when the value is already known from context to have a valid predecessor. However, the caller takes responsibility for the logical soundness of the call.
    ]
    test {
     verify ((predecessor to (successor example: value) skipping underflow check) is (example: value))
    }
   ]
   (
    English: predecessor to (value: value) skipping underflow check
   )
   value
   {
    let (• copy: value) start as (value)
    decrement (↓ copy) skipping underflow check
    ← copy
   }

  requirement (clients)
   [
    [
     English: Returns a truth value indicating whether the value has a valid predecessor.
    ]
   ]
   (
    English: can decrement (value: value)
   )
   truth value

  requirement (clients)
   [
    [
     English: A separate example instance which is one greater than the main example.
    ]
   ]
   (
    English: successor example
   )
   value
 }

extension
 incrementation of (value)
 {
  action (clients)
   [
    [
     English: Decrements the value if it has a valid predecessor and then returns whether or not the decrementation succeeded.
    ]
    test {
     let (• value: value) start as (successor example: value)
     verify (decrement (↓ value))
    }
   ]
   (
    English: decrement (value: ↓ value)
   )
   truth value
   {
    if (can decrement (value)), {
     decrement (↓ value) skipping underflow check
     ← true
    }
    ← false
   }

  action (clients)
   [
    test {
     verify ((predecessor to (successor example: value)) exists)
     verify ((predecessor to (zero: natural number)) does not exist)
    }
   ]
   (
    English: predecessor to (value: value)
   )
   optional (value)
   {
    let (• copy: value) start as (value)
    if (decrement (↓ copy)), {
     ← wrap (copy) into optional
    }
    ← nothing
   }
 }
