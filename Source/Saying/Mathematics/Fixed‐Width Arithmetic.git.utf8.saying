ability (clients)
 (
  English: fixed‐width arithmetic with (number)
 )
 {
  requirement (clients)
   [
    test {ignore (maximum representable: number)}
   ]
   (
    English: maximum representable
   )
   number

  requirement (clients)
   [
    test {ignore (minimum representable: number)}
   ]
   (
    English: minimum representable
   )
   number

  requirement (clients)
   [
    [
     English: Adds to the cumulative sum without checking whether the result is representable.
    ]
    [
     English: This action is simpler to implement as an ability requirement, but callers are generally advised to use its safer variant {add () to ()} instead.
    ]
    [
     English: Skipping the overflow check can also be more efficient when the resulting sum is already known from context to be representable. However, the caller takes responsibility for the logical soundness of the call.
    ]
    test {
     let (• cumulative sum: number) start as (example augend: number)
     add (example addend: number) to (↓ cumulative sum) skipping overflow check
     verify ((cumulative sum) is (example sum: number))
    }
   ]
   (
    English: add (addend: number) to (cumulative sum: ↓ number) skipping overflow check
   )

  choice (clients)
   [
    [
     English: Returns the sum of two values without checking whether the sum is representable.
    ]
    [
     English: This action is simpler to implement as an ability requirement, but callers are generally advised to use its safer variant {() plus ()} instead.
    ]
    [
     English: Skipping the overflow check can also be more efficient when the sum is already known from context to be representable. However, the caller takes responsibility for the logical soundness of the call.
    ]
    test {verify (((example augend: number) plus (example addend: number), skipping overflow check) = (example sum: number))}
   ]
   (
    English: (augend: number) plus (addend: number), skipping overflow check
   )
   number
   {
    let (• sum: number) start as (augend)
    add (addend) to (↓ sum) skipping overflow check
    ← sum
   }

  requirement (clients)
   [
    [
     English: Returns a truth value indicating whether the sum will be representable.
    ]
   ]
   (
    English: can add (addend: number) to (augend: number)
   )
   truth value

  requirement (clients)
   [
    [
     English: Subracts from the value without checking whether the result is representable.
    ]
    [
     English: This action is simpler to implement as an ability requirement, but callers are generally advised to use its safer variant {subtract () from ()} instead.
    ]
    [
     English: Skipping the overflow check can also be more efficient when the resulting difference is already known from context to be representable. However, the caller takes responsibility for the logical soundness of the call.
    ]
    test {
     let (• value: number) start as (example sum: number)
     subtract (example addend: number) from (↓ value) skipping overflow check
     verify ((value) is (example augend: number))
    }
   ]
   (
    English: subtract (subtrahend: number) from (value: ↓ number) skipping overflow check
   )

  choice (clients)
   [
    [
     English: Returns the difference of the minuend minus the subrahend without checking whether the difference is representable.
    ]
    [
     English: This action is simpler to implement as an ability requirement, but callers are generally advised to use its safer variant {() minus ()} instead.
    ]
    [
     English: Skipping the overflow check can also be more efficient when the difference is already known from context to be representable. However, the caller takes responsibility for the logical soundness of the call.
    ]
    test {verify (((example sum: number) minus (example addend: number), skipping overflow check) = (example augend: number))}
   ]
   (
    English: (minuend: number) minus (subtrahend: number), skipping overflow check
   )
   number
   {
    let (• value: number) start as (minuend)
    subtract (subtrahend) from (↓ value) skipping overflow check
    ← value
   }

  requirement (clients)
   [
    [
     English: Returns a truth value indicating whether the difference will be representable.
    ]
   ]
   (
    English: can subtract (subtrahend: number) from (minuend: number)
   )
   truth value

  requirement (clients)
   (
    English: example augend
   )
   number

  requirement (clients)
   (
    English: example addend
   )
   number

  requirement (clients)
   (
    English: example sum
   )
   number
 }

extension
 fixed‐width arithmetic with (number)
 {
  action (clients)
   [
    [
     English: Adds the value to the cumulative sum if possible and then returns whether or not the addition succeeded.
    ]
    test {
     let (• cumulative sum: number) start as (example augend: number)
     verify (add (example addend: number) to (↓ cumulative sum))
     verify ((cumulative sum) is (example sum: number))
    }
    test {
     let (• cumulative sum: number) start as (maximum representable: number)
     verify (not (add (one: number) to (↓ cumulative sum)))
     verify ((cumulative sum) is (maximum representable: number))
    }
   ]
   (
    English: add (addend: number) to (cumulative sum: ↓ number)
   )
   truth value
   {
    if (can add (addend) to (cumulative sum)), {
     add (addend) to (↓ cumulative sum) skipping overflow check
     ← true
    }
    ← false
   }

  action (clients)
   [
    test {
     if ((example augend: number) + (example addend: number)) exists, unwrap it as (• sum: number), {
      verify ((sum) = (example sum: number))
     }
    }
    test {
     verify (((maximum representable: number) + (one: number)) does not exist)
    }
   ]
   (
    English: (augend: number) plus (addend: number)
    English +: (augend: [augend]) + (addend: [addend])
    español: (primer sumando: [augend]) más (segundo sumando: [addend])
    español +: (primer sumando: [augend]) + (segundo sumando: [addend])
    português: (primeiro sumado: [augend]) mais (segundo sumado: [addend])
    português +: (primeiro sumado: [augend]) + (segundo sumado: [addend])
    français : (cumulande: [augend]) plus (cumulateur: [addend])
    français + : (cumulande: [augend]) + (cumulateur: [addend])
    Deutsch: (erster Summand: [augend]) plus (zweiter Summand: [addend])
    Deutsch: (erster Summand: [augend]) + (zweiter Summand: [addend])
    italiano: (auguendo: [augend]) più (addendo: [addend])
    italiano +: (auguendo: [augend]) + (addendo: [addend])
    Nederlands: (eerste term: [augend]) plus (tweede term: [addend])
    Nederlands +: (eerste term: [augend]) + (tweede term: [addend])
    ελληνικά: (προσθέτης: [augend]) συν (προσθετέος: [addend])
    ελληνικά +: (προσθέτης: [augend]) + (προσθετέος: [addend])
    עברית: (מחובר ראשון: [augend]) ועוד (מחובר שני: [addend])
    עברית +: (מחובר ראשון: [augend]) + (מחובר שני: [addend])
   )
   optional (number)
   {
    let (• sum: number) start as (augend)
    if (add (addend) to (↓ sum)), {
     ← wrap (sum) into optional
    }
    ← nothing
   }

  action (clients)
   [
    [
     English: Subracts the subtrahend from the value if possible and then returns whether or not the subtraction succeeded.
    ]
    test {
     let (• value: number) start as (example sum: number)
     verify (subtract (example addend: number) from (↓ value))
     verify ((value) is (example augend: number))
    }
    test {
     let (• value: number) start as (minimum representable: number)
     verify (not (subtract (one: number) from (↓ value)))
     verify ((value) is (minimum representable: number))
    }
   ]
   (
    English: subtract (subtrahend: number) from (value: ↓ number)
   )
   truth value
   {
    if (can subtract (subtrahend) from (value)), {
     subtract (subtrahend) from (↓ value) skipping overflow check
     ← true
    }
    ← false
   }

  action (clients)
   [
    test {
     if ((example sum: number) − (example addend: number)) exists, unwrap it as (• difference: number), {
      verify ((difference) = (example augend: number))
     }
    }
    test {
     verify (((minimum representable: number) − (one: number)) does not exist)
    }
   ]
   (
    English: (minuend: number) minus (subtrahend: number)
    English +: (minuend: [minuend]) − (subtrahend: [subtrahend])
    español: (minuendo: [minuend]) menos (sustraendo: [subtrahend])
    español +: (minuendo: [minuend]) − (sustraendo: [subtrahend])
    português: (minuendo: [minuend]) menos (subtraendo: [subtrahend])
    português +: (minuendo: [minuend]) − (subtraendo: [subtrahend])
    français : (diminuende: [minuend]) moins (diminuteur: [subtrahend])
    français + : (diminuende: [minuend]) − (diminuteur: [subtrahend])
    Deutsch: (Minuend: [minuend]) minus (Subtrahend: [subtrahend])
    Deutsch: (Minuend: [minuend]) − (Subtrahend: [subtrahend])
    italiano: (minuendo: [minuend]) meno (sottraendo: [subtrahend])
    italiano +: (minuendo: [minuend]) − (sottraendo: [subtrahend])
    Nederlands: (aftrekgetal: [minuend]) min (aftrekker: [subtrahend])
    Nederlands +: (aftrekgetal: [minuend]) − (aftrekker: [subtrahend])
    ελληνικά: (μειωτέος: [minuend]) μείον (αφαιρετέος: [subtrahend])
    ελληνικά +: (μειωτέος: [minuend]) − (αφαιρετέος: [subtrahend])
    עברית: (מחוסר: [minuend]) פחות (מחסר: [subtrahend])
    עברית +: (מחוסר: [minuend]) − (מחסר: [subtrahend])
   )
   number
   {
    let (• value: number) start as (minuend)
    subtract (subtrahend) from (↓ value)
    ← value
   }
 }

thing (file)
 (
  English: minimal fixed‐width arithmetic example
 )
 {
  part (file)
   (
    English: number
   )
   platform fixed‐width natural number
 }

action (file)
 (
  English: minimal fixed‐width arithmetic example wrapping (number: platform fixed‐width natural number)
 )
 minimal fixed‐width arithmetic example
 create

use (file)
 general containers of (minimal fixed‐width arithmetic example)
 {
  action (file)
   example
   minimal fixed‐width arithmetic example
   {
    ← example augend
   }
 }

use (file)
 comparison of (minimal fixed‐width arithmetic example) for equality
 {
  action (file)
   (first: minimal fixed‐width arithmetic example) is (second: minimal fixed‐width arithmetic example)
   truth value
   {
    ← ((number) of (first)) is ((number) of (second))
   }

  action (file)
   hash key (key: minimal fixed‐width arithmetic example) with (hasher: ↓ hasher)
   {
    hash part ((number) of (key)) with (↓ hasher)
   }

  action (file)
   differing example
   minimal fixed‐width arithmetic example
   {
    ← example sum
   }
 }

use (file)
 fixed‐width arithmetic with (minimal fixed‐width arithmetic example)
 {
  action (file)
   (
    English: maximum representable
   )
   minimal fixed‐width arithmetic example
   {
    ← minimal fixed‐width arithmetic example wrapping (maximum representable: platform fixed‐width natural number)
   }

  action (file)
   (
    English: minimum representable
   )
   minimal fixed‐width arithmetic example
   {
    ← minimal fixed‐width arithmetic example wrapping (minimum representable: platform fixed‐width natural number)
   }

  action (file)
   (
    English: add (addend: minimal fixed‐width arithmetic example) to (cumulative sum: ↓ minimal fixed‐width arithmetic example) skipping overflow check
   )
   {
    add ((number) of (addend)) to (↓ (number) of (cumulative sum)) skipping overflow check
   }

  action (file)
   (
    English: can add (addend: minimal fixed‐width arithmetic example) to (augend: minimal fixed‐width arithmetic example)
   )
   truth value
   {
    ← can add ((number) of (addend)) to ((number) of (augend))
   }

  action (file)
   (
    English: subtract (subtrahend: minimal fixed‐width arithmetic example) from (value: ↓ minimal fixed‐width arithmetic example) skipping overflow check
   )
   {
    subtract ((number) of (subrahend)) from (↓ (number) of (value)) skipping overflow check
}

  action (file)
   (
    English: can subtract (subtrahend: minimal fixed‐width arithmetic example) from (minuend: minimal fixed‐width arithmetic example)
   )
   truth value
   {
    ← can subtract ((number) of (subrahend)) from ((number) of (minuend))
   }

  action (file)
   (
    English: example augend
   )
   minimal fixed‐width arithmetic example
   {
    ← minimal fixed‐width arithmetic example wrapping (example augend: platform fixed‐width natural number)
   }

  action (file)
   (
    English: example addend
   )
   minimal fixed‐width arithmetic example
   {
    ← minimal fixed‐width arithmetic example wrapping (example addend: platform fixed‐width natural number)
   }

  action (file)
   (
    English: example sum
   )
   minimal fixed‐width arithmetic example
   {
    ← minimal fixed‐width arithmetic example wrapping (example sum: platform fixed‐width natural number)
   }
 }

use (file)
 natural arithmetic with (minimal fixed‐width arithmetic example)
 {
  action (file)
   (
    English: zero
   )
   minimal fixed‐width arithmetic example
   {
    ← minimal fixed‐width arithmetic example wrapping (zero: platform fixed‐width natural number)
   }

  action (file)
   (
    English: one
   )
   minimal fixed‐width arithmetic example
   {
    ← minimal fixed‐width arithmetic example wrapping (one: platform fixed‐width natural number)
   }
 }
