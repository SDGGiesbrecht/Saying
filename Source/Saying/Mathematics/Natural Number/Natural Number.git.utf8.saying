thing (clients)
 [
  [
   English: A natural number; 0, 1, 2, 3 or any number that follows in that sequence.
  ]
  [
   English: {natural number} and {integer} are the generally recommended representations to use for numbers. They most closely match the mathematical concepts, prioritizing reliability over efficiency. They are expected to be used as though they could hypothetically hold any relevant number with exact precision, regardless of size.
  ]
  [
   English: In practice, storage of a number is still bound by the physical limits of the device. If the platform runs out of resources, code execution will fail in some manner.
  ]
  [
   English: Where speed or memory size becomes a concern, fixed‐width numbers can be used instead, provided values are known to remain within their representable range.
  ]
 ]
 (
  español: número natural
  English: natural number
  العربية: عدد طبيعي
  हिन्दी: प्राकृतिक संख्या
  português: número natural
  русский: натуральное число
  Deutsch: natürliche Zahl
  tiếng Việt: số tự nhiên
  한국어: 자연수
  français : entier naturel
  Türkçe: doğal sayı
  italiano: numero naturale
  polski: liczba naturalna
  українська: натуральне число
  Nederlands: natuurlijk getal
  română: număr natural
  ελληνικά: φυσικός αριθμός
  čeština: přirozené číslo
  magyar: természetes szám
  svenska: naturligt tal
  Afrikaans: natuurlike getal
  dansk: naturligt tal
  suomi: luonnollinen luku
  slovenčina: prirodzené číslo
  עברית: מספר טבעי
  norsk: naturlig tall
  català: nombre natural
  Gaeilge: uimhir aiceanta
 )
 C: “uintmax¤(5F)t” (“stdint”)
 C♯: “ulong”
 Kotlin: “ULong”
 Swift: “UInt64”

use (clients)
 general containers of (natural number)
 {
  action (clients)
   example
   natural number
   {
    ← zero
   }
 }

use (clients)
 comparison of (natural number) for equality
 {
  action (clients)
   (first: natural number) is (second: natural number)
   truth value
   C: “” first “ == ” second “”
   C♯: “” first “ == ” second “”
   JavaScript: “” first “ == ” second “”
   Kotlin: “” first “ == ” second “”
   Swift: «» first “ == ” second „“

  action (clients)
   (first: natural number) is not (second: natural number)
   truth value
   C: “” first “ != ” second “”
   C♯: “” first “ != ” second “”
   JavaScript: “” first “ != ” second “”
   Kotlin: “” first “ != ” second “”
   Swift: «» first “ != ” second „“

  action (clients)
   hash key (key: natural number) with (hasher: ↓ hasher)
   Swift: “” key “.hash(into: ¤(26)” hasher “)”
   {
    hash part (hashing proxy of (key)) with (↓ hasher)
   }

  action (unit)
   (
    English: hash value of (key: natural number)
   )
   hash value
   C♯: “” key “.GetHashCode()”
   Kotlin: “” key “.hashCode()”
   {
    ← hash value of (key) according to comparison for equality
   }

  action (clients)
   differing example
   natural number
   {
    ← greater example
   }
 }

action (file)
 [
  test {ignore (hashing proxy of (zero: natural number))}
 ]
 hashing proxy of (number: natural number)
 platform fixed‐width integer
 C: “(unsigned)” number “”
 C♯: “” number “.GetHashCode()”
 JavaScript: “” number “”
 Kotlin: “” number “.hashCode()”
 Swift: “Int(truncatingIfNeeded: ” number “)”

use (clients)
 comparison of (natural number) for order
 {
  action (clients)
   (first: natural number) is less than (second: natural number)
   truth value
   C: “” first “ < ” second “”
   C♯: “” first “ < ” second “”
   JavaScript: “” first “ < ” second “”
   Kotlin: “” first “ < ” second “”
   Swift: «» first “ < ” second „“

  action (clients)
   (first: natural number) is greater than (second: natural number)
   truth value
   C: “” first “ > ” second “”
   C♯: “” first “ > ” second “”
   JavaScript: “” first “ > ” second “”
   Kotlin: “” first “ > ” second “”
   Swift: «» first “ > ” second „“

  action (clients)
   (first: natural number) is less than or equal to (second: natural number)
   truth value
   C: “” first “ <= ” second “”
   C♯: “” first “ <= ” second “”
   JavaScript: “” first “ <= ” second “”
   Kotlin: “” first “ <= ” second “”
   Swift: «» first “ <= ” second „“

  action (clients)
   (first: natural number) is greater than or equal to (second: natural number)
   truth value
   C: “” first “ >= ” second “”
   C♯: “” first “ >= ” second “”
   JavaScript: “” first “ >= ” second “”
   Kotlin: “” first “ >= ” second “”
   Swift: «» first “ >= ” second „“

  action (clients)
   greater example
   natural number
   {
    ← one
   }
 }

use (clients)
 addition of (natural number)
 {
  action (clients)
   (
    English: add (addend: natural number) to (cumulative sum: ↓ natural number)
   )
   C: “” cumulative sum “ += ” addend “”
   C♯: “” cumulative sum “ += ” addend “”
   JavaScript: “” cumulative sum “ += ” addend “”
   Kotlin: “” cumulative sum “ += ” addend “”
   Swift: “” cumulative sum “ += ” addend “”

  action (clients)
   (
    English: (augend: natural number) plus (addend: natural number)
   )
   natural number
   C: “” augend “ + ” addend “”
   C♯: “” augend “ + ” addend “”
   JavaScript: “” augend “ + ” addend “”
   Kotlin: “” augend “ + ” addend “”
   Swift: “” augend “ + ” addend “”

  action (clients)
   (
    English: example augend
   )
   natural number
   {
    ← example augend according to additive arithmetic
   }

  action (clients)
   (
    English: example addend
   )
   natural number
   {
    ← example addend according to additive arithmetic
   }

  action (clients)
   (
    English: example sum
   )
   natural number
   {
    ← example sum according to additive arithmetic
   }
 }

use (clients)
 additive arithmetic with (natural number)
 {
  action (clients)
   (
    English: zero
   )
   natural number
   C: “0”
   C♯: “0”
   JavaScript: “0”
   Kotlin: “0uL”
   Swift: “0”

  action (clients)
   (
    English: one
   )
   natural number
   C: “1”
   C♯: “1”
   JavaScript: “1”
   Kotlin: “1uL”
   Swift: “1”
 }

use (clients)
 incrementation of (natural number)
 {
  action (clients)
   (
    English: increment (value: ↓ natural number)
   )
   C: “++” value “”
   C♯: “++” value “”
   JavaScript: “++” value “”
   Kotlin: “++” value “”
   {
    add (one: natural number) to (↓ value)
   }

  action (clients)
   (
    English: decrement (value: ↓ natural number) skipping underflow check
   )
   C: “¤(2D)¤(2D)” value “”
   C♯: “¤(2D)¤(2D)” value “”
   JavaScript: “¤(2D)¤(2D)” value “”
   Kotlin: “¤(2D)¤(2D)” value “”
   Swift: “” value “ ¤(2D)= 1”

  action (clients)
   (
    English: can decrement (value: natural number)
   )
   truth value
   {
    ← (value) is greater than (zero: natural number)
   }

  action (clients)
   (
    English: successor example
   )
   natural number
   {
    ← one
   }
 }

action (unit)
 (
  English: two
 )
 natural number
 C: “2”
 C♯: “2”
 JavaScript: “2”
 Kotlin: “2uL”
 Swift: “2”

action (unit)
 (
  English: three
 )
 natural number
 C: “3”
 C♯: “3”
 JavaScript: “3”
 Kotlin: “3uL”
 Swift: “3”

action (unit)
 (
  English: six
 )
 natural number
 C: “6”
 C♯: “6”
 JavaScript: “6”
 Kotlin: “6uL”
 Swift: “6”
