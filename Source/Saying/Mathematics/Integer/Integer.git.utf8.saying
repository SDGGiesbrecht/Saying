thing (clients)
 [
  [
   English: An integer; a natural number or a negation thereof.
  ]
  [
   English: {integer} makes the same design tradeoffs as {natural number}. See {natural number} for more information.
  ]
 ]
 (
  español: número entero
  English: integer
  العربية: عدد صحيح
  हिन्दी: पूर्णांक
  português: número inteiro
  русский: целое число
  Deutsch: ganze Zahl
  tiếng Việt: số nguyên
  한국어: 정수
  français : entier relatif
  Türkçe: tam sayı
  italiano: numero intero
  polski: liczba całkowita
  українська: ціле число
  Nederlands: geheel getal
  română: număr întreg
  ελληνικά: ακέραιος αριθμός
  čeština: celé číslo
  magyar: egész szám
  svenska: heltal
  Afrikaans: heelgetal
  dansk: heltal
  suomi: kokonaisluku
  slovenčina: celé číslo
  עברית: מספר שלם
  norsk: heltall
  català: nombre enter
  Gaeilge: slánuimhir
 )
 C: “intmax¤(5F)t” (“stdint”)
 C♯: “long”
 Kotlin: “Long”
 Swift: “Int64”

use (clients)
 general containers of (integer)
 {
  action (clients)
   example
   integer
   {
    ← zero
   }
 }

use (clients)
 comparison of (integer) for equality
 {
  action (clients)
   (first: integer) is (second: integer)
   truth value
   C: “” first “ == ” second “”
   C♯: “” first “ == ” second “”
   JavaScript: “” first “ == ” second “”
   Kotlin: “” first “ == ” second “”
   Swift: «» first “ == ” second „“

  action (clients)
   (first: integer) is not (second: integer)
   truth value
   C: “” first “ != ” second “”
   C♯: “” first “ != ” second “”
   JavaScript: “” first “ != ” second “”
   Kotlin: “” first “ != ” second “”
   Swift: «» first “ != ” second „“

  action (clients)
   hash key (key: integer) with (hasher: ↓ hasher)
   Swift: “” key “.hash(into: ¤(26)” hasher “)”
   {
    hash part (hashing proxy of (key)) with (↓ hasher)
   }

  action (unit)
   (
    English: hash value of (key: integer)
   )
   hash value
   C♯: “” key “.GetHashCode()”
   Kotlin: “” key “.hashCode()”
   {
    ← hash value of (key) according to comparison for equality
   }

  action (clients)
   differing example
   integer
   {
    ← greater example
   }
 }

action (file)
 [
  test {ignore (hashing proxy of (zero: integer))}
 ]
 hashing proxy of (integer: integer)
 platform fixed‐width integer
 C: “(unsigned)” integer “”
 C♯: “” integer “.GetHashCode()”
 JavaScript: “” integer “”
 Kotlin: “” integer “.hashCode()”
 Swift: “Int(truncatingIfNeeded: ” integer “)”

use (clients)
 comparison of (integer) for order
 {
  action (clients)
   (first: integer) is less than (second: integer)
   truth value
   C: “” first “ < ” second “”
   C♯: “” first “ < ” second “”
   JavaScript: “” first “ < ” second “”
   Kotlin: “” first “ < ” second “”
   Swift: «» first “ < ” second „“

  action (clients)
   (first: integer) is greater than (second: integer)
   truth value
   C: “” first “ > ” second “”
   C♯: “” first “ > ” second “”
   JavaScript: “” first “ > ” second “”
   Kotlin: “” first “ > ” second “”
   Swift: «» first “ > ” second „“

  action (clients)
   (first: integer) is less than or equal to (second: integer)
   truth value
   C: “” first “ <= ” second “”
   C♯: “” first “ <= ” second “”
   JavaScript: “” first “ <= ” second “”
   Kotlin: “” first “ <= ” second “”
   Swift: «» first “ <= ” second „“

  action (clients)
   (first: integer) is greater than or equal to (second: integer)
   truth value
   C: “” first “ >= ” second “”
   C♯: “” first “ >= ” second “”
   JavaScript: “” first “ >= ” second “”
   Kotlin: “” first “ >= ” second “”
   Swift: «» first “ >= ” second „“

  action (clients)
   greater example
   integer
   {
    ← one
   }
 }

use (clients)
 addition of (integer)
 {
  action (clients)
   (
    English: add (addend: integer) to (cumulative sum: ↓ integer)
   )
   C: “” cumulative sum “ += ” addend “”
   C♯: “” cumulative sum “ += ” addend “”
   JavaScript: “” cumulative sum “ += ” addend “”
   Kotlin: “” cumulative sum “ += ” addend “”
   Swift: “” cumulative sum “ += ” addend “”

  action (clients)
   (
    English: (augend: integer) plus (addend: integer)
   )
   integer
   C: “” augend “ + ” addend “”
   C♯: “” augend “ + ” addend “”
   JavaScript: “” augend “ + ” addend “”
   Kotlin: “” augend “ + ” addend “”
   Swift: “” augend “ + ” addend “”

  action (clients)
   (
    English: example augend
   )
   integer
   {
    ← example augend according to natural arithmetic
   }

  action (clients)
   (
    English: example addend
   )
   integer
   {
    ← example addend according to natural arithmetic
   }

  action (clients)
   (
    English: example sum
   )
   integer
   {
    ← example sum according to natural arithmetic
   }
 }

use (clients)
 natural additive arithmetic with (integer)
 {
  action (clients)
   (
    English: additive identity
   )
   integer
   {
    ← zero
   }
 }

use (clients)
 additive arithmetic with (integer)
 {
  action (clients)
   (
    English: subtract (subtrahend: integer) from (value: ↓ integer)
   )
   C: “” value “ ¤(2D)= ” subtrahend “”
   C♯: “” value “ ¤(2D)= ” subtrahend “”
   JavaScript: “” value “ ¤(2D)= ” subtrahend “”
   Kotlin: “” value “ ¤(2D)= ” subtrahend “”
   Swift: “” value “ ¤(2D)= ” subtrahend “”

  action (clients)
   (
    English: (minuend: integer) minus (subtrahend: integer)
   )
   integer
   C: “” minuend “ ¤(2D) ” subtrahend “”
   C♯: “” minuend “ ¤(2D) ” subtrahend “”
   JavaScript: “” minuend “ ¤(2D) ” subtrahend “”
   Kotlin: “” minuend “ ¤(2D) ” subtrahend “”
   Swift: “” minuend “ ¤(2D) ” subtrahend “”
 }

use (clients)
 one‐dimensional additive arithmetic with (integer)
 {
 }

use (clients)
 natural arithmetic with (integer)
 {
  action (clients)
   (
    English: zero
   )
   integer
   Swift: “Int64.zero”
   {
    ← “0”
   }

  action (clients)
   (
    English: one
   )
   integer
   {
    ← “1”
   }
 }

use (clients)
 incrementation of (integer)
 {
  action (clients)
   (
    English: increment (value: ↓ integer)
   )
   C: “++” value “”
   C♯: “++” value “”
   JavaScript: “++” value “”
   Kotlin: “++” value “”
   {
    add (one: integer) to (↓ value)
   }

  action (clients)
   (
    English: decrement (value: ↓ integer) skipping underflow check
   )
   C: “¤(2D)¤(2D)” value “”
   C♯: “¤(2D)¤(2D)” value “”
   JavaScript: “¤(2D)¤(2D)” value “”
   Kotlin: “¤(2D)¤(2D)” value “”
   Swift: “” value “ ¤(2D)= 1”

  action (clients)
   (
    English: can decrement (value: integer)
   )
   truth value
   {
    ← true
   }

  action (clients)
   (
    English: successor example
   )
   integer
   {
    ← one
   }
 }
