thing (clients)
 [
  [
   English: A sequence of Unicode scalars in normalized form according to compatibility decomposition (NFKD).
  ]
  test {verify ((“¤(A0)”) is (“¤(20)”))}
  test {verify ((first in (“¤(A8)”)) is (“ ”: Unicode scalar))}
  [
   English: Maintaining normalization means that insertions and removals may also expand or rearrange scalars. Positions and distances recorded before a change are no longer valid afterward.
  ]
 ]
 (
  English: Unicode text
  Swift: UnicodeText
 )
 {
  part (file)
   (
    English: scalars
   )
   Unicode scalars
 }

action (clients)
 [
  [
   English: Creates Unicode text directly from scalars that are already in normalized form, without performing redundant normalization.
  ]
  [
   English: It is generally advised to use the safer variant {Unicode text of ()} instead.
  ]
  [
   English: Skipping normalization can be more efficient when the scalars are already known from context to be in normalized form. However, the caller takes responsibility for the logical soundness of the call. Creating text from scalars that are not in the correct normalized form may cause a fatal error or escape into invalid program state.
  ]
  test {ignore (Unicode text skipping normalization of (“ASCII”: Unicode scalars))}
 ]
 (
  English: Unicode text skipping normalization of (scalars: Unicode scalars)
  Swift: UnicodeText.init skippingNormalizationOf (scalars: [scalars])
 )
 Unicode text
 create

action (clients)
 [
  [
   English: Creates Unicode text by normalizing a sequence of Unicode scalars.
  ]
  test {verify ((Unicode text of (“¤(A0)”: Unicode scalars)) is (“¤(20)”))}
 ]
 (
  English: Unicode text of (scalars: Unicode scalars)
  Swift: UnicodeText.init (scalars: [scalars])
 )
 Unicode text
 {
  ← Unicode text skipping normalization of (compatibility decomposition of (scalars))
 }

action (clients)
 [
  [
   English: Creates Unicode text by normalizing a Unicode scalar.
  ]
  test {verify ((Unicode text of (“¤(A0)”: Unicode scalar)) is (“¤(20)”))}
  test {verify ((Unicode text of (“¤(A8)”: Unicode scalar)) is (“¤(20)¤(308)”))}
 ]
 (
  English: Unicode text of (scalar: Unicode scalar)
 )
 Unicode text
 {
  ← Unicode text of ((scalar) as scalars)
 }

use (clients)
 general containers of (Unicode text)
 {
  action (clients)
   (
    English: example
   )
   Unicode text
   {
    ← non‐empty example
   }
 }

use (clients)
 comparison of (Unicode text) for equality
 {
  action (clients)
   (first: Unicode text) is (second: Unicode text)
   truth value
   {
    ← ((scalars) of (first)) is ((scalars) of (second))
   }

  action (clients)
   hash key (key: Unicode text) with (hasher: ↓ hasher)
   {
    hash part ((scalars) of (key)) with (↓ hasher)
   }

  action (clients)
   differing example
   Unicode text
   {
    ← “!”
   }
 }

use (clients)
 use of (Unicode text) as list of (Unicode scalar) indexed by (Unicode scalar index) separated by (Unicode scalar boundary)
 {
  action (clients)
   (
    English: index after (boundary: Unicode scalar boundary) in (list: Unicode text) skipping bounds check
   )
   Unicode scalar index
   {
    ← index after (boundary) in ((scalars) of (list)) skipping bounds check
   }

  action (clients)
   (
    English: beginning of (list: Unicode text)
   )
   Unicode scalar boundary
   {
    ← beginning of ((scalars) of (list))
   }

  action (clients)
   (
    English: end of (list: Unicode text)
   )
   Unicode scalar boundary
   {
    ← end of ((scalars) of (list))
   }

  action (clients)
   (
    English: advance (cursor: ↓ Unicode scalar boundary) to next in (list: Unicode text) skipping bounds check
   )
   {
    advance (↓ cursor) to next in ((scalars) of (list)) skipping bounds check
   }

  action (clients)
   (
    English: boundary after (cursor: Unicode scalar boundary) in (list: Unicode text) skipping bounds check
   )
   Unicode scalar boundary
   {
    ← boundary after (cursor) in ((scalars) of (list)) skipping bounds check
   }

  action (clients)
   (
    English: entry at (index: Unicode scalar index) in (list: Unicode text)
   )
   Unicode scalar
   {
    ← entry at (index) in ((scalars) of (list))
   }

  action (clients)
   (
    English: entry after (cursor: Unicode scalar boundary) in (list: Unicode text) skipping bounds check
   )
   Unicode scalar
   {
    ← entry after (cursor) in ((scalars) of (list)) skipping bounds check
   }

  action (clients)
   (
    English: first in (list: Unicode text)
   )
   optional (Unicode scalar)
   {
    ← first in ((scalars) of (list))
   }

  action (clients)
   (
    English: (list: Unicode text) is empty
   )
   truth value
   {
    ← ((scalars) of (list)) is empty
   }

  action (clients)
   (
    English: (list: Unicode text) is not empty
   )
   truth value
   {
    ← ((scalars) of (list)) is not empty
   }

  action (clients)
   (
    English: empty
   )
   Unicode text
   {
    ← “”
   }

  action (clients)
   (
    English: non‐empty example
   )
   Unicode text
   {
    ← “ ”
   }
 }

use (clients)
 slicing (Unicode text) as list of (Unicode scalar) indexed by (Unicode scalar index) separated by (Unicode scalar boundary)
 {
 }

use (clients)
 use of (Unicode text) as changeable list of (Unicode scalar) indexed by (Unicode scalar index) separated by (Unicode scalar boundary)
 {
  action (clients)
   (
    English: replace (index: Unicode scalar index) in (list: ↓ Unicode text) with (element: Unicode scalar)
   )
   {
    let (• boundary before: Unicode scalar boundary) be (boundary before (index) in ((scalars) of (list)))
    replace (from (boundary before) to (boundary after (boundary before) in (list) skipping bounds check)) in (↓ list) with (Unicode text of (element))
   }

  action (clients)
   (
    English: insert (element: Unicode scalar) at (boundary: Unicode scalar boundary) in (list: ↓ Unicode text)
   )
   {
    insert (Unicode text of (element)) at (boundary) in (↓ list)
   }

  action (clients)
   (
    English: remove (index: Unicode scalar index) from (list: ↓ Unicode text)
   )
   {
    let (• boundary before: Unicode scalar boundary) be (boundary before (index) in ((scalars) of (list)))
    remove (from (boundary before) to (boundary after (boundary before) in (list) skipping bounds check)) from (↓ list)
   }

  action (clients)
   (
    English: remove (range: range of (Unicode scalar boundary)) from (list: ↓ Unicode text)
   )
   {
    remove (range) from (↓ list) according to list insertion
   }
 }

use (clients)
 insertion from (Unicode text) into (Unicode text) separated by (Unicode scalar boundary)
 {
  action (clients)
   (
    English: replace (range: range of (Unicode scalar boundary)) in (list: ↓ Unicode text) with (insertion: Unicode text)
   )
   {
    let (• end: Unicode scalar boundary) be (end of (list))
    let (• after: Unicode text) be (convert ((from ((upper bound) of (range)) to (end)) in (list)) into list: Unicode text)
    remove (from ((lower bound) of (range)) to (end)) from (↓ (scalars) of (list))
    append (insertion) to (↓ list)
    append (after) to (↓ list)
   }

  action (clients)
   [
    test {verify (((“¤(315)”) with (“¤(300)”) appended) is (“¤(300)¤(315)”))}
   ]
   (
    English: append (appendix: Unicode text) to (list: ↓ Unicode text)
   )
   {
    append ((scalars) of (appendix)) to (↓ (scalars) of (list))
    decompose (↓ (scalars) of (list)) according to compatibility decomposition
   }

  action (clients)
   (
    English: convert (other: Unicode text) into list
   )
   Unicode text
   {
    ← other
   }

  action (clients)
   (
    English: insertion example
   )
   Unicode text
   {
    ← example
   }
 }

use (clients)
 insertion from (slice of (Unicode text)) into (Unicode text) separated by (Unicode scalar boundary)
 {
  action (clients)
   (
    English: replace (range: range of (Unicode scalar boundary)) in (list: ↓ Unicode text) with (insertion: slice of (Unicode text))
   )
   {
    replace (range) in (↓ list) with (convert (insertion) into list)
   }

  action (clients)
   (
    English: convert (other: slice of (Unicode text)) into list
   )
   Unicode text
   {
    ← Unicode text skipping normalization of (convert (((bounds) of (other)) in ((scalars) of ((whole) of (other)))) into list: Unicode scalars)
   }

  action (clients)
   (
    English: insertion example
   )
   slice of (Unicode text)
   {
    ← non‐empty example
   }
 }
