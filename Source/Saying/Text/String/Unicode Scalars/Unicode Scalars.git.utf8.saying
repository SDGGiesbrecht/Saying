thing (clients)
 [
  [
   English: An unnormalized sequence of Unicode scalars.
  ]
  [
   English: {Unicode scalars} always preserves the exact scalar representation; it does not consider canonical or compatibility equivalence and does not apply normalization.
  ]
  test {verify ((“¤(C0)”: Unicode scalars) is not (“A¤(300)”: Unicode scalars))}
  [
   English: However, literals originate in source files, which are text. As such, any tool handling the source files may change their representation. To prevent inconsistency, the compiler reads source files according to compatibility decomposition (NFKD). This means that literals can safely include NFKD scalars directly, but must use escape codes to preserve non‐NFKD scalars.
  ]
  [
   English: Unicode scalars are not null‐terminated; the null control is a valid scalar.
  ]
  test {verify ((“¤(0)”: Unicode scalars) is not empty)}
 ]
 (
  English: Unicode scalars
  C: Unicode‐scalars
 )
 C♯: “string”
 Kotlin: “String”
 Swift: “String.UnicodeScalarView”
 {
  part (file)
   (
    English: 8‐bit encoded
   )
   list of (8‐bit Unicode code unit)
   C♯: “”
   JavaScript: “”
   Kotlin: “”
   Swift: “”
 }

action (clients)
 [
  [
   English: Returns the Unicode scalars of an instance of 8‐bit encoded Unicode (UTF‐8) text without checking that it is valid.
  ]
  [
   English: Skipping the validity check can be more efficient when the encoded text is already known from context to be valid. However, the caller takes responsibility for the logical soundness of the call. Decoding invalid data may cause a fatal error or result in invalid program state.
  ]
  test {ignore (Unicode scalars of (empty: list of (8‐bit Unicode code unit)) skipping validity check)}
 ]
 (
  English: Unicode scalars of (8‐bit encoded: list of (8‐bit Unicode code unit)) skipping validity check
 )
 Unicode scalars
 C♯: “Encoding.UTF8.GetString(” 8‐bit encoded “.ToArray())” (
   “System.Collections.Generic”
   “System.Text”
  )
 JavaScript: “new TextDecoder().decode(Uint8Array.from(” 8‐bit encoded “))”
 Kotlin: “String(” 8‐bit encoded “.toByteArray(), Charsets.UTF¤(5F)8)”
 Swift: “String(bytes: ” 8‐bit encoded “, encoding: .utf8)!.unicodeScalars”
 create

action (file)
 [
  test {ignore (if possible, list boundary at (example: Unicode scalar boundary))}
 ]
 (
  English: if possible, list boundary at (cursor: Unicode scalar boundary)
 )
 list boundary
 C: “” cursor “”
 C♯: “” cursor “”
 JavaScript: “” cursor “”
 Kotlin: “” cursor “”
 {
  ← example
 }

action (file)
 [
  test {ignore (if possible, scalar boundary at (example: list boundary))}
 ]
 (
  English: if possible, scalar boundary at (cursor: list boundary)
 )
 Unicode scalar boundary
 C: “” cursor “”
 C♯: “” cursor “”
 JavaScript: “” cursor “”
 Kotlin: “” cursor “”
 {
  ← example
 }

action (clients)
 [
  [
   English: Returns the Unicode scalars of a string literal as 8‐bit Unicode encoded (UTF‐8) text without checking that it is valid.
  ]
  [
   English: Skipping the validity check is usually more efficient, because the string literal is most often visible at the call site and obviously valid. However, the caller takes responsibility for the logical soundness of the call. Decoding invalid data may cause a fatal error or result in invalid program state.
  ]
  test (hidden) {ignore (Unicode scalars of string literal (empty: string literal of unknown length) ending at (end of empty list: list boundary) skipping validity check)}
 ]
 (
  English: Unicode scalars of string literal (uncounted: string literal of unknown length) ending at (end: list boundary) skipping validity check
  C: Unicode‐scalars‐literal (uncounted: [uncounted]) (end: [end])
 )
 Unicode scalars
 C♯: “” uncounted “”
 JavaScript: “” uncounted “”
 Kotlin: “” uncounted “”
 Swift: “” uncounted “.unicodeScalars”
 {
  ← Unicode scalars of (list in read‐only memory (8‐bit Unicode code units of (uncounted)) ending at (end)) skipping validity check
 }

use (clients)
 general containers of (Unicode scalars)
 {
  action (clients)
   example
   Unicode scalars
   {
    ← “ ”
   }
 }

action (file)
 [
  test {verify (implementation of (“”: Unicode scalars) is (“”: Unicode scalars))}
 ]
 implementation of (first: Unicode scalars) is (second: Unicode scalars)
 truth value
 C♯: “” first “ == ” second “”
 JavaScript: “” first “ == ” second “”
 Kotlin: “” first “ == ” second “”
 Swift: “” first “.elementsEqual(” second “)”
 {
  ← ((8‐bit encoded) of (first)) is ((8‐bit encoded) of (second))
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) be (“ ”: Unicode scalars)
   let (• hasher: hasher) start as (create hasher)
   if most efficient, hash key (scalars) with (↓ hasher) by 8‐bit encoded
  }
 ]
 if most efficient, hash key (key: Unicode scalars) with (hasher: ↓ hasher) by 8‐bit encoded
 C♯: “”
 JavaScript: “”
 Kotlin: “”
 Swift: “”
 {
  hash part ((8‐bit encoded) of (key)) with (↓ hasher)
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) be (“ ”: Unicode scalars)
   let (• hasher: hasher) start as (create hasher)
   if most efficient, hash key (scalars) with (↓ hasher) by iteration
  }
 ]
 if most efficient, hash key (key: Unicode scalars) with (hasher: ↓ hasher) by iteration
 C: “”
 {
  for each (• scalar: Unicode scalar) in (key), {
   hash part (scalar) with (↓ hasher)
  }
 }

use (clients)
 comparison of (Unicode scalars) for equality
 {
  action (clients)
   (first: Unicode scalars) is (second: Unicode scalars)
   truth value
   C♯: “” first “ == ” second “”
   JavaScript: “” first “ == ” second “”
   Kotlin: “” first “ == ” second “”
   {
    ← implementation of (first) is (second)
   }

  action (clients)
   (first: Unicode scalars) is not (second: Unicode scalars)
   truth value
   C♯: “” first “ != ” second “”
   JavaScript: “” first “ != ” second “”
   Kotlin: “” first “ != ” second “”
   Swift: “” first “ != ” second “” [“==(¤(5F): String.UnicodeScalarView, ¤(5F): String.UnicodeScalarView)”] {“extension String.UnicodeScalarView: Equatable {}”}
   {
    ← (first) is not (second) according to comparison for equality
   }

  action (clients)
   hash key (key: Unicode scalars) with (hasher: ↓ hasher)
   {
    if most efficient, hash key (key) with (↓ hasher) by 8‐bit encoded
    if most efficient, hash key (key) with (↓ hasher) by iteration
   }

  action (unit)
   (
    English: hash value of (key: Unicode scalars)
   )
   hash value
   C♯: “” key “.GetHashCode()”
   Kotlin: “” key “.hashCode()”
   {
    ← hash value of (key) according to comparison for equality
   }

  action (clients)
   differing example
   Unicode scalars
   {
    ← “!”
   }
 }

action (file)
 [
  test {
   let (• end: list boundary) be (end of list containing (one: natural number) entries)
   let (• list: unmanaged list of (8‐bit Unicode code unit) of unknown length) start as (allocate memory up to (end): unmanaged list of (8‐bit Unicode code unit) of unknown length)
   let (• beginning: list boundary) be (beginning of (list))
   initialize entry at (index after (beginning) in (list) skipping bounds check) in (↓ list) to (null control code)
   ignore (if most efficient, scalar boundary after (beginning) in (list) ending at (end) skipping bounds check)
   clean (list) up up to (end)
  }
 ]
 (
  English: if most efficient, scalar boundary after (cursor: list boundary) in (list: unmanaged list of (8‐bit Unicode code unit) of unknown length) ending at (end: list boundary) skipping bounds check
 )
 list boundary
 C: “g¤(5F)utf8¤(5F)find¤(5F)next¤(5F)char(” list “ + ” cursor “, ” list “ + ” end “) == NULL ? ” end “ : g¤(5F)utf8¤(5F)find¤(5F)next¤(5F)char(” list “ + ” cursor “, ” list “ + ” end “) ¤(2D) ” list “” (“glib¤(2D)2.0”)
 {
  ← cursor
 }

action (file)
 [
  test {
   let (• end: list boundary) be (end of list containing (one: natural number) entries)
   let (• list: unmanaged list of (8‐bit Unicode code unit) of unknown length) start as (allocate memory up to (end): unmanaged list of (8‐bit Unicode code unit) of unknown length)
   let (• beginning: list boundary) be (beginning of (list))
   initialize entry at (index after (beginning) in (list) skipping bounds check) in (↓ list) to (null control code)
   ignore (if most efficient, scalar beginning at (beginning) in (list))
   clean (list) up up to (end)
  }
 ]
 (
  English: if most efficient, scalar beginning at (cursor: list boundary) in (list: unmanaged list of (8‐bit Unicode code unit) of unknown length)
 )
 Unicode scalar
 C: “g¤(5F)utf8¤(5F)get¤(5F)char(” list “ + ” cursor “)” (“glib¤(2D)2.0”)
 {
  ← example
 }

use (clients)
 use of (Unicode scalars) as list of (Unicode scalar) indexed by (Unicode scalar index) separated by (Unicode scalar boundary)
 {
  action (clients)
   (
    English: index after (boundary: Unicode scalar boundary) in (list: Unicode scalars) skipping bounds check
   )
   Unicode scalar index
   C♯: “” boundary “”
   JavaScript: “” boundary “”
   Kotlin: “” boundary “”
   Swift: “” boundary “”
   {
    ← index after (boundary) skipping bounds check
   }

  action (clients)
   (
    English: beginning of (list: Unicode scalars)
   )
   Unicode scalar boundary
   C♯: “0”
   JavaScript: “0”
   Kotlin: “0”
   Swift: “” list “.startIndex”
   {
    ← if possible, scalar boundary at (beginning of ((8‐bit encoded) of (list)))
   }

  action (clients)
   (
    English: end of (list: Unicode scalars)
   )
   Unicode scalar boundary
   C♯: “” list “.Length”
   JavaScript: “” list “.length”
   Kotlin: “” list “.length”
   Swift: “” list “.endIndex”
   {
    ← if possible, scalar boundary at (end of ((8‐bit encoded) of (list)))
   }

  action (clients)
   (
    English: advance (cursor: ↓ Unicode scalar boundary) to next in (list: Unicode scalars) skipping bounds check
   )
   Swift: “” list “.formIndex(after: ¤(26)” cursor “)”
   {
    change (↓ cursor) to (boundary after (cursor) in (list) skipping bounds check)
   }

  action (clients)
   [
    test (hidden) {
     let (• ASCII: Unicode scalars) be (“ ”: Unicode scalars)
     verify ((boundary after (beginning of (ASCII)) in (ASCII) skipping bounds check) is (end of (ASCII)))
    }
    test (hidden) {
     let (• supplementary: Unicode scalars) be (“¤(10000)”: Unicode scalars)
     verify ((boundary after (beginning of (supplementary)) in (supplementary) skipping bounds check) is (end of (supplementary)))
    }
   ]
   (
    English: boundary after (cursor: Unicode scalar boundary) in (list: Unicode scalars) skipping bounds check
   )
   Unicode scalar boundary
   C♯: “0xD800 <= ” list “[” cursor “] ¤(26)¤(26) ” list “[” cursor “] < 0xDC00 ? ” cursor “ + 2 : ” cursor “ + 1”
   JavaScript: “0xD800 <= ” list “.charCodeAt(” cursor “) ¤(26)¤(26) ” list “.charCodeAt(” cursor “) < 0xDC00 ? ” cursor “ + 2 : ” cursor “ + 1”
   Kotlin: “” list “.offsetByCodePoints(” cursor “, 1)”
   Swift: “” list “.index(after: ” cursor “)”
   {
    ← if possible, scalar boundary at (if most efficient, scalar boundary after (if possible, list boundary at (cursor)) in ((uncounted) of ((unmanaged) of ((8‐bit encoded) of (list)))) ending at (if possible, list boundary at (end of (list))) skipping bounds check)
   }

  action (clients)
   (
    English: entry at (index: Unicode scalar index) in (list: Unicode scalars)
   )
   Unicode scalar
   C♯: “Rune.GetRuneAt(” list “, ” index “)”
   JavaScript: “” list “.codePointAt(” index “)”
   Kotlin: “” list “.codePointAt(” index “)”
   Swift: “” list “[” index “]”
   {
    ← if most efficient, scalar beginning at (if possible, list boundary at ((beginning) of (index))) in ((uncounted) of ((unmanaged) of ((8‐bit encoded) of (list))))
   }

  action (clients)
   (
    English: entry after (cursor: Unicode scalar boundary) in (list: Unicode scalars) skipping bounds check
   )
   Unicode scalar
   C♯: “Rune.GetRuneAt(” list “, ” cursor “)”
   JavaScript: “” list “.codePointAt(” cursor “)”
   Kotlin: “” list “.codePointAt(” cursor “)”
   Swift: “” list “[” cursor “]”
   {
    ← entry after (cursor) in (list) skipping bounds check, according to default use as list
   }

  action (clients)
   (
    English: (list: Unicode scalars) is empty
   )
   truth value
   Kotlin: “” list “.isEmpty()”
   Swift: “” list “.isEmpty”
   {
    ← (list) is empty according to default use as list
   }

  action (clients)
   (
    English: (list: Unicode scalars) is not empty
   )
   truth value
   Kotlin: “” list “.isNotEmpty()”
   {
    ← (list) is not empty according to default use as list
   }

  action (clients)
   (
    English: empty
   )
   Unicode scalars
   Swift: “String.UnicodeScalarView()”
   {
    ← “”
   }

  action (clients)
   (
    English: non‐empty example
   )
   Unicode scalars
   {
    ← “ ”
   }
 }

use (clients)
 slicing (Unicode scalars) as list of (Unicode scalar) indexed by (Unicode scalar index) separated by (Unicode scalar boundary)
 {
 }

action (clients)
 (
  English: boundary before (index: Unicode scalar index) in (scalars: Unicode scalars)
 )
 Unicode scalar boundary
 C♯: “” index “”
 JavaScript: “” index “”
 Kotlin: “” index “”
 Swift: “” index “”
 {
  ← (beginning) of (index)
 }

action (file)
 [
  test {
   let (• end: list boundary) be (end of list containing (six: natural number) entries)
   let (• list: unmanaged list of (8‐bit Unicode code unit) of unknown length) start as (allocate memory up to (end): unmanaged list of (8‐bit Unicode code unit) of unknown length)
   ignore (insert (example: Unicode scalar) into (↓ list))
   clean (list) up up to (end)
  }
 ]
 (
  English: insert (scalar: Unicode scalar) into (buffer: ↓ unmanaged list of (8‐bit Unicode code unit) of unknown length)
 )
 platform fixed‐width integer
 C: “g¤(5F)unichar¤(5F)to¤(5F)utf8(” scalar “, ” buffer “)” (“glib¤(2D)2.0”)
 {
  ← zero
 }

action (file)
 [
  test {ignore (convert (example: platform fixed‐width integer) into natural number implicitly)}
 ]
 (
  English: convert (integer: platform fixed‐width integer) into natural number implicitly
 )
 natural number
 C: “” integer “”
 {
  ← zero
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) start as (empty: Unicode scalars)
   if most efficient, fill (↓ scalars) with (example: Unicode scalar) by 8‐bit encoded
  }
 ]
 (
  English: if most efficient, fill (empty: ↓ Unicode scalars) with (scalar: Unicode scalar) by 8‐bit encoded
 )
 C♯: “”
 JavaScript: “”
 Kotlin: “”
 Swift: “”
 {
  ensure enough storage for (end of list containing (six: natural number) entries) in (↓ (unmanaged) of ((8‐bit encoded) of (empty)))
  let (• length: platform fixed‐width integer) be (insert (scalar) into (↓ (uncounted) of ((unmanaged) of ((8‐bit encoded) of (empty)))))
  change (↓ (end) of ((unmanaged) of ((8‐bit encoded) of (empty)))) to (end of list containing (convert (length) into natural number implicitly) entries)
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) start as (empty: Unicode scalars)
   if most efficient, fill (↓ scalars) with (example: Unicode scalar) by appending
  }
 ]
 (
  English: if most efficient, fill (empty: ↓ Unicode scalars) with (scalar: Unicode scalar) by appending
 )
 C: “”
 C♯: “”
 JavaScript: “”
 Swift: “”
 {
  append (scalar) to (↓ empty)
 }

action (clients)
 [
  test {verify (((“ ”: Unicode scalar) as scalars) is (“ ”: Unicode scalars))}
 ]
 (
  English: (scalar: Unicode scalar) as scalars
 )
 Unicode scalars
 C♯: “” scalar “.ToString()”
 JavaScript: “String.fromCodePoint(” scalar “)”
 Swift: “String(” scalar “).unicodeScalars”
 {
  let (• scalars: Unicode scalars) start as (empty: Unicode scalars)
  if most efficient, fill (↓ scalars) with (scalar) by appending
  if most efficient, fill (↓ scalars) with (scalar) by 8‐bit encoded
  ← scalars
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) start as (empty: Unicode scalars)
   if most efficient, append (example: Unicode scalar) to (↓ scalars) by replacement
  }
 ]
 (
  English: if most efficient, append (element: Unicode scalar) to (list: ↓ Unicode scalars) by replacement
 )
 C: “”
 C♯: “”
 JavaScript: “”
 Swift: “”
 {
  change (↓ list) to ((list) with (element) appended)
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) start as (empty: Unicode scalars)
   if most efficient, append (example: Unicode scalar) to (↓ scalars) by changeable list
  }
 ]
 (
  English: if most efficient, append (element: Unicode scalar) to (list: ↓ Unicode scalars) by changeable list
 )
 Kotlin: “”
 Swift: “”
 {
  append (element) to (↓ list) according to use as changeable list
 }

action (file)
 [
  test {
   let (• list: Unicode scalars) be (non‐empty example: Unicode scalars)
   ignore ((list) with from (beginning of (list)) to (end of (list)) removed)
  }
 ]
 (
  English: (list: Unicode scalars) with from (beginning: Unicode scalar boundary) to (end: Unicode scalar boundary) removed
 )
 Unicode scalars
 C♯: “” list “.Remove(” beginning “, ” end “ ¤(2D) ” beginning “)”
 Kotlin: “” list “.removeRange(” beginning “, ” end “)”
 {
  ← list
 }

action (file)
 [
  test {
   let (• list: Unicode scalars) be (non‐empty example: Unicode scalars)
   ignore (if most efficient, (list) with (from (beginning of (list)) to (end of (list))) removed by bounds)
  }
 ]
 (
  English: if most efficient, (list: Unicode scalars) with (range: range of (Unicode scalar boundary)) removed by bounds
 )
 Unicode scalars
 C: “” hold on (list) “”
 JavaScript: “” list “”
 Swift: “” list “”
 {
  ← (list) with from ((lower bound) of (range)) to ((upper bound) of (range)) removed
 }

action (file)
 [
  test {
   let (• list: Unicode scalars) be (non‐empty example: Unicode scalars)
   ignore (if most efficient, (list) with (from (beginning of (list)) to (end of (list))) removed by changeable list)
  }
 ]
 (
  English: if most efficient, (list: Unicode scalars) with (range: range of (Unicode scalar boundary)) removed by changeable list
 )
 Unicode scalars
 C♯: “” list “”
 Kotlin: “” list “”
 {
  ← (list) with (range) removed according to use as changeable list
 }

use (clients)
 use of (Unicode scalars) as changeable list of (Unicode scalar) indexed by (Unicode scalar index) separated by (Unicode scalar boundary)
 {
  action (clients)
   (
    English: replace (index: Unicode scalar index) in (list: ↓ Unicode scalars) with (element: Unicode scalar)
   )
   {
    let (• lower bound: Unicode scalar boundary) be (boundary before (index) in (list))
    replace (from (lower bound) to (boundary after (lower bound) in (list) skipping bounds check)) in (↓ list) with ((element) as scalars)
   }

  action (clients)
   (
    English: insert (element: Unicode scalar) at (boundary: Unicode scalar boundary) in (list: ↓ Unicode scalars)
   )
   Swift: “” list “.insert(” element “, at: ” boundary “)”
   {
    insert ((element) as scalars) at (boundary) in (↓ list)
   }

  action (clients)
   (
    English: append (element: Unicode scalar) to (list: ↓ Unicode scalars)
   )
   Swift: “” list “.append(” element “)”
   {
    if most efficient, append (element) to (↓ list) by replacement
    if most efficient, append (element) to (↓ list) by changeable list
   }

  action (clients)
   (
    English: (list: Unicode scalars) with (element: Unicode scalar) appended
   )
   Unicode scalars
   Kotlin: “StringBuilder(” list “).appendCodePoint(” element “).toString()”
   {
    ← (list) with ((element) as scalars) appended
   }

  action (clients)
   (
    English: remove (index: Unicode scalar index) from (list: ↓ Unicode scalars)
   )
   Swift: “” list “.remove(at: ” index “)”
   {
    let (• lower bound: Unicode scalar boundary) be (boundary before (index) in (list))
    remove (from (lower bound) to (boundary after (lower bound) in (list) skipping bounds check)) from (↓ list)
   }

  action (clients)
   (
    English: remove (range: range of (Unicode scalar boundary)) from (list: ↓ Unicode scalars)
   )
   Swift: “” list “.removeSubrange(” range “)”
   {
    remove (range) from (↓ list) according to list insertion
   }

  action (clients)
   (
    English: (list: Unicode scalars) with (range: range of (Unicode scalar boundary)) removed
   )
   Unicode scalars
   {
    ← if most efficient, (if most efficient, (list) with (range) removed by bounds) with (range) removed by changeable list
   }
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) start as (example: Unicode scalars)
   if most efficient, replace (from (beginning of (scalars)) to (end of (scalars))) in (↓ scalars) with (scalars) by replacement
  }
 ]
 (
  English: if most efficient, replace (range: range of (Unicode scalar boundary)) in (list: ↓ Unicode scalars) with (insertion: Unicode scalars) by replacement
 )
 C: “”
 Swift: “”
 {
  change (↓ list) to ((list) with (range) replaced with (insertion))
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) start as (example: Unicode scalars)
   if most efficient, replace (from (beginning of (scalars)) to (end of (scalars))) in (↓ scalars) with (scalars) by 8‐bit encoded
  }
 ]
 (
  English: if most efficient, replace (range: range of (Unicode scalar boundary)) in (list: ↓ Unicode scalars) with (insertion: Unicode scalars) by 8‐bit encoded
 )
 C♯: “”
 JavaScript: “”
 Kotlin: “”
 Swift: “”
 {
  let (• converted range: range of (list boundary)) be (from (if possible, list boundary at ((lower bound) of (range))) to (if possible, list boundary at ((upper bound) of (range))))
  replace (converted range) in (↓ (8‐bit encoded) of (list)) with ((8‐bit encoded) of (insertion))
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) be (example: Unicode scalars)
   ignore ((scalars) with (beginning of (scalars)) to (end of (scalars)) replaced with (scalars))
  }
 ]
 (
  English: (list: Unicode scalars) with (beginning: Unicode scalar boundary) to (end: Unicode scalar boundary) replaced with (insertion: Unicode scalars)
 )
 Unicode scalars
 Kotlin: “” list “.replaceRange(” beginning “, ” end “, ” insertion “)”
 {
  ← list
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) be (example: Unicode scalars)
   ignore (if most efficient, (scalars) with (from (beginning of (scalars)) to (end of (scalars))) replaced with (scalars) by bounds)
  }
 ]
 (
  English: if most efficient, (list: Unicode scalars) with (range: range of (Unicode scalar boundary)) replaced with (replacement: Unicode scalars) by bounds
 )
 Unicode scalars
 C: “” hold on (list) “”
 C♯: “” list “”
 JavaScript: “” list “”
 Swift: “” list “”
 {
  ← (list) with ((lower bound) of (range)) to ((upper bound) of (range)) replaced with (replacement)
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) be (example: Unicode scalars)
   ignore (if most efficient, (scalars) with (from (beginning of (scalars)) to (end of (scalars))) replaced with (scalars) by list insertion)
  }
 ]
 (
  English: if most efficient, (list: Unicode scalars) with (range: range of (Unicode scalar boundary)) replaced with (replacement: Unicode scalars) by list insertion
 )
 Unicode scalars
 C♯: “” list “”
 JavaScript: “” list “”
 Kotlin: “” list “”
 {
  ← (list) with (range) replaced with (replacement) according to list insertion
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) be (example: Unicode scalars)
   ignore (if most efficient, (scalars) with (from (beginning of (scalars)) to (end of (scalars))) replaced with (scalars) by appending)
  }
 ]
 (
  English: if most efficient, (list: Unicode scalars) with (range: range of (Unicode scalar boundary)) replaced with (replacement: Unicode scalars) by appending
 )
 Unicode scalars
 C: “” hold on (list) “”
 Kotlin: “” list “”
 Swift: “” list “”
 {
  let (• copy: Unicode scalars) start as (convert from (beginning of (list)) to ((lower bound) of (range)) in (list) into scalars)
  append (replacement) to (↓ copy)
  append (convert from ((upper bound) of (range)) to (end of (list)) in (list) into scalars) to (↓ copy)
  ← copy
 }

use (clients)
 insertion from (Unicode scalars) into (Unicode scalars) separated by (Unicode scalar boundary)
 {
  action (clients)
   (
    English: replace (range: range of (Unicode scalar boundary)) in (list: ↓ Unicode scalars) with (insertion: Unicode scalars)
   )
   Swift: “” list “.replaceSubrange(” range “, with: ” insertion “)”
   {
    if most efficient, replace (range) in (↓ list) with (insertion) by replacement
    if most efficient, replace (range) in (↓ list) with (insertion) by 8‐bit encoded
   }

  action (clients)
   (
    English: (list: Unicode scalars) with (range: range of (Unicode scalar boundary)) replaced with (replacement: Unicode scalars)
   )
   Unicode scalars
   {
    ← if most efficient, (if most efficient, (if most efficient, (list: Unicode scalars) with (range) replaced with (replacement) by bounds) with (range) replaced with (replacement) by list insertion) with (range) replaced with (replacement) by appending
   }

  action (clients)
   (
    English: insert (insertion: Unicode scalars) at (boundary: Unicode scalar boundary) in (list: ↓ Unicode scalars)
   )
   Swift: “” list “.insert(contentsOf: ” insertion “, at: ” boundary “)”
   {
    insert (insertion) at (boundary) in (↓ list) according to list insertion
   }

  action (clients)
   (
    English: (list: Unicode scalars) with (insertion: Unicode scalars) inserted at (boundary: Unicode scalar boundary)
   )
   Unicode scalars
   C♯: “” list “.Insert(” boundary “, ” insertion “)” (“System”)
   Kotlin: “StringBuilder(” list “).insert(” boundary “, ” insertion “).toString()”
   {
    ← (list) with (insertion) inserted at (boundary) according to list insertion
   }

  action (clients)
   (
    English: append (appendix: Unicode scalars) to (list: ↓ Unicode scalars)
   )
   C♯: “” list “ += ” appendix “”
   JavaScript: “” list “ += ” appendix “”
   Kotlin: “” list “ += ” appendix “”
   Swift: “” list “ += ” appendix “”
   {
    append (appendix) to (↓ list) according to list insertion
   }

  action (clients)
   (
    English: (list: Unicode scalars) with (appendix: Unicode scalars) appended
   )
   Unicode scalars
   C♯: “” list “ + ” appendix “”
   JavaScript: “” list “ + ” appendix “”
   Kotlin: “” list “ + ” appendix “”
   Swift: “” list “ + ” appendix “”
   {
    ← (list) with (appendix) appended according to list insertion
   }

  action (clients)
   (
    English: (list: Unicode scalars) with (prefix: Unicode scalars) prepended
   )
   Unicode scalars
   C♯: “” prefix “ + ” list “”
   JavaScript: “” prefix “ + ” list “”
   Kotlin: “” prefix “ + ” list “”
   Swift: “” prefix “ + ” list “”
   {
    ← (list) with (prefix) prepended according to list insertion
   }

  action (clients)
   (
    English: convert (other: Unicode scalars) into list
   )
   Unicode scalars
   C: “” hold on (other) “”
   C♯: “” other “”
   JavaScript: “” other “”
   Kotlin: “” other “”
   Swift: “” other “”

  action (clients)
   (
    English: insertion example
   )
   Unicode scalars
   {
    ← example
   }
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) be (example: Unicode scalars)
   verify ((convert from (beginning of (scalars)) to (end of (scalars)) in (scalars) into scalars) is (scalars))
  }
 ]
 (
  English: convert from (beginning: Unicode scalar boundary) to (end: Unicode scalar boundary) in (scalars: Unicode scalars) into scalars
 )
 Unicode scalars
 C♯: “” scalars “.Substring(” beginning “, ” end “ ¤(2D) ” beginning “)” (“System”)
 JavaScript: “” scalars “.substring(” beginning “, ” end “)”
 Kotlin: “” scalars “.slice(” beginning “..<” end “)”
 {
  ← scalars
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) be (example: Unicode scalars)
   ignore (if most efficient, convert (from (beginning of (scalars)) to (end of (scalars))) in (scalars) into scalars by bounds)
  }
 ]
 (
  English: if most efficient, convert (range: range of (Unicode scalar boundary)) in (scalars: Unicode scalars) into scalars by bounds
 )
 Unicode scalars
 C: “” hold on (scalars) “”
 Swift: “” scalars “”
 {
  ← convert from ((lower bound) of (range)) to ((upper bound) of (range)) in (scalars) into scalars
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) be (example: Unicode scalars)
   ignore (if most efficient, convert (from (beginning of (scalars)) to (end of (scalars))) in (scalars) into scalars by 8‐bit encoded)
  }
 ]
 (
  English: if most efficient, convert (range: range of (Unicode scalar boundary)) in (scalars: Unicode scalars) into scalars by 8‐bit encoded
 )
 Unicode scalars
 C♯: “” scalars “”
 JavaScript: “” scalars “”
 Kotlin: “” scalars “”
 Swift: “” scalars “”
 {
  let (• converted range: range of (list boundary)) be (from (if possible, list boundary at ((lower bound) of (range))) to (if possible, list boundary at ((upper bound) of (range))))
  ← Unicode scalars of (convert ((converted range) in ((8‐bit encoded) of (scalars))) into list) skipping validity check
 }

use (clients)
 insertion from (slice of (Unicode scalars)) into (Unicode scalars) separated by (Unicode scalar boundary)
 {
  action (clients)
   (
    English: replace (range: range of (Unicode scalar boundary)) in (list: ↓ Unicode scalars) with (insertion: slice of (Unicode scalars))
   )
   Swift: “” list “.replaceSubrange(” range “, with: ” insertion “)”
   {
    replace (range) in (↓ list) with (convert (insertion) into list: Unicode scalars)
   }

  action (clients)
   (
    English: insert (insertion: slice of (Unicode scalars)) at (boundary: Unicode scalar boundary) in (list: ↓ Unicode scalars)
   )
   Swift: “” list “.insert(contentsOf: ” insertion “, at: ” boundary “)”
   {
    insert (convert (insertion) into list: Unicode scalars) at (boundary) in (↓ list)
   }

  action (clients)
   (
    English: append (appendix: slice of (Unicode scalars)) to (list: ↓ Unicode scalars)
   )
   Swift: “” list “.append(contentsOf: ” appendix “)”
   {
    append (convert (appendix) into list: Unicode scalars) to (↓ list)
   }

  action (clients)
   (
    English: convert (other: slice of (Unicode scalars)) into list
   )
   Unicode scalars
   Swift: “String.UnicodeScalarView(” other “)”
   {
    let (• bounds: range of (Unicode scalar boundary)) be ((bounds) of (other))
    let (• whole: Unicode scalars) be ((whole) of (other))
    ← if most efficient, convert (bounds) in (if most efficient, convert (bounds) in (whole) into scalars by bounds) into scalars by 8‐bit encoded
   }

  action (clients)
   (
    English: insertion example
   )
   slice of (Unicode scalars)
   {
    ← entirety of (example: Unicode scalars)
   }
 }

action (clients)
 [
  [
   English: Normalizes the scalars according to compatibility decomposition (NFKD).
  ]
  test {
   let (• scalars: Unicode scalars) start as (“¤(A0)”: Unicode scalars)
   decompose (↓ scalars) according to compatibility decomposition
   verify ((scalars) is (“¤(20)”: Unicode scalars))
  }
 ]
 (
  English: decompose (scalars: ↓ Unicode scalars) according to compatibility decomposition
  Swift: (self: [scalars]).decomposeAccordingToCompatibilityDecomposition
 )
 {
  change (↓ scalars) to (compatibility decomposition of (scalars))
 }

action (file)
 [
  [
   English: Ensures Unicode resources have been loaded.
  ]
  [
   English: This action provides a workaround for a bug in Swift’s Foundation module on some platforms. Some of its methods silently fail to do anything if they are called before some internal initialization has been triggered. (As an example, the bug can be demonstrated by attempting decomposedStringWithCompatibilityMapping at the very beginning of an executable created with the Swift Package Manager and running on macOS 12.) This action triggers the initialization required for the relevant methods to work properly.
  ]
 ]
 (
  English: ensure Unicode resources have loaded
 )
 Swift: “ensureUnicodeResourcesHaveLoaded” (“Foundation”) {“private let ensureUnicodeResourcesHaveLoaded: Void = { ¤(5F) = Locale.current }()”}
 {}

action (file)
 [
  test {
   let (• end: list boundary) be (end of list containing (one: natural number) entries)
   let (• list: unmanaged list of (8‐bit Unicode code unit) of unknown length) start as (allocate memory up to (end): unmanaged list of (8‐bit Unicode code unit) of unknown length)
   let (• beginning: list boundary) be (beginning of (list))
   initialize entry at (index after (beginning) in (list) skipping bounds check) in (↓ list) to (null control code)
   clean (if most efficient, compute compatibility decomposition of (list) up to (end)) up up to (end)
   clean (list) up up to (end)
  }
 ]
 (
  English: if most efficient, compute compatibility decomposition of (8‐bit encoded: unmanaged list of (8‐bit Unicode code unit) of unknown length) up to (end: list boundary)
 )
 unmanaged list of (8‐bit Unicode code unit) of unknown length
 C: “g¤(5F)utf8¤(5F)normalize(” 8‐bit encoded “, ” end “, G¤(5F)NORMALIZE¤(5F)ALL)” (“glib¤(2D)2.0”)
 {
  ← 8‐bit encoded
 }

action (file)
 (
  English: compute compatibility decomposition of (scalars: Unicode scalars)
 )
 Unicode scalars
 C♯: “” scalars “.Normalize(NormalizationForm.FormKD)” (
   “System”
   “System.Text”
  )
 JavaScript: “” scalars “.normalize(¤(22)NFKD¤(22))”
 Kotlin: “Normalizer.normalize(” scalars “, Normalizer.Form.NFKD)” (“java.text”)
 Swift: “String(” scalars “).decomposedStringWithCompatibilityMapping.unicodeScalars” (“Foundation”)
 {
  let (• normalized: unmanaged list of (8‐bit Unicode code unit) of unknown length) be (if most efficient, compute compatibility decomposition of ((uncounted) of ((unmanaged) of ((8‐bit encoded) of (scalars)))) up to (if possible, list boundary at (end of (scalars))))
  let (• end: list boundary) start as (end of empty list)
  while ((entry at (index after (end) in (normalized) skipping bounds check) in (normalized)) is not (null control code)), {
   advance (↓ end) to next in (normalized) skipping bounds check
  }
  ← Unicode scalars of (create list with unmanaged list (create unmanaged list with uncounted (normalized), end (end), limit (end) and references (one: platform fixed‐width natural number) where memory is read‐only (false))) skipping validity check
 }

action (clients)
 [
  [
   English: Returns a copy of the scalars normalized according to compatibility decomposition (NFKD).
  ]
  test {verify ((compatibility decomposition of (“¤(A0)”: Unicode scalars)) is (“¤(20)”: Unicode scalars))}
 ]
 (
  English: compatibility decomposition of (scalars: Unicode scalars)
  Swift: (self: [scalars]).compatibilityDecomposition
 )
 Unicode scalars
 {
  ensure Unicode resources have loaded
  ← compute compatibility decomposition of (scalars)
 }
