thing (clients)
 [
  [
   English: An unnormalized sequence of Unicode scalars.
  ]
  [
   English: {Unicode scalars} always preserves the exact scalar representation; it does not consider canonical or compatibility equivalence and does not apply normalization.
  ]
  test {verify ((“¤(C0)”: Unicode scalars) is not (“A¤(300)”: Unicode scalars))}
  [
   English: However, literals originate in source files, which are text. As such, any tool handling the source files may change their representation. To prevent inconsistency, the compiler reads source files according to compatibility decomposition (NFKD). This means that literals can safely include NFKD scalars directly, but must use escape codes to preserve non‐NFKD scalars.
  ]
 ]
 (
  English: Unicode scalars
 )
 C: “reference¤(5F)counted¤(5F)string¤(2A)”/“hold¤(5F)string(” string “)”/“release¤(5F)string(” string “)” (“glib¤(2D)2.0”) {“REFERENCE¤(5F)COUNTING(GString¤(2A), string, g¤(5F)string¤(5F)free, TRUE)”}
 C♯: “string”
 Kotlin: “String”
 Swift: “String.UnicodeScalarView”
 {
 }

use (clients)
 general containers of (Unicode scalars)
 {
  action (clients)
   example
   Unicode scalars
   {
    ← “ ”
   }
 }

action (file)
 [
  test {verify (implementation of (“”: Unicode scalars) is (“”: Unicode scalars))}
 ]
 implementation of (first: Unicode scalars) is (second: Unicode scalars)
 truth value
 C: “g¤(5F)string¤(5F)equal(” first “¤(2D)>target, ” second “¤(2D)>target)”
 C♯: “” first “ == ” second “”
 JavaScript: “” first “ == ” second “”
 Kotlin: “” first “ == ” second “”
 Swift: “” first “.elementsEqual(” second “)”

use (clients)
 comparison of (Unicode scalars) for equality
 {
  action (clients)
   (first: Unicode scalars) is (second: Unicode scalars)
   truth value
   C: “g¤(5F)string¤(5F)equal(” first “¤(2D)>target, ” second “¤(2D)>target)”
   C♯: “” first “ == ” second “”
   JavaScript: “” first “ == ” second “”
   Kotlin: “” first “ == ” second “”
   {
    ← implementation of (first) is (second)
   }

  action (clients)
   (first: Unicode scalars) is not (second: Unicode scalars)
   truth value
   C♯: “” first “ != ” second “”
   JavaScript: “” first “ != ” second “”
   Kotlin: “” first “ != ” second “”
   Swift: “” first “ != ” second “” [“==(¤(5F): String.UnicodeScalarView, ¤(5F): String.UnicodeScalarView)”] {“extension String.UnicodeScalarView: Equatable {}”}
   {
    ← (first) is not (second) according to comparison for equality
   }

  action (clients)
   hash key (key: Unicode scalars) with (hasher: ↓ hasher)
   {
    for each (• scalar: Unicode scalar) in (key), {
     hash part (scalar) with (↓ hasher)
    }
   }

  action (unit)
   (
    English: hash value of (key: Unicode scalars)
   )
   hash value
   C♯: “” key “.GetHashCode()”
   Kotlin: “” key “.hashCode()”
   {
    ← hash value of (key) according to comparison for equality
   }

  action (clients)
   differing example
   Unicode scalars
   {
    ← “!”
   }
 }

use (clients)
 use of (Unicode scalars) as list of (Unicode scalar) indexed by (Unicode scalar index) separated by (Unicode scalar boundary)
 {
  action (clients)
   (
    English: index after (boundary: Unicode scalar boundary) in (list: Unicode scalars) skipping bounds check
   )
   Unicode scalar index
   C: “” boundary “”
   C♯: “” boundary “”
   JavaScript: “” boundary “”
   Kotlin: “” boundary “”
   Swift: “” boundary “”

  action (clients)
   (
    English: beginning of (list: Unicode scalars)
   )
   Unicode scalar boundary
   C: “0”
   C♯: “0”
   JavaScript: “0”
   Kotlin: “0”
   Swift: “” list “.startIndex”

  action (clients)
   (
    English: end of (list: Unicode scalars)
   )
   Unicode scalar boundary
   C: “” list “¤(2D)>target¤(2D)>len”
   C♯: “” list “.Length”
   JavaScript: “” list “.length”
   Kotlin: “” list “.length”
   Swift: “” list “.endIndex”

  action (clients)
   (
    English: advance (cursor: ↓ Unicode scalar boundary) to next in (list: Unicode scalars) skipping bounds check
   )
   Swift: “” list “.formIndex(after: ¤(26)” cursor “)”
   {
    change (↓ cursor) to (boundary after (cursor) in (list) skipping bounds check)
   }

  action (clients)
   [
    test (hidden) {
     let (• ASCII: Unicode scalars) be (“ ”: Unicode scalars)
     verify ((boundary after (beginning of (ASCII)) in (ASCII) skipping bounds check) is (end of (ASCII)))
    }
    test (hidden) {
     let (• supplementary: Unicode scalars) be (“¤(10000)”: Unicode scalars)
     verify ((boundary after (beginning of (supplementary)) in (supplementary) skipping bounds check) is (end of (supplementary)))
    }
   ]
   (
    English: boundary after (cursor: Unicode scalar boundary) in (list: Unicode scalars) skipping bounds check
   )
   Unicode scalar boundary
   C: “g¤(5F)utf8¤(5F)find¤(5F)next¤(5F)char(” list “¤(2D)>target¤(2D)>str + sizeof(gchar) ¤(2A) ” cursor “, ” list “¤(2D)>target¤(2D)>str + sizeof(gchar) ¤(2A) ” list “¤(2D)>target¤(2D)>len) == NULL ? ” list “¤(2D)>target¤(2D)>len : (g¤(5F)utf8¤(5F)find¤(5F)next¤(5F)char(” list “¤(2D)>target¤(2D)>str + sizeof(gchar) ¤(2A) ” cursor “, ” list “¤(2D)>target¤(2D)>str + sizeof(gchar) ¤(2A) ” list “¤(2D)>target¤(2D)>len) ¤(2D) ” list “¤(2D)>target¤(2D)>str) / sizeof(gchar)”
   C♯: “0xD800 <= ” list “[” cursor “] ¤(26)¤(26) ” list “[” cursor “] < 0xDC00 ? ” cursor “ + 2 : ” cursor “ + 1”
   JavaScript: “0xD800 <= ” list “.charCodeAt(” cursor “) ¤(26)¤(26) ” list “.charCodeAt(” cursor “) < 0xDC00 ? ” cursor “ + 2 : ” cursor “ + 1”
   Kotlin: “” list “.offsetByCodePoints(” cursor “, 1)”
   Swift: “” list “.index(after: ” cursor “)”

  action (clients)
   (
    English: entry at (cursor: Unicode scalar index) in (list: Unicode scalars)
   )
   Unicode scalar
   C: “g¤(5F)utf8¤(5F)get¤(5F)char(” list “¤(2D)>target¤(2D)>str + sizeof(gchar) ¤(2A) ” cursor “)”
   C♯: “Rune.GetRuneAt(” list “, ” cursor “)”
   JavaScript: “” list “.codePointAt(” cursor “)”
   Kotlin: “” list “.codePointAt(” cursor “)”
   Swift: “” list “[” cursor “]”

  action (clients)
   (
    English: entry after (cursor: Unicode scalar boundary) in (list: Unicode scalars) skipping bounds check
   )
   Unicode scalar
   C: “g¤(5F)utf8¤(5F)get¤(5F)char(” list “¤(2D)>target¤(2D)>str + sizeof(gchar) ¤(2A) ” cursor “)”
   C♯: “Rune.GetRuneAt(” list “, ” cursor “)”
   JavaScript: “” list “.codePointAt(” cursor “)”
   Kotlin: “” list “.codePointAt(” cursor “)”
   Swift: “” list “[” cursor “]”

  action (clients)
   (
    English: (list: Unicode scalars) is empty
   )
   truth value
   Kotlin: “” list “.isEmpty()”
   Swift: “” list “.isEmpty”
   {
    ← (list) is empty according to default use as list
   }

  action (clients)
   (
    English: (list: Unicode scalars) is not empty
   )
   truth value
   Kotlin: “” list “.isNotEmpty()”
   {
    ← (list) is not empty according to default use as list
   }

  action (clients)
   (
    English: empty
   )
   Unicode scalars
   Swift: “String.UnicodeScalarView()”
   {
    ← “”
   }

  action (clients)
   (
    English: non‐empty example
   )
   Unicode scalars
   {
    ← “ ”
   }
 }

use (clients)
 slicing (Unicode scalars) as list of (Unicode scalar) indexed by (Unicode scalar index) separated by (Unicode scalar boundary)
 {
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) be (“ ”: Unicode scalars)
   verify ((copy of (scalars) appending (“!”: Unicode scalar)) is (“ !”: Unicode scalars))
  }
 ]
 (
  English: copy of (scalars: Unicode scalars) appending (scalar: Unicode scalar)
 )
 Unicode scalars
 C: “reference¤(5F)string(g¤(5F)string¤(5F)append¤(5F)unichar(” scalars “¤(2D)>target, ” scalar “))”
 C♯: “new StringBuilder(” scalars “).Append(” scalar “.ToString()).ToString()” (“System.Text”)
 Kotlin: “StringBuilder(” scalars “).appendCodePoint(” scalar “).toString()”
 {
  let (• copy: Unicode scalars) start as (scalars)
  append (scalar) to (↓ copy)
  ← copy
 }

use (clients)
 use of (Unicode scalars) as changeable list of (Unicode scalar) indexed by (Unicode scalar index) separated by (Unicode scalar boundary)
 {
  action (clients)
   (
    English: append (element: Unicode scalar) to (list: ↓ Unicode scalars)
   )
   Swift: “” list “.append(” element “)”
   {
    change (↓ list) to (copy of (list) appending (element))
   }
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) be (example: Unicode scalars)
   verify ((copy of (scalars) replacing from (beginning of (scalars)) to (end of (scalars)) with (scalars)) is (scalars))
  }
 ]
 (
  English: copy of (list: Unicode scalars) replacing from (beginning: Unicode scalar boundary) to (end: Unicode scalar boundary) with (insertion: Unicode scalars)
 )
 Unicode scalars
 C♯: “” list “.Remove(” beginning “, ” end “ ¤(2D) ” beginning “).Insert(” beginning “, ” insertion “)” (“System”)
 Kotlin: “” list “.replaceRange(” beginning “, ” end “, ” insertion “)”
 {
  let (• copy: Unicode scalars) start as (list)
  replace (from (beginning) to (end)) in (↓ copy) with (insertion)
  ← copy
 }

use (clients)
 insertion from (Unicode scalars) into (Unicode scalars) separated by (Unicode scalar boundary)
 {
  action (clients)
   (
    English: replace (range: range of (Unicode scalar boundary)) in (list: ↓ Unicode scalars) with (insertion: Unicode scalars)
   )
   Swift: “” list “.replaceSubrange(” range “, with: ” insertion “)”
   {
    change (↓ list) to (copy of (list) replacing from ((lower bound) of (range)) to ((upper bound) of (range)) with (insertion))
   }

  action (clients)
   (
    English: insertion example
   )
   Unicode scalars
   {
    ← example
   }
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) be (example: Unicode scalars)
   verify ((isolated copy of slice from (beginning of (scalars)) to (end of (scalars)) in (scalars)) is (scalars))
  }
 ]
 (
  English: isolated copy of slice from (beginning: Unicode scalar boundary) to (end: Unicode scalar boundary) in (scalars: Unicode scalars)
 )
 Unicode scalars
 C♯: “” scalars “.Substring(” beginning “, ” end “ ¤(2D) ” beginning “)” (“System”)
 Kotlin: “” scalars “.slice(” beginning “..<” end “)”
 {
  ← isolated copy of ((from (beginning) to (end)) in (scalars))
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) be (example: Unicode scalars)
   verify ((isolated copy of (entirety of (scalars))) is (scalars))
  }
 ]
 (
  English: isolated copy of (slice: slice of (Unicode scalars))
 )
 Unicode scalars
 Swift: “String.UnicodeScalarView(” slice “)”
 {
  ← isolated copy of slice from (beginning of (slice)) to (end of (slice)) in ((whole) of (slice))
 }

use (clients)
 insertion from (slice of (Unicode scalars)) into (Unicode scalars) separated by (Unicode scalar boundary)
 {
  action (clients)
   (
    English: replace (range: range of (Unicode scalar boundary)) in (list: ↓ Unicode scalars) with (insertion: slice of (Unicode scalars))
   )
   Swift: “” list “.replaceSubrange(” range “, with: ” insertion “)”
   {
    change (↓ list) to (copy of (list) replacing from ((lower bound) of (range)) to ((upper bound) of (range)) with (isolated copy of (insertion)))
   }

  action (clients)
   (
    English: insertion example
   )
   slice of (Unicode scalars)
   {
    ← entirety of (example: Unicode scalars)
   }
 }

action (clients)
 [
  [
   English: Returns a copy of the scalars normalized according to compatibility decomposition (NFKD).
  ]
  test {verify ((compatibility decomposition of (“¤(A0)”: Unicode scalars)) is (“¤(20)”: Unicode scalars))}
 ]
 (
  English: compatibility decomposition of (scalars: Unicode scalars)
 )
 Unicode scalars
 C: “reference¤(5F)string(g¤(5F)string¤(5F)copying¤(5F)and¤(5F)freeing(g¤(5F)utf8¤(5F)normalize(” scalars “¤(2D)>target¤(2D)>str, ” scalars “¤(2D)>target¤(2D)>len, G¤(5F)NORMALIZE¤(5F)ALL)))” {“GString¤(2A) g¤(5F)string¤(5F)copying¤(5F)and¤(5F)freeing(gchar¤(2A) init)¤(A){¤(A)GString¤(2A) string = g¤(5F)string¤(5F)new(init);¤(A)free(init);¤(A)return string;¤(A)}”}
 C♯: “” scalars “.Normalize(NormalizationForm.FormKD)” (
  “System”
  “System.Text”
  )
 JavaScript: “” scalars “.normalize(¤(22)NFKD¤(22))”
 Kotlin: “Normalizer.normalize(” scalars “, Normalizer.Form.NFKD)” (“java.text”)
 Swift: “String(” scalars “).decomposedStringWithCompatibilityMapping.unicodeScalars” (“Foundation”)
