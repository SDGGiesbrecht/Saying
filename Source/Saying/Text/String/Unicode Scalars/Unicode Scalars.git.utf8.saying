thing (clients)
 [
  [
   English: An unnormalized sequence of Unicode scalars.
  ]
  [
   English: {Unicode scalars} always preserves the exact scalar representation; it does not consider canonical or compatibility equivalence and does not apply normalization.
  ]
  test {verify ((“¤(C0)”: Unicode scalars) is not (“A¤(300)”: Unicode scalars))}
  [
   English: However, literals originate in source files, which are text. As such, any tool handling the source files may change their representation. To prevent inconsistency, the compiler reads source files according to compatibility decomposition (NFKD). This means that literals can safely include NFKD scalars directly, but must use escape codes to preserve non‐NFKD scalars.
  ]
 ]
 (
  English: Unicode scalars
 )
 C: “reference¤(5F)counted¤(5F)string¤(2A)”/“hold¤(5F)string(” string “)”/“release¤(5F)string(” string “)” (“glib¤(2D)2.0”) {“REFERENCE¤(5F)COUNTING(GString¤(2A), string, g¤(5F)string¤(5F)free, TRUE)”}
 C♯: “string”
 Kotlin: “String”
 Swift: “String.UnicodeScalarView”
 {
 }

use (clients)
 general containers of (Unicode scalars)
 {
  action (clients)
   example
   Unicode scalars
   {
    ← “ ”
   }
 }

action (file)
 [
  test {verify (implementation of (“”: Unicode scalars) is (“”: Unicode scalars))}
 ]
 implementation of (first: Unicode scalars) is (second: Unicode scalars)
 truth value
 C: “g¤(5F)string¤(5F)equal(” first “¤(2D)>target, ” second “¤(2D)>target)”
 C♯: “” first “ == ” second “”
 JavaScript: “” first “ == ” second “”
 Kotlin: “” first “ == ” second “”
 Swift: “” first “.elementsEqual(” second “)”

use (clients)
 comparison of (Unicode scalars) for equality
 {
  action (clients)
   (first: Unicode scalars) is (second: Unicode scalars)
   truth value
   C: “g¤(5F)string¤(5F)equal(” first “¤(2D)>target, ” second “¤(2D)>target)”
   C♯: “” first “ == ” second “”
   JavaScript: “” first “ == ” second “”
   Kotlin: “” first “ == ” second “”
   {
    ← implementation of (first) is (second)
   }

  action (clients)
   (first: Unicode scalars) is not (second: Unicode scalars)
   truth value
   C♯: “” first “ != ” second “”
   JavaScript: “” first “ != ” second “”
   Kotlin: “” first “ != ” second “”
   Swift: “” first “ != ” second “” [“==(¤(5F): String.UnicodeScalarView, ¤(5F): String.UnicodeScalarView)”] {“extension String.UnicodeScalarView: Equatable {}”}
   {
    ← (first) is not (second) according to comparison for equality
   }

  action (clients)
   hash key (key: Unicode scalars) with (hasher: ↓ hasher)
   {
    for each (• scalar: Unicode scalar) in (key), {
     hash part (scalar) with (↓ hasher)
    }
   }

  action (unit)
   (
    English: hash value of (key: Unicode scalars)
   )
   hash value
   C♯: “” key “.GetHashCode()”
   Kotlin: “” key “.hashCode()”
   {
    ← hash value of (key) according to comparison for equality
   }

  action (clients)
   differing example
   Unicode scalars
   {
    ← “!”
   }
 }

use (clients)
 use of (Unicode scalars) as list of (Unicode scalar) indexed by (Unicode scalar index) separated by (Unicode scalar boundary)
 {
  action (clients)
   (
    English: index after (boundary: Unicode scalar boundary) in (list: Unicode scalars) skipping bounds check
   )
   Unicode scalar index
   C: “” boundary “”
   C♯: “” boundary “”
   JavaScript: “” boundary “”
   Kotlin: “” boundary “”
   Swift: “” boundary “”

  action (clients)
   (
    English: beginning of (list: Unicode scalars)
   )
   Unicode scalar boundary
   C: “0”
   C♯: “0”
   JavaScript: “0”
   Kotlin: “0”
   Swift: “” list “.startIndex”

  action (clients)
   (
    English: end of (list: Unicode scalars)
   )
   Unicode scalar boundary
   C: “” list “¤(2D)>target¤(2D)>len”
   C♯: “” list “.Length”
   JavaScript: “” list “.length”
   Kotlin: “” list “.length”
   Swift: “” list “.endIndex”

  action (clients)
   (
    English: advance (cursor: ↓ Unicode scalar boundary) to next in (list: Unicode scalars) skipping bounds check
   )
   Swift: “” list “.formIndex(after: ¤(26)” cursor “)”
   {
    change (↓ cursor) to (boundary after (cursor) in (list) skipping bounds check)
   }

  action (clients)
   [
    test (hidden) {
     let (• ASCII: Unicode scalars) be (“ ”: Unicode scalars)
     verify ((boundary after (beginning of (ASCII)) in (ASCII) skipping bounds check) is (end of (ASCII)))
    }
    test (hidden) {
     let (• supplementary: Unicode scalars) be (“¤(10000)”: Unicode scalars)
     verify ((boundary after (beginning of (supplementary)) in (supplementary) skipping bounds check) is (end of (supplementary)))
    }
   ]
   (
    English: boundary after (cursor: Unicode scalar boundary) in (list: Unicode scalars) skipping bounds check
   )
   Unicode scalar boundary
   C: “g¤(5F)utf8¤(5F)find¤(5F)next¤(5F)char(” list “¤(2D)>target¤(2D)>str + sizeof(gchar) ¤(2A) ” cursor “, ” list “¤(2D)>target¤(2D)>str + sizeof(gchar) ¤(2A) ” list “¤(2D)>target¤(2D)>len) == NULL ? ” list “¤(2D)>target¤(2D)>len : (g¤(5F)utf8¤(5F)find¤(5F)next¤(5F)char(” list “¤(2D)>target¤(2D)>str + sizeof(gchar) ¤(2A) ” cursor “, ” list “¤(2D)>target¤(2D)>str + sizeof(gchar) ¤(2A) ” list “¤(2D)>target¤(2D)>len) ¤(2D) ” list “¤(2D)>target¤(2D)>str) / sizeof(gchar)”
   C♯: “0xD800 <= ” list “[” cursor “] ¤(26)¤(26) ” list “[” cursor “] < 0xDC00 ? ” cursor “ + 2 : ” cursor “ + 1”
   JavaScript: “0xD800 <= ” list “.charCodeAt(” cursor “) ¤(26)¤(26) ” list “.charCodeAt(” cursor “) < 0xDC00 ? ” cursor “ + 2 : ” cursor “ + 1”
   Kotlin: “” list “.offsetByCodePoints(” cursor “, 1)”
   Swift: “” list “.index(after: ” cursor “)”

  action (clients)
   (
    English: entry at (cursor: Unicode scalar index) in (list: Unicode scalars)
   )
   Unicode scalar
   C: “g¤(5F)utf8¤(5F)get¤(5F)char(” list “¤(2D)>target¤(2D)>str + sizeof(gchar) ¤(2A) ” cursor “)”
   C♯: “Rune.GetRuneAt(” list “, ” cursor “)”
   JavaScript: “” list “.codePointAt(” cursor “)”
   Kotlin: “” list “.codePointAt(” cursor “)”
   Swift: “” list “[” cursor “]”

  action (clients)
   (
    English: entry after (cursor: Unicode scalar boundary) in (list: Unicode scalars) skipping bounds check
   )
   Unicode scalar
   C: “g¤(5F)utf8¤(5F)get¤(5F)char(” list “¤(2D)>target¤(2D)>str + sizeof(gchar) ¤(2A) ” cursor “)”
   C♯: “Rune.GetRuneAt(” list “, ” cursor “)”
   JavaScript: “” list “.codePointAt(” cursor “)”
   Kotlin: “” list “.codePointAt(” cursor “)”
   Swift: “” list “[” cursor “]”

  action (clients)
   (
    English: (list: Unicode scalars) is empty
   )
   truth value
   Kotlin: “” list “.isEmpty()”
   Swift: “” list “.isEmpty”
   {
    ← (list) is empty according to default use as list
   }

  action (clients)
   (
    English: (list: Unicode scalars) is not empty
   )
   truth value
   Kotlin: “” list “.isNotEmpty()”
   {
    ← (list) is not empty according to default use as list
   }

  action (clients)
   (
    English: empty
   )
   Unicode scalars
   Swift: “String.UnicodeScalarView()”
   {
    ← “”
   }

  action (clients)
   (
    English: non‐empty example
   )
   Unicode scalars
   {
    ← “ ”
   }
 }

use (clients)
 slicing (Unicode scalars) as list of (Unicode scalar) indexed by (Unicode scalar index) separated by (Unicode scalar boundary)
 {
 }

action (file)
 (
  English: boundary before (index: Unicode scalar index) in (scalars: Unicode scalars)
 )
 Unicode scalar boundary
 C: “” index “”
 C♯: “” index “”
 JavaScript: “” index “”
 Kotlin: “” index “”
 Swift: “” index “”

action (clients)
 [
  test {verify (((“ ”: Unicode scalar) as scalars) is (“ ”: Unicode scalars))}
 ]
 (
  English: (scalar: Unicode scalar) as scalars
 )
 Unicode scalars
 C♯: “” scalar “.ToString()”
 JavaScript: “String.fromCodePoint(” scalar “)”
 Swift: “String(” scalar “).unicodeScalars”
 {
  let (• scalars: Unicode scalars) start as (empty: Unicode scalars)
  append (scalar) to (↓ scalars)
  ← scalars
 }

action (file)
 [
  test {
   let (• list: Unicode scalars) start as (“ ”: Unicode scalars)
   remove from (beginning of (list)) to (end of (list)) in (↓ list)
   verify ((list) is (“”: Unicode scalars))
  }
 ]
 (
  English: remove from (beginning: Unicode scalar boundary) to (end: Unicode scalar boundary) in (list: ↓ Unicode scalars)
 )
 C: “g¤(5F)array¤(5F)erase((” list “)¤(2D)>target, ” beginning “, ” end “ ¤(2D) ” beginning “)”
 C♯: “” list “.Remove(” beginning “, ” end “ ¤(2D) ” beginning “)”
 Kotlin: “StringBuilder(” list “).deleteRange(” beginning “, ” end “).toString()”
 {
  replace from (beginning) to (end) in (↓ list) with (empty: Unicode scalars)
 }

action (clients)
 [
  test {
   let (• list: Unicode scalars) be (non‐empty example: Unicode scalars)
   ignore ((list) with from (beginning of (list)) to (end of (list)) removed)
  }
 ]
 (
  English: (list: Unicode scalars) with from (beginning: Unicode scalar boundary) to (end: Unicode scalar boundary) removed
 )
 Unicode scalars
 Kotlin: “” list “.removeRange(” beginning “, ” end “)”
 {
  ← (list) with (from (beginning) to (end)) removed according to use as changeable list
 }

use (clients)
 use of (Unicode scalars) as changeable list of (Unicode scalar) indexed by (Unicode scalar index) separated by (Unicode scalar boundary)
 {
  action (clients)
   (
    English: replace (index: Unicode scalar index) in (list: ↓ Unicode scalars) with (element: Unicode scalar)
   )
   Swift: “” list “[” index “] = ” element “”
   {
    let (• lower bound) be (boundary before (index))
    replace (from (lower bound) to (boundary after (lower bound) in (list) skipping bounds check)) in (↓ list) with ((element) as scalars)
   }

  action (clients)
   (
    English: insert (element: element) at (boundary: boundary) in (list: ↓ list)
   )
   C: “g¤(5F)string¤(5F)insert¤(5F)unichar((” list “)¤(2D)>target, ” boundary “, ” element “)”
   Swift: “” list “.insert(” element “, at: ” boundary “)”
   {
    insert ((element) as scalars) at (boundary before (index) in (list))
   }

  action (clients)
   (
    English: append (element: Unicode scalar) to (list: ↓ Unicode scalars)
   )
   C: “g¤(5F)string¤(5F)append¤(5F)unichar((” list “)¤(2D)>target, ” element “)”
   Swift: “” list “.append(” element “)”
   {
    change (↓ list) to ((list) with (element) appended)
   }

  action (clients)
   (
    English: (list: Unicode scalars) with (element: Unicode scalar) appended
   )
   Unicode scalars
   Kotlin: “StringBuilder(” list “).appendCodePoint(” element “).toString()”
   {
    ← (list) with ((element) as scalars) appended
   }

  action (clients)
   (
    English: prepend (element: Unicode scalar) to (list: ↓ Unicode scalars)
   )
   C: “g¤(5F)string¤(5F)prepend¤(5F)unichar((” list “)¤(2D)>target, ” element “)”
   {
    ← prepend (element) to (↓ list) according to use as changeable list
   }

  action (clients)
   (
    English: remove (index: index) from (list: ↓ list)
   )
   Swift: “” list “.remove(at: ” index “)”
   {
    let (• lower bound) be (boundary before (index))
    remove (from (lower bound) to (boundary after (lower bound))) from (↓ list)
   }

  action (clients)
   (
    English: remove (range: range of (boundary)) from (list: ↓ list)
   )
   Swift: “” list “.removeSubrange(” range “)”
   {
    ← remove from ((lower bound) of (range)) to ((lower bound) of (range)) from (↓ list)
   }

  action (clients)
   (
    English: (list: list) with (range: range of (boundary)) removed
   )
   {
    ← (list) with from ((lower bound) of (range)) to ((upper bound) of (range)) removed
   }
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) be (example: Unicode scalars)
   verify (((scalars) with (beginning of (scalars)) to (end of (scalars)) replaced with (scalars)) is (scalars))
  }
 ]
 (
  English: (list: Unicode scalars) with (beginning: Unicode scalar boundary) to (end: Unicode scalar boundary) replaced with (insertion: Unicode scalars)
 )
 Unicode scalars
 Kotlin: “” list “.replaceRange(” beginning “, ” end “, ” insertion “)”
 {
  let (• copy: Unicode scalars) start as (convert from (beginning of (list)) to (beginning) in (list) into scalars)
  append (insertion) to (↓ copy)
  append (convert from (end) to (end of (list)) in (list) into scalars) to (↓ copy)
  ← copy
 }

use (clients)
 insertion from (Unicode scalars) into (Unicode scalars) separated by (Unicode scalar boundary)
 {
  action (clients)
   (
    English: replace (range: range of (Unicode scalar boundary)) in (list: ↓ Unicode scalars) with (insertion: Unicode scalars)
   )
   Swift: “” list “.replaceSubrange(” range “, with: ” insertion “)”
   {
    change (↓ list) to ((list) with ((lower bound) of (range)) to ((upper bound) of (range)) replaced with (insertion))
   }

  action (clients)
   (
    English: insert (insertion: Unicode scalars) at (boundary: Unicode scalar boundary) in (list: ↓ Unicode scalars)
   )
   C: “g¤(5F)string¤(5F)insert((” list “)¤(2D)>target, ” boundary “, ” insertion “¤(2D)>target¤(2D)>str)”
   Swift: “” list “.insert(contentsOf: ” insertion “, at: ” boundary “)”
   {
    insert (insertion) at (boundary) in (↓ list) according to list insertion
   }

  action (clients)
   (
    English: (list: Unicode scalars) with (insertion: Unicode scalars) inserted at (boundary: Unicode scalar boundary)
   )
   Unicode scalars
   C♯: “” list “.Insert(” boundary “, ” insertion “)” (“System”)
   Kotlin: “StringBuilder(” list “).insert(” boundary “, ” insertion “).toString()”
   {
    ← (list) with (insertion) inserted at (boundary) according to list insertion
   }

  action (clients)
   (
    English: append (appendix: Unicode scalars) to (list: ↓ Unicode scalars)
   )
   C: “g¤(5F)string¤(5F)append((” list “)¤(2D)>target, ” appendix “¤(2D)>target¤(2D)>str)”
   C♯: “” list “ += ” appendix “”
   JavaScript: “” list “ += ” appendix “”
   Kotlin: “” list “ += ” appendix “”
   Swift: “” list “ += ” appendix “”

  action (clients)
   (
    English: (list: Unicode scalars) with (appendix: Unicode scalars) appended
   )
   Unicode scalars
   C♯: “” list “ + ” appendix “”
   JavaScript: “” list “ + ” appendix “”
   Kotlin: “” list “ + ” appendix “”
   Swift: “” list “ + ” appendix “”
   {
    ← (list) with (appendix) appended according to list insertion
   }

  action (clients)
   (
    English: prepend (prefix: Unicode scalars) to (list: ↓ Unicode scalars)
   )
   C: “g¤(5F)string¤(5F)prepend((” list “)¤(2D)>target, ” prefix “¤(2D)>target¤(2D)>str)”
   {
    prepend (prefix) to (↓ list) according to list insertion
   }

  action (clients)
   (
    English: (list: Unicode scalars) with (prefix: Unicode scalars) prepended
   )
   Unicode scalars
   C♯: “” prefix “ + ” list “”
   JavaScript: “” prefix “ + ” list “”
   Kotlin: “” prefix “ + ” list “”
   Swift: “” prefix “ + ” list “”
   {
    ← (list) with (prefix) prepended according to list insertion
   }

  action (clients)
   (
    English: convert (other: Unicode scalars) into list
   )
   Unicode scalars
   C: “” other “”
   C♯: “” other “”
   JavaScript: “” other “”
   Kotlin: “” other “”
   Swift: “” other “”

  action (clients)
   (
    English: insertion example
   )
   Unicode scalars
   {
    ← example
   }
 }

action (file)
 [
  test {
   let (• scalars: Unicode scalars) be (example: Unicode scalars)
   verify ((convert from (beginning of (scalars)) to (end of (scalars)) in (scalars) into scalars) is (scalars))
  }
 ]
 (
  English: convert from (beginning: Unicode scalar boundary) to (end: Unicode scalar boundary) in (scalars: Unicode scalars) into scalars
 )
 Unicode scalars
 C: “reference¤(5F)string(g¤(5F)string¤(5F)copying¤(5F)and¤(5F)freeing¤(5F)for¤(5F)slicing(g¤(5F)utf8¤(5F)substring(” scalars “¤(2D)>target¤(2D)>str, ” beginning “, ” end “)))” {“GString¤(2A) g¤(5F)string¤(5F)copying¤(5F)and¤(5F)freeing¤(5F)for¤(5F)slicing(gchar¤(2A) init)¤(A){¤(A)GString¤(2A) string = g¤(5F)string¤(5F)new(init);¤(A)free(init);¤(A)return string;¤(A)}”}
 C♯: “” scalars “.Substring(” beginning “, ” end “ ¤(2D) ” beginning “)” (“System”)
 JavaScript: “” scalars “.substring(” beginning “, ” end “)”
 Kotlin: “” scalars “.slice(” beginning “..<” end “)”
 {
  ← convert ((from (beginning) to (end)) in (scalars)) into list
 }

use (clients)
 insertion from (slice of (Unicode scalars)) into (Unicode scalars) separated by (Unicode scalar boundary)
 {
  action (clients)
   (
    English: replace (range: range of (Unicode scalar boundary)) in (list: ↓ Unicode scalars) with (insertion: slice of (Unicode scalars))
   )
   Swift: “” list “.replaceSubrange(” range “, with: ” insertion “)”
   {
    replace (range) in (↓ list) with (convert (insertion) into list: Unicode scalars)
   }

  action (clients)
   (
    English: insert (insertion: slice of (Unicode scalars)) at (boundary: Unicode scalar boundary) in (list: ↓ Unicode scalars)
   )
   Swift: “” list “.insert(contentsOf: ” insertion “, at: ” boundary “)”
   {
    insert (convert (insertion) into list: Unicode scalars) at (boundary) in (↓ list)
   }

  action (clients)
   (
    English: append (appendix: slice of (Unicode scalars)) to (list: ↓ Unicode scalars)
   )
   Swift: “” list “.append(contentsOf: ” appendix “)”
   {
    append (convert (appendix) into list: Unicode scalars) to (↓ list)
   }

  action (clients)
   (
    English: convert (other: slice of (Unicode scalars)) into list
   )
   Unicode scalars
   Swift: “String.UnicodeScalarView(” other “)”
   {
    ← convert from (beginning of (other)) to (end of (other)) in ((whole) of (other)) into scalars
   }

  action (clients)
   (
    English: insertion example
   )
   slice of (Unicode scalars)
   {
    ← entirety of (example: Unicode scalars)
   }
 }

action (clients)
 [
  [
   English: Returns a copy of the scalars normalized according to compatibility decomposition (NFKD).
  ]
  test {verify ((compatibility decomposition of (“¤(A0)”: Unicode scalars)) is (“¤(20)”: Unicode scalars))}
 ]
 (
  English: compatibility decomposition of (scalars: Unicode scalars)
 )
 Unicode scalars
 C: “reference¤(5F)string(g¤(5F)string¤(5F)copying¤(5F)and¤(5F)freeing¤(5F)for¤(5F)normalization(g¤(5F)utf8¤(5F)normalize(” scalars “¤(2D)>target¤(2D)>str, ” scalars “¤(2D)>target¤(2D)>len, G¤(5F)NORMALIZE¤(5F)ALL)))” {“GString¤(2A) g¤(5F)string¤(5F)copying¤(5F)and¤(5F)freeing¤(5F)for¤(5F)normalization(gchar¤(2A) init)¤(A){¤(A)GString¤(2A) string = g¤(5F)string¤(5F)new(init);¤(A)free(init);¤(A)return string;¤(A)}”}
 C♯: “” scalars “.Normalize(NormalizationForm.FormKD)” (
  “System”
  “System.Text”
  )
 JavaScript: “” scalars “.normalize(¤(22)NFKD¤(22))”
 Kotlin: “Normalizer.normalize(” scalars “, Normalizer.Form.NFKD)” (“java.text”)
 Swift: “String(” scalars “).decomposedStringWithCompatibilityMapping.unicodeScalars” (“Foundation”)
